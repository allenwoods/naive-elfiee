# Frontend Development Guide

This guide explains how to work with the Elfiee frontend codebase, focusing on type-safe communication with the Tauri backend.

## Overview

Elfiee uses **Tauri Specta v2** to automatically generate TypeScript bindings from Rust code. This ensures:
- **Type safety**: TypeScript types are automatically synced with Rust types
- **No manual updates**: Changes to backend types/commands automatically reflect in frontend
- **Consistent naming**: Rust `snake_case` is automatically converted to TypeScript `camelCase`

## Architecture

```
Backend (Rust)                    Frontend (TypeScript)
├─ src/models/                    ├─ src/bindings.ts (auto-generated)
│  ├─ block.rs                    │  ├─ Block type
│  ├─ command.rs                  │  ├─ Command type
│  ├─ event.rs                    │  ├─ Event type
│  └─ ...                         │  └─ commands.*()
├─ src/commands/                  │
│  ├─ file.rs                     ├─ src/lib/tauri-client.ts (wrapper)
│  └─ block.rs                    │  └─ High-level API wrappers
└─ src/lib.rs                     │
   └─ Specta Builder config       └─ Your components
```

## Auto-Generated Bindings

### Location
`src/bindings.ts` - **DO NOT EDIT THIS FILE MANUALLY**

This file is auto-generated every time you run `pnpm tauri dev`. It contains:
1. All Tauri command functions
2. All data types (Block, Command, Event, etc.)
3. Type-safe wrappers with Result types

### When Bindings are Regenerated
- Automatically on `pnpm tauri dev` (debug mode only)
- On every Tauri app startup in development
- **NOT** in release builds (uses standard Tauri handlers)

### Example Generated Code

**Rust Backend:**
```rust
#[tauri::command]
#[specta]
pub async fn execute_command(
    file_id: String,
    cmd: Command,
    state: State<'_, AppState>,
) -> Result<Vec<Event>, String>
```

**Generated TypeScript:**
```typescript
async executeCommand(
  fileId: string,  // snake_case → camelCase
  cmd: Command
): Promise<Result<Event[], string>>
```

## Using the Bindings

### Import from Bindings
```typescript
import { commands, type Block, type Command, type Event } from '@/bindings';
```

### Calling Commands
All generated commands return a `Result` type for error handling:

```typescript
const result = await commands.executeCommand(fileId, cmd);

if (result.status === 'ok') {
  const events: Event[] = result.data;
  // Handle success
} else {
  const error: string = result.error;
  // Handle error
}
```

### Using the Tauri Client Wrapper
For convenience, use the high-level wrapper in `src/lib/tauri-client.ts`:

```typescript
import { TauriClient } from '@/lib/tauri-client';

// File operations
const fileId = await TauriClient.file.createFile();
await TauriClient.file.saveFile(fileId);

// Block operations
const blocks = await TauriClient.block.getAllBlocks(fileId);
const events = await TauriClient.block.createBlock(
  fileId,
  'block-1',
  null,
  { type: 'text', data: 'Hello' }
);
```

The wrapper automatically unwraps `Result` types and throws errors.

## Adding New Backend Commands

### 1. Define the Command in Rust
```rust
// src/commands/my_commands.rs
use specta::specta;
use tauri::State;

#[tauri::command]
#[specta]  // ← Required for binding generation
pub async fn my_new_command(
    param1: String,
    param2: i32,
) -> Result<MyReturnType, String> {
    // Implementation
}
```

### 2. Register the Command
```rust
// src/lib.rs
#[cfg(debug_assertions)]
let specta_builder = tauri_specta::Builder::<tauri::Wry>::new()
    .commands(tauri_specta::collect_commands![
        // ... existing commands
        commands::my_commands::my_new_command,  // ← Add here
    ]);
```

### 3. Run the App
```bash
pnpm tauri dev
```

The bindings will be automatically regenerated with your new command!

### 4. Use in Frontend
```typescript
import { commands } from '@/bindings';

const result = await commands.myNewCommand('hello', 42);
```

## Capability Payload Types

### Why Payload Types Matter

When creating capabilities that require input data, **always define Rust payload structs** instead of using raw JSON parsing. This ensures frontend-backend type consistency and prevents runtime errors.

### Bad Practice ❌
```rust
// Backend: Manual JSON parsing (BAD!)
let content = cmd.payload.get("content")
    .and_then(|v| v.as_str())
    .ok_or("Missing content")?;
```

```typescript
// Frontend: Manual interface definition (can drift!)
interface WriteBlockPayload {
  content: { type: 'text', data: string }  // ← Wrong structure!
}
```

**Problem**: Frontend and backend can become inconsistent, causing runtime errors like "Missing 'content' in payload".

### Good Practice ✅

**Backend: Define typed payload in extension module**
```rust
// src/extensions/markdown/mod.rs
use serde::{Deserialize, Serialize};
use specta::Type;

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MarkdownWritePayload {
    pub content: String,  // Direct string, not nested object
}

// In handler (markdown_write.rs)
use super::MarkdownWritePayload;

#[capability(id = "markdown.write", target = "markdown")]
fn handle_markdown_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    let payload: MarkdownWritePayload = serde_json::from_value(cmd.payload.clone())
        .map_err(|e| format!("Invalid payload: {}", e))?;
    // Use payload.content
}
```

**Frontend: Import auto-generated type**
```typescript
import { type MarkdownWritePayload } from '@/bindings'

const payload: MarkdownWritePayload = { content: "markdown text" }
```

**Benefit**: Compiler enforces consistency. Frontend TypeScript errors appear immediately if backend changes.

### Workflow for Payload Types

1. **Define Rust struct** with `#[derive(Type)]` in your extension's `mod.rs`
2. **Use in capability handler** with `serde_json::from_value()`
3. **Run** `pnpm tauri dev` to regenerate bindings
4. **Import from** `@/bindings` in frontend
5. **TypeScript catches** any mismatches at compile time

### Common Payload Patterns

**Simple data:**
```rust
#[derive(Serialize, Deserialize, Type)]
pub struct SimplePayload {
    pub value: String,
}
```

**Optional fields:**
```rust
#[derive(Serialize, Deserialize, Type)]
pub struct WithOptionals {
    pub required: String,
    #[serde(default)]
    pub optional: Option<i64>,
}
```

**Default values:**
```rust
fn default_wildcard() -> String { "*".to_string() }

#[derive(Serialize, Deserialize, Type)]
pub struct GrantPayload {
    pub target_editor: String,
    pub capability: String,
    #[serde(default = "default_wildcard")]
    pub target_block: String,  // Defaults to "*" if not provided
}
```

### Where to Define Payload Types

- **Extension-specific payloads**: Define in `src/extensions/{extension_name}/mod.rs`
  - Example: `MarkdownWritePayload` in `src/extensions/markdown/mod.rs`
- **Core payloads**: Define in `src/models/payloads.rs`
  - Example: `GrantPayload`, `RevokePayload`, `LinkBlockPayload`

This keeps extensions modular and self-contained.

## Adding New Types

### 1. Define the Type in Rust
```rust
// src/models/my_type.rs
use serde::{Deserialize, Serialize};
use specta::Type;

#[derive(Debug, Clone, Serialize, Deserialize, Type)]  // ← Add Type
pub struct MyNewType {
    pub field1: String,
    pub field2: i64,  // Will be `number` in TypeScript
    pub field3: serde_json::Value,  // Will be `JsonValue` in TypeScript
}
```

### 2. Export from models module
```rust
// src/models/mod.rs
pub mod my_type;
pub use my_type::MyNewType;
```

### 3. Use in a Command
Once used in a command with `#[specta]`, it will be automatically exported to TypeScript.

### 4. Access in Frontend
```typescript
import { type MyNewType } from '@/bindings';

const data: MyNewType = {
  field1: 'value',
  field2: 123,
  field3: { any: 'json' }
};
```

## Type Mappings

| Rust Type | TypeScript Type | Notes |
|-----------|----------------|-------|
| `String` | `string` | |
| `i32`, `i64` | `number` | BigInt behavior configured |
| `bool` | `boolean` | |
| `Vec<T>` | `T[]` | |
| `HashMap<String, T>` | `Partial<{ [key in string]: T }>` | |
| `serde_json::Value` | `JsonValue` | Recursive union type |
| `chrono::DateTime<Utc>` | `string` | ISO 8601 format |
| `Option<T>` | `T \| null` | |
| `Result<T, E>` | `Result<T, E>` | Special wrapper type |

## Development Workflow

### Standard Workflow
1. Modify Rust backend code (models, commands)
2. Run `pnpm tauri dev`
3. Bindings automatically regenerate
4. Use updated types/commands in frontend
5. TypeScript compiler catches any mismatches

### Troubleshooting

**Problem:** Bindings not updating
- **Solution:** Kill and restart `pnpm tauri dev`
- Check console for export errors

**Problem:** TypeScript errors after backend changes
- **Solution:** This is expected! Update your frontend code to match new types
- The compiler is protecting you from runtime errors

**Problem:** `BigIntForbidden` error
- **Cause:** Using `u64` or `u128` in exported types
- **Solution:** Use `i64` (configured to export as `number`)
- Or use `String` for very large numbers

## Best Practices

### DO:
✅ Always use generated bindings via `@/bindings`
✅ Add `#[derive(Type)]` to all models used in commands
✅ Add `#[specta]` to all Tauri commands
✅ Use the `TauriClient` wrapper for common operations
✅ Handle `Result` types properly
✅ Let TypeScript catch type mismatches early

### DON'T:
❌ Manually edit `src/bindings.ts`
❌ Use raw `invoke()` for commands with bindings
❌ Define duplicate types manually
❌ Forget to add commands to Builder in `lib.rs`
❌ Use `u64`/`u128` in exported types
❌ Bypass Result type error handling

## Configuration

### Specta Configuration
Located in `src-tauri/src/lib.rs`:

```rust
#[cfg(debug_assertions)]
specta_builder
    .export(
        Typescript::default().bigint(BigIntExportBehavior::Number),
        "../src/bindings.ts",
    )
    .expect("Failed to export TypeScript bindings");
```

**Key Settings:**
- `BigIntExportBehavior::Number`: Exports `i64` as TypeScript `number`
- Export path: `../src/bindings.ts` (relative to `src-tauri/`)
- Only runs in debug mode (`#[cfg(debug_assertions)]`)

### Dependencies
In `src-tauri/Cargo.toml`:
```toml
specta = { version = "=2.0.0-rc.22", features = ["serde_json", "chrono"] }
specta-typescript = "0.0.9"
tauri-specta = { version = "=2.0.0-rc.21", features = ["derive", "typescript"] }
```

## Testing

### Unit Tests
Test backend logic independently:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_my_command() {
        // Test Rust logic
    }
}
```

### Integration Tests
Test with generated bindings:
```typescript
import { commands } from '@/bindings';
import { describe, it, expect } from 'vitest';

describe('Block Operations', () => {
  it('should create and retrieve block', async () => {
    const result = await commands.createFile('/tmp/test.elf');
    expect(result.status).toBe('ok');
  });
});
```

## Resources

- [Tauri Specta Documentation](https://github.com/oscartbeaumont/tauri-specta)
- [Specta Documentation](https://docs.rs/specta/)
- [Tauri v2 Documentation](https://v2.tauri.app/)

## Summary

The key principle: **Rust code is the single source of truth**. The frontend automatically adapts to backend changes through auto-generated bindings, eliminating an entire class of bugs related to API mismatches.

When you need to modify the API:
1. Change Rust code
2. Run dev server
3. Fix TypeScript errors
4. Done!
