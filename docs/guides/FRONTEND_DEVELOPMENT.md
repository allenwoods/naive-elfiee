# Frontend Development Guide

This guide explains how to work with the Elfiee frontend codebase, focusing on type-safe communication with the Tauri backend.

## Overview

Elfiee uses **Tauri Specta v2** to automatically generate TypeScript bindings from Rust code. This ensures:
- **Type safety**: TypeScript types are automatically synced with Rust types
- **No manual updates**: Changes to backend types/commands automatically reflect in frontend
- **Consistent naming**: Rust `snake_case` is automatically converted to TypeScript `camelCase`

## Architecture

```
Backend (Rust)                    Frontend (TypeScript)
├─ src/models/                    ├─ src/bindings.ts (auto-generated)
│  ├─ block.rs                    │  ├─ Block type
│  ├─ command.rs                  │  ├─ Command type
│  ├─ event.rs                    │  ├─ Event type
│  └─ ...                         │  └─ commands.*()
├─ src/commands/                  │
│  ├─ file.rs                     ├─ src/lib/tauri-client.ts (wrapper)
│  └─ block.rs                    │  └─ High-level API wrappers
└─ src/lib.rs                     │
   └─ Specta Builder config       └─ Your components
```

## Auto-Generated Bindings

### Location
`src/bindings.ts` - **DO NOT EDIT THIS FILE MANUALLY**

This file is auto-generated every time you run `pnpm tauri dev`. It contains:
1. All Tauri command functions
2. All data types (Block, Command, Event, etc.)
3. Type-safe wrappers with Result types

### When Bindings are Regenerated
- Automatically on `pnpm tauri dev` (debug mode only)
- On every Tauri app startup in development
- **NOT** in release builds (uses standard Tauri handlers)

### Example Generated Code

**Rust Backend:**
```rust
#[tauri::command]
#[specta]
pub async fn execute_command(
    file_id: String,
    cmd: Command,
    state: State<'_, AppState>,
) -> Result<Vec<Event>, String>
```

**Generated TypeScript:**
```typescript
async executeCommand(
  fileId: string,  // snake_case → camelCase
  cmd: Command
): Promise<Result<Event[], string>>
```

## Using the Bindings

### Import from Bindings
```typescript
import { commands, type Block, type Command, type Event } from '@/bindings';
```

### Calling Commands
All generated commands return a `Result` type for error handling:

```typescript
const result = await commands.executeCommand(fileId, cmd);

if (result.status === 'ok') {
  const events: Event[] = result.data;
  // Handle success
} else {
  const error: string = result.error;
  // Handle error
}
```

### Using the Tauri Client Wrapper
For convenience, use the high-level wrapper in `src/lib/tauri-client.ts`:

```typescript
import { TauriClient } from '@/lib/tauri-client';

// File operations
const fileId = await TauriClient.file.createFile();
await TauriClient.file.saveFile(fileId);

// Block operations
const blocks = await TauriClient.block.getAllBlocks(fileId);
const events = await TauriClient.block.createBlock(
  fileId,
  'block-1',
  null,
  { type: 'text', data: 'Hello' }
);
```

The wrapper automatically unwraps `Result` types and throws errors.

## Adding New Backend Commands

### 1. Define the Command in Rust
```rust
// src/commands/my_commands.rs
use specta::specta;
use tauri::State;

#[tauri::command]
#[specta]  // ← Required for binding generation
pub async fn my_new_command(
    param1: String,
    param2: i32,
) -> Result<MyReturnType, String> {
    // Implementation
}
```

### 2. Register the Command
```rust
// src/lib.rs
#[cfg(debug_assertions)]
let specta_builder = tauri_specta::Builder::<tauri::Wry>::new()
    .commands(tauri_specta::collect_commands![
        // ... existing commands
        commands::my_commands::my_new_command,  // ← Add here
    ]);
```

### 3. Run the App
```bash
pnpm tauri dev
```

The bindings will be automatically regenerated with your new command!

### 4. Use in Frontend
```typescript
import { commands } from '@/bindings';

const result = await commands.myNewCommand('hello', 42);
```

## Capability Payload Types

### Why Payload Types Matter

When creating capabilities that require input data, **always define Rust payload structs** instead of using raw JSON parsing. This ensures frontend-backend type consistency and prevents runtime errors.

### Bad Practice ❌
```rust
// Backend: Manual JSON parsing (BAD!)
let content = cmd.payload.get("content")
    .and_then(|v| v.as_str())
    .ok_or("Missing content")?;
```

```typescript
// Frontend: Manual interface definition (can drift!)
interface WriteBlockPayload {
  content: { type: 'text', data: string }  // ← Wrong structure!
}
```

**Problem**: Frontend and backend can become inconsistent, causing runtime errors like "Missing 'content' in payload".

### Good Practice ✅

**Backend: Define typed payload in extension module**
```rust
// src/extensions/markdown/mod.rs
use serde::{Deserialize, Serialize};
use specta::Type;

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MarkdownWritePayload {
    pub content: String,  // Direct string, not nested object
}

// In handler (markdown_write.rs)
use super::MarkdownWritePayload;

#[capability(id = "markdown.write", target = "markdown")]
fn handle_markdown_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    let payload: MarkdownWritePayload = serde_json::from_value(cmd.payload.clone())
        .map_err(|e| format!("Invalid payload: {}", e))?;
    // Use payload.content
}
```

**Frontend: Import auto-generated type**
```typescript
import { type MarkdownWritePayload } from '@/bindings'

const payload: MarkdownWritePayload = { content: "markdown text" }
```

**Benefit**: Compiler enforces consistency. Frontend TypeScript errors appear immediately if backend changes.

### Workflow for Payload Types

1. **Define Rust struct** with `#[derive(Type)]` in your extension's `mod.rs`
2. **Use in capability handler** with `serde_json::from_value()`
3. **Run** `pnpm tauri dev` to regenerate bindings
4. **Import from** `@/bindings` in frontend
5. **TypeScript catches** any mismatches at compile time

### Common Payload Patterns

**Simple data:**
```rust
#[derive(Serialize, Deserialize, Type)]
pub struct SimplePayload {
    pub value: String,
}
```

**Optional fields:**
```rust
#[derive(Serialize, Deserialize, Type)]
pub struct WithOptionals {
    pub required: String,
    #[serde(default)]
    pub optional: Option<i64>,
}
```

**Default values:**
```rust
fn default_wildcard() -> String { "*".to_string() }

#[derive(Serialize, Deserialize, Type)]
pub struct GrantPayload {
    pub target_editor: String,
    pub capability: String,
    #[serde(default = "default_wildcard")]
    pub target_block: String,  // Defaults to "*" if not provided
}
```

### Where to Define Payload Types

- **Extension-specific payloads**: Define in `src/extensions/{extension_name}/mod.rs`
  - Example: `MarkdownWritePayload` in `src/extensions/markdown/mod.rs`
- **Core payloads**: Define in `src/models/payloads.rs`
  - Example: `GrantPayload`, `RevokePayload`, `LinkBlockPayload`, `CreateBlockPayload`, `UnlinkBlockPayload`, `EditorCreatePayload`

This keeps extensions modular and self-contained.

### Current Payload Types in System

**Core Payloads** (in `src/models/payloads.rs`):

1. **CreateBlockPayload** - For `core.create` capability
   ```rust
   pub struct CreateBlockPayload {
       pub name: String,
       pub block_type: String,
   }
   ```

2. **LinkBlockPayload** - For `core.link` capability
   ```rust
   pub struct LinkBlockPayload {
       pub relation: String,      // e.g., "references", "depends_on", "contains"
       pub target_id: String,
   }
   ```

3. **UnlinkBlockPayload** - For `core.unlink` capability
   ```rust
   pub struct UnlinkBlockPayload {
       pub relation: String,
       pub target_id: String,
   }
   ```

4. **GrantPayload** - For `core.grant` capability
   ```rust
   pub struct GrantPayload {
       pub target_editor: String,
       pub capability: String,
       #[serde(default = "default_wildcard")]
       pub target_block: String,  // Defaults to "*"
   }
   ```

5. **RevokePayload** - For `core.revoke` capability
   ```rust
   pub struct RevokePayload {
       pub target_editor: String,
       pub capability: String,
       #[serde(default = "default_wildcard")]
       pub target_block: String,
   }
   ```

6. **EditorCreatePayload** - For `editor.create` capability
   ```rust
   pub struct EditorCreatePayload {
       pub name: String,
   }
   ```

**Extension Payloads**:

1. **MarkdownWritePayload** (in `src/extensions/markdown/mod.rs`) - For `markdown.write` capability
   ```rust
   pub struct MarkdownWritePayload {
       pub content: String,
   }
   ```

**Note**: `core.delete` capability requires no payload (empty JSON object).

## Adding New Types

### 1. Define the Type in Rust
```rust
// src/models/my_type.rs
use serde::{Deserialize, Serialize};
use specta::Type;

#[derive(Debug, Clone, Serialize, Deserialize, Type)]  // ← Add Type
pub struct MyNewType {
    pub field1: String,
    pub field2: i64,  // Will be `number` in TypeScript
    pub field3: serde_json::Value,  // Will be `JsonValue` in TypeScript
}
```

### 2. Export from models module
```rust
// src/models/mod.rs
pub mod my_type;
pub use my_type::MyNewType;
```

### 3. Use in a Command
Once used in a command with `#[specta]`, it will be automatically exported to TypeScript.

### 4. Access in Frontend
```typescript
import { type MyNewType } from '@/bindings';

const data: MyNewType = {
  field1: 'value',
  field2: 123,
  field3: { any: 'json' }
};
```

## Type Mappings

| Rust Type | TypeScript Type | Notes |
|-----------|----------------|-------|
| `String` | `string` | |
| `i32`, `i64` | `number` | BigInt behavior configured |
| `bool` | `boolean` | |
| `Vec<T>` | `T[]` | |
| `HashMap<String, T>` | `Partial<{ [key in string]: T }>` | |
| `serde_json::Value` | `JsonValue` | Recursive union type |
| `chrono::DateTime<Utc>` | `string` | ISO 8601 format |
| `Option<T>` | `T \| null` | |
| `Result<T, E>` | `Result<T, E>` | Special wrapper type |

## Development Workflow

### Standard Workflow
1. Modify Rust backend code (models, commands)
2. Run `pnpm tauri dev`
3. Bindings automatically regenerate
4. Use updated types/commands in frontend
5. TypeScript compiler catches any mismatches

### Troubleshooting

**Problem:** Bindings not updating
- **Solution:** Kill and restart `pnpm tauri dev`
- Check console for export errors

**Problem:** TypeScript errors after backend changes
- **Solution:** This is expected! Update your frontend code to match new types
- The compiler is protecting you from runtime errors

**Problem:** `BigIntForbidden` error
- **Cause:** Using `u64` or `u128` in exported types
- **Solution:** Use `i64` (configured to export as `number`)
- Or use `String` for very large numbers

## Best Practices

### DO:
✅ Always use generated bindings via `@/bindings`
✅ Add `#[derive(Type)]` to all models used in commands
✅ Add `#[specta]` to all Tauri commands
✅ Use the `TauriClient` wrapper for common operations
✅ Handle `Result` types properly
✅ Let TypeScript catch type mismatches early

### DON'T:
❌ Manually edit `src/bindings.ts`
❌ Use raw `invoke()` for commands with bindings
❌ Define duplicate types manually
❌ Forget to add commands to Builder in `lib.rs`
❌ Use `u64`/`u128` in exported types
❌ Bypass Result type error handling

## Configuration

### Specta Configuration
Located in `src-tauri/src/lib.rs`:

```rust
#[cfg(debug_assertions)]
specta_builder
    .export(
        Typescript::default().bigint(BigIntExportBehavior::Number),
        "../src/bindings.ts",
    )
    .expect("Failed to export TypeScript bindings");
```

**Key Settings:**
- `BigIntExportBehavior::Number`: Exports `i64` as TypeScript `number`
- Export path: `../src/bindings.ts` (relative to `src-tauri/`)
- Only runs in debug mode (`#[cfg(debug_assertions)]`)

### Dependencies
In `src-tauri/Cargo.toml`:
```toml
specta = { version = "=2.0.0-rc.22", features = ["serde_json", "chrono"] }
specta-typescript = "0.0.9"
tauri-specta = { version = "=2.0.0-rc.21", features = ["derive", "typescript"] }
```

## Testing

### Test Architecture

Elfiee 使用 Vitest 进行单元测试和集成测试。测试系统通过 mock Tauri 的 `invoke` 函数来模拟后端响应，无需实际启动 Tauri 应用。

### Mock System Overview

测试系统位于 `src/test/` 目录：

- **setup.ts**: 配置 Vitest 环境，mock `@tauri-apps/api/core` 的 `invoke` 函数
- **mock-tauri-invoke.ts**: 提供类型安全的 mock 工具函数

关键特性：
- 直接 mock 底层 `invoke` 函数，无需创建独立的 MockTauriClient
- 基于 `bindings.ts` 的类型，确保 mock 数据与后端一致
- 自动处理 snake_case/camelCase 转换

### Writing Tests for App Store

测试 Zustand store 时，使用 `setupCommandMocks` 来模拟后端响应：

```typescript
import { describe, expect, test, beforeEach, vi } from 'vitest'
import { useAppStore } from './app-store'
import { setupCommandMocks, setupCommandError } from '@/test/mock-tauri-invoke'
import { createMockBlock, TEST_FILE_ID } from '@/test/setup'

describe('AppStore - Block Operations', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  test('should load blocks successfully', async () => {
    const fileId = TEST_FILE_ID
    const mockBlocks = [createMockBlock({ block_id: 'block-1' })]

    // Setup initial state
    const store = useAppStore.getState()
    store.files.set(fileId, {
      fileId,
      blocks: [],
      selectedBlockId: null,
      editors: [],
      activeEditorId: null,
      grants: [],
      events: []
    })

    // Mock backend commands
    setupCommandMocks({
      getAllBlocks: mockBlocks
    })

    await store.loadBlocks(fileId)

    const updatedStore = useAppStore.getState()
    expect(updatedStore.files.get(fileId)?.blocks).toEqual(mockBlocks)
  })

  test('should handle backend errors', async () => {
    const fileId = TEST_FILE_ID
    const store = useAppStore.getState()
    
    // Mock backend error
    setupCommandError('getAllBlocks', 'Failed to load blocks')

    await store.loadBlocks(fileId)

    const updatedStore = useAppStore.getState()
    expect(updatedStore.notifications[0].type).toBe('error')
  })
})
```

### Writing Tests for TauriClient

测试 TauriClient wrapper 时，使用 `setupCommandMock` 或 spy 方法：

```typescript
import { describe, expect, test, vi } from 'vitest'
import { TauriClient } from './tauri-client'
import { setupCommandMock, setupCommandError } from '@/test/mock-tauri-invoke'
import { createMockBlock, TEST_FILE_ID, TEST_BLOCK_ID, TEST_EDITOR_ID } from '@/test/setup'

describe('TauriClient - Block Operations', () => {
  test('getAllBlocks should return blocks array', async () => {
    const mockBlocks = [createMockBlock(), createMockBlock({ block_id: 'block-2' })]
    setupCommandMock('getAllBlocks', mockBlocks)

    const result = await TauriClient.block.getAllBlocks(TEST_FILE_ID)

    expect(result).toEqual(mockBlocks)
  })

  test('createBlock should execute command with correct payload', async () => {
    const mockEvents = [createMockEvent()]
    const executeCommandSpy = vi.spyOn(TauriClient.block, 'executeCommand')
    executeCommandSpy.mockResolvedValue(mockEvents)

    await TauriClient.block.createBlock(
      TEST_FILE_ID,
      TEST_BLOCK_ID,
      'Test Block',
      'markdown',
      TEST_EDITOR_ID
    )

    expect(executeCommandSpy).toHaveBeenCalledWith(
      TEST_FILE_ID,
      expect.objectContaining({
        editor_id: TEST_EDITOR_ID,
        cap_id: 'core.create',
        block_id: TEST_BLOCK_ID,
        payload: expect.objectContaining({
          name: 'Test Block',
          block_type: 'markdown',
        }),
      })
    )
  })
})
```

### Writing Tests for React Components

测试 React 组件时，mock useAppStore hook：

```typescript
import { describe, expect, test, vi, beforeEach } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { BlockList } from './BlockList'
import { useAppStore } from '@/lib/app-store'
import { createMockBlock } from '@/test/setup'

// Mock the app store
vi.mock('@/lib/app-store', () => ({
  useAppStore: vi.fn(),
}))

describe('BlockList Component', () => {
  const mockStore = {
    activeFileId: 'test-file-1',
    getBlocks: vi.fn(),
    createBlock: vi.fn(),
    deleteBlock: vi.fn(),
    selectBlock: vi.fn(),
    isLoading: false,
    addNotification: vi.fn(),
  }

  beforeEach(() => {
    vi.clearAllMocks()
    vi.mocked(useAppStore).mockReturnValue(mockStore)
  })

  test('renders blocks correctly', () => {
    const mockBlocks = [createMockBlock({ name: 'Test Block' })]
    vi.mocked(mockStore.getBlocks).mockReturnValue(mockBlocks)
    
    render(<BlockList />)
    
    expect(screen.getByText('Test Block')).toBeInTheDocument()
  })

  test('creates block when button clicked', async () => {
    const user = userEvent.setup()
    vi.mocked(mockStore.createBlock).mockResolvedValue(undefined)
    
    render(<BlockList />)
    
    const createButton = screen.getByRole('button', { name: /new block/i })
    await user.click(createButton)
    
    expect(mockStore.createBlock).toHaveBeenCalled()
  })
})
```

### Mock Helper Functions

**setupCommandMocks** - Mock multiple commands at once:
```typescript
setupCommandMocks({
  createFile: 'file-123',
  getAllBlocks: [block1, block2],
  listEditors: [editor1],
})
```

**setupCommandMock** - Mock single command:
```typescript
setupCommandMock('createFile', 'file-123')
```

**setupCommandError** - Mock command error:
```typescript
setupCommandError('createFile', 'Failed to create file')
```

**Mock Data Helpers** (from `src/test/setup.ts`):
```typescript
import { 
  createMockBlock, 
  createMockEditor, 
  createMockEvent, 
  createMockGrant,
  TEST_FILE_ID,
  TEST_BLOCK_ID,
  TEST_EDITOR_ID 
} from '@/test/setup'

const block = createMockBlock({ name: 'Custom Name' })
const editor = createMockEditor({ editor_id: 'custom-id' })
```

### Running Tests

```bash
# Run all tests
pnpm test

# Run tests in watch mode
pnpm test:watch

# Run tests with coverage
pnpm test:coverage

# Run specific test file
pnpm test src/lib/app-store.test.ts
```

### Test File Organization

```
src/
├── lib/
│   ├── app-store.ts
│   ├── app-store.basic.test.ts       # State & getters tests
│   ├── app-store.block-ops.test.ts   # Block operations tests
│   ├── app-store.editor-ops.test.ts  # Editor operations tests
│   ├── app-store.file-ops.test.ts    # File operations tests
│   ├── tauri-client.ts
│   └── tauri-client.test.ts          # TauriClient wrapper tests
├── components/
│   ├── BlockList.tsx
│   ├── BlockList.test.tsx            # Component tests
│   └── ...
└── test/
    ├── setup.ts                       # Vitest setup & global mocks
    └── mock-tauri-invoke.ts           # Type-safe mock utilities
```

### Best Practices

DO:
- Use `setupCommandMocks` for mocking backend responses
- Use mock helper functions from `@/test/setup`
- Clear mocks in `beforeEach` with `vi.clearAllMocks()`
- Test both success and error cases
- Use `createMock*` helpers for consistent test data
- Mock `useAppStore` when testing components

DON'T:
- Create manual MockTauriClient classes
- Define mock data inline (use helpers)
- Forget to mock dialog functions (`@tauri-apps/plugin-dialog`)
- Skip error case testing
- Test implementation details (test behavior, not internals)
```

## Resources

- [Tauri Specta Documentation](https://github.com/oscartbeaumont/tauri-specta)
- [Specta Documentation](https://docs.rs/specta/)
- [Tauri v2 Documentation](https://v2.tauri.app/)

## Summary

The key principle: **Rust code is the single source of truth**. The frontend automatically adapts to backend changes through auto-generated bindings, eliminating an entire class of bugs related to API mismatches.

When you need to modify the API:
1. Change Rust code
2. Run dev server
3. Fix TypeScript errors
4. Done!
