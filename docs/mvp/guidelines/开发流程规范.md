# Elfiee å¼€å‘æµç¨‹è§„èŒƒ

> æœ¬æ–‡æ¡£é¢å‘æ‰€æœ‰ Elfiee é¡¹ç›®å¼€å‘è€…ï¼ˆåŒ…æ‹¬ AI è¾…åŠ©å¼€å‘ï¼‰ï¼Œè¯´æ˜å®Œæ•´çš„å¼€å‘æµç¨‹ã€ç¯å¢ƒæ­å»ºã€åä½œè§„èŒƒå’Œå¸¸è§ä»»åŠ¡æŒ‡å—ã€‚

## ğŸ¯ å¿«é€Ÿå¼€å§‹

### 1ï¸âƒ£ ç¯å¢ƒæ­å»ºï¼ˆæ–°æ‰‹å¿…çœ‹ï¼‰

```bash
# å®‰è£…ä¾èµ–
pnpm install

# å¯åŠ¨å¼€å‘æœåŠ¡å™¨ï¼ˆå‰åç«¯çƒ­é‡è½½ + è‡ªåŠ¨ç”Ÿæˆ bindings.tsï¼‰
pnpm tauri dev
```

### 2ï¸âƒ£ å¼€å‘å·¥ä½œæµï¼ˆæ ¸å¿ƒæµç¨‹ï¼‰

```
åç«¯å®šä¹‰æ¥å£ (#[tauri::command] + #[specta])
    â†“
åœ¨ lib.rs æ³¨å†Œå‘½ä»¤å’Œç±»å‹
    â†“
é‡å¯ pnpm tauri dev â†’ è‡ªåŠ¨ç”Ÿæˆ bindings.ts
    â†“
å‰ç«¯é€šè¿‡ TauriClient è°ƒç”¨
```

### 3ï¸âƒ£ AI è¾…åŠ©å¼€å‘æ£€æŸ¥æ¸…å•

**åç«¯å¼€å‘å¿…æŸ¥ï¼š**
- [ ] Payload ç±»å‹æ·»åŠ äº† `#[derive(Type)]`
- [ ] åœ¨ lib.rs çš„ **debug å’Œ release** éƒ½æ³¨å†Œäº†
- [ ] èƒ½åŠ›å¤„ç†å™¨æ³¨æ„ Read/Write çš„ Entity åŒºåˆ«
- [ ] ä½¿ç”¨ `create_event()` è€Œä¸æ˜¯ç›´æ¥ä¿®æ”¹çŠ¶æ€

**å‰ç«¯å¼€å‘å¿…æŸ¥ï¼š**
- [ ] ç»„ä»¶åªè°ƒç”¨ `Zustand Actions`ï¼Œä¸ç›´æ¥ä½¿ç”¨ `TauriClient`
- [ ] `TauriClient` åªåœ¨ `app-store.ts` çš„ Actions å†…éƒ¨ä½¿ç”¨
- [ ] æ²¡æœ‰æ‰‹åŠ¨ç¼–è¾‘ `bindings.ts`
- [ ] Payload ç±»å‹ä» `bindings.ts` å¯¼å…¥
- [ ] åœ¨ç»„ä»¶ä¸­ä½¿ç”¨ try-catch å¤„ç† Action é”™è¯¯
- [ ] ä¸ç›´æ¥ä¿®æ”¹çŠ¶æ€å¯¹è±¡ï¼Œå¿…é¡»é€šè¿‡ Actions

---

## ç›®å½•

1. [ç¯å¢ƒæ­å»º](#ç¯å¢ƒæ­å»º)
2. [å¼€å‘å·¥ä½œæµ](#å¼€å‘å·¥ä½œæµ)
3. [å‰åç«¯åä½œæµç¨‹](#å‰åç«¯åä½œæµç¨‹)
4. [æ·»åŠ æ–°åŠŸèƒ½](#æ·»åŠ æ–°åŠŸèƒ½)ï¼ˆå®Œæ•´ç¤ºä¾‹ï¼‰
5. [æµ‹è¯•ä¸è°ƒè¯•](#æµ‹è¯•ä¸è°ƒè¯•)
6. [Git å·¥ä½œæµ](#git-å·¥ä½œæµ)
7. [å¸¸è§ä»»åŠ¡å¿«é€ŸæŒ‡å—](#å¸¸è§ä»»åŠ¡å¿«é€ŸæŒ‡å—)ï¼ˆâ­ å¿«é€Ÿå‚è€ƒï¼‰
8. [AI è¾…åŠ©å¼€å‘æŒ‡å—](#ai-è¾…åŠ©å¼€å‘æŒ‡å—)ï¼ˆâ­ AI å¿…è¯»ï¼‰
9. [æµç¨‹è‡ªæŸ¥æ¸…å•](#ğŸ-æµç¨‹è‡ªæŸ¥æ¸…å•-checklist)

---

## ç¯å¢ƒæ­å»º

### 1. ç³»ç»Ÿè¦æ±‚

**å¿…éœ€å·¥å…·ï¼š**
- **Node.js** >= 18.0.0
- **pnpm** >= 8.0.0
- **Rust** >= 1.70.0 (é€šè¿‡ rustup å®‰è£…)
- **Git**

**æ“ä½œç³»ç»Ÿæ”¯æŒï¼š**
- Windows 10/11
- macOS 10.15+
- Linux (Ubuntu 20.04+, Fedora, etc.)

### 2. å®‰è£…æ­¥éª¤

**A. å®‰è£… Rust**

```bash
# ä½¿ç”¨ rustup å®‰è£… Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# éªŒè¯å®‰è£…
rustc --version
cargo --version
```

**B. å®‰è£… Node.js å’Œ pnpm**

```bash
# ä½¿ç”¨ nvm (æ¨è)
nvm install 18
nvm use 18

# å®‰è£… pnpm
npm install -g pnpm

# éªŒè¯å®‰è£…
node --version
pnpm --version
```

**C. å…‹éš†é¡¹ç›®**

```bash
git clone https://github.com/your-org/elfiee.git
cd elfiee
```

**D. å®‰è£…ä¾èµ–**

```bash
# å®‰è£…å‰ç«¯ä¾èµ–
pnpm install

# éªŒè¯ Rust ä¾èµ–ï¼ˆä¼šè‡ªåŠ¨ä¸‹è½½ï¼‰
cd src-tauri
cargo check
cd ..
```

### 3. è¿è¡Œå¼€å‘æœåŠ¡å™¨

```bash
# å¯åŠ¨å¼€å‘æ¨¡å¼ï¼ˆå‰ç«¯ + åç«¯çƒ­é‡è½½ï¼‰
pnpm tauri dev
```

**é¦–æ¬¡è¿è¡Œæ—¶ï¼š**
- Rust ä¾èµ–ä¼šè‡ªåŠ¨ç¼–è¯‘ï¼ˆå¯èƒ½éœ€è¦å‡ åˆ†é’Ÿï¼‰
- Tauri ä¼šåˆ›å»ºå¼€å‘çª—å£
- å‰ç«¯ä¼šåœ¨ `http://localhost:5173` è¿è¡Œ
- `src/bindings.ts` ä¼šè‡ªåŠ¨ç”Ÿæˆ

### 4. IDE é…ç½®

**æ¨è IDEï¼š**
- **å‰ç«¯**: VS Code + Volar + TypeScript
- **åç«¯**: VS Code + rust-analyzer / RustRover

**VS Code æ¨èæ‰©å±•ï¼š**
```json
{
  "recommendations": [
    "rust-lang.rust-analyzer",
    "tauri-apps.tauri-vscode",
    "Vue.volar",
    "bradlc.vscode-tailwindcss",
    "esbenp.prettier-vscode"
  ]
}
```

---

## å¼€å‘å·¥ä½œæµ

### 1. å¼€å‘æ¨¡å¼

**å¯åŠ¨å¼€å‘æœåŠ¡å™¨ï¼š**

```bash
pnpm tauri dev
```

**å‘ç”Ÿäº†ä»€ä¹ˆï¼š**
1. Vite å¯åŠ¨å‰ç«¯å¼€å‘æœåŠ¡å™¨ (çƒ­é‡è½½)
2. Cargo ç¼–è¯‘ Rust åç«¯ (debug æ¨¡å¼)
3. Tauri åˆ›å»ºåº”ç”¨çª—å£
4. tauri-specta ç”Ÿæˆ `src/bindings.ts`
5. å‰ç«¯è¿æ¥åˆ°åç«¯ Tauri IPC

**çƒ­é‡è½½ï¼š**
- **å‰ç«¯ä»£ç å˜æ›´** â†’ æµè§ˆå™¨è‡ªåŠ¨åˆ·æ–° (Vite HMR)
- **åç«¯ Rust ä»£ç å˜æ›´** â†’ è‡ªåŠ¨é‡æ–°ç¼–è¯‘ + åº”ç”¨é‡å¯

### 2. æ„å»ºç”Ÿäº§ç‰ˆæœ¬

```bash
# æ„å»ºå®Œæ•´åº”ç”¨
pnpm tauri build

# è¾“å‡ºä½ç½®ï¼š
# - Windows: src-tauri/target/release/bundle/msi/
# - macOS: src-tauri/target/release/bundle/dmg/
# - Linux: src-tauri/target/release/bundle/deb/
```

### 3. ä»…æ„å»ºå‰ç«¯

```bash
# æ„å»ºå‰ç«¯é™æ€æ–‡ä»¶
pnpm build

# è¾“å‡ºä½ç½®ï¼šdist/
```

### 4. è¿è¡Œæµ‹è¯•

**å‰ç«¯æµ‹è¯•ï¼š**

```bash
# è¿è¡Œæ‰€æœ‰å‰ç«¯æµ‹è¯•
pnpm test

# è¿è¡Œæµ‹è¯•å¹¶ç›‘å¬å˜æ›´
pnpm test:watch

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
pnpm test:coverage
```

**åç«¯æµ‹è¯•ï¼š**

```bash
cd src-tauri

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
cargo test

# è¿è¡Œç‰¹å®šæµ‹è¯•
cargo test test_name

# æ˜¾ç¤ºè¾“å‡º
cargo test -- --nocapture
```

### 5. ä»£ç æ ¼å¼åŒ–å’Œæ£€æŸ¥

**å‰ç«¯ï¼š**

```bash
# æ ¼å¼åŒ–ä»£ç 
pnpm format

# æ£€æŸ¥ TypeScript ç±»å‹
pnpm typecheck

# è¿è¡Œ ESLint
pnpm lint
```

**åç«¯ï¼š**

```bash
cd src-tauri

# æ ¼å¼åŒ–ä»£ç 
cargo fmt

# è¿è¡Œ Clippy (Rust ä»£ç æ£€æŸ¥)
cargo clippy

# è‡ªåŠ¨ä¿®å¤
cargo clippy --fix
```

---

## å‰åç«¯åä½œæµç¨‹

### 1. æ¶æ„åˆ†ç¦»åŸåˆ™

```
å‰ç«¯ (React/TypeScript)
    â†“ IPC é€šä¿¡
åç«¯ (Rust/Tauri)
```

**ã€æ ¸å¿ƒè§„åˆ™ã€‘å‰ç«¯å’Œåç«¯ä¸¥æ ¼åˆ†ç¦»ï¼š**
- å‰ç«¯åªèƒ½é€šè¿‡ `src/bindings.ts` è°ƒç”¨åç«¯
- åç«¯é€šè¿‡ Tauri Commands æš´éœ²æ¥å£
- ä½¿ç”¨ tauri-specta è‡ªåŠ¨ç”Ÿæˆç±»å‹ç»‘å®š

### 2. æ·»åŠ æ–°æ¥å£çš„åä½œæµç¨‹

**åœºæ™¯ï¼šå‰ç«¯éœ€è¦ä¸€ä¸ªæ–°åŠŸèƒ½ï¼Œä½†åç«¯æ²¡æœ‰æä¾›æ¥å£**

#### æ­¥éª¤ 1ï¼šå‰ç«¯å¼€å‘è€…æ£€æŸ¥ç°æœ‰æ¥å£

```typescript
import { commands } from '@/bindings';

// æŸ¥çœ‹æ‰€æœ‰å¯ç”¨å‘½ä»¤
console.log(Object.keys(commands));
```

**å¦‚æœæ¥å£ä¸å­˜åœ¨ â†’ è¯·æ±‚åç«¯æ·»åŠ **

#### æ­¥éª¤ 2ï¼šåç«¯å¼€å‘è€…æ·»åŠ  Tauri Command

**A. å®šä¹‰å‘½ä»¤** (`src-tauri/src/commands/my_module.rs`)

```rust
#[tauri::command]
#[specta]
pub async fn my_new_command(
    param1: String,
    param2: i32,
    state: State<'_, AppState>,
) -> Result<MyResult, String> {
    // å®ç°é€»è¾‘
    Ok(MyResult { data: "result".to_string() })
}
```

**B. å®šä¹‰è¿”å›ç±»å‹** (å¦‚æœéœ€è¦)

```rust
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MyResult {
    pub data: String,
}
```

**C. åœ¨ lib.rs ä¸­æ³¨å†Œ**

```rust
// Debug æ¨¡å¼
#[cfg(debug_assertions)]
let specta_builder = tauri_specta::Builder::<tauri::Wry>::new()
    .commands(tauri_specta::collect_commands![
        // ... å·²æœ‰å‘½ä»¤ ...
        commands::my_module::my_new_command,
    ])
    .typ::<commands::my_module::MyResult>()
    // ...
```

```rust
// Release æ¨¡å¼ï¼ˆå¿…é¡»ä¸ debug ä¸€è‡´ï¼‰
#[cfg(not(debug_assertions))]
let builder = builder.invoke_handler(tauri::generate_handler![
    // ... å·²æœ‰å‘½ä»¤ ...
    commands::my_module::my_new_command,
]);
```

#### æ­¥éª¤ 3ï¼šé‡æ–°ç”Ÿæˆç»‘å®š

```bash
# é‡å¯å¼€å‘æœåŠ¡å™¨
pnpm tauri dev
```

**è‡ªåŠ¨å‘ç”Ÿï¼š**
- `src/bindings.ts` æ›´æ–°
- æ–°å‘½ä»¤ `myNewCommand` å¯ç”¨
- æ–°ç±»å‹ `MyResult` å¯ç”¨

#### æ­¥éª¤ 4ï¼šå‰ç«¯ä½¿ç”¨æ–°æ¥å£

```typescript
import { commands, type MyResult } from '@/bindings';

const result = await commands.myNewCommand('param1', 42);
if (result.status === 'ok') {
  const data: MyResult = result.data;
  console.log(data);
}
```

### 3. æ·»åŠ æ–°èƒ½åŠ›çš„åä½œæµç¨‹

**åœºæ™¯ï¼šéœ€è¦ä¸ºç‰¹å®šå—ç±»å‹æ·»åŠ æ–°æ“ä½œ**

#### æ­¥éª¤ 1ï¼šåç«¯å®šä¹‰ Payload ç±»å‹

```rust
// src/extensions/my_extension/mod.rs
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MyCapabilityPayload {
    pub field1: String,
    pub field2: i32,
}
```

#### æ­¥éª¤ 2ï¼šåç«¯å®ç°èƒ½åŠ›å¤„ç†å™¨

```rust
// src/extensions/my_extension/my_capability.rs
#[capability(id = "my_extension.do_something", target = "my_block_type")]
fn handle_my_capability(cmd: &Command, block: &Block) -> CapResult<Vec<Event>> {
    let payload: MyCapabilityPayload = serde_json::from_value(cmd.payload.clone())?;

    // å®ç°é€»è¾‘
    let event = create_event(
        block.block_id.clone(),
        format!("{}/{}", cmd.editor_id, cmd.cap_id),
        json!({ "result": payload.field1 }),
        &cmd.timestamp,
    )?;

    Ok(vec![event])
}
```

#### æ­¥éª¤ 3ï¼šåç«¯æ³¨å†Œèƒ½åŠ›å’Œç±»å‹

```rust
// src/capabilities/registry.rs
impl CapabilityRegistry {
    pub fn register_extensions(&mut self) {
        // ...
        self.register_capability(handle_my_capability());
    }
}

// src-tauri/src/lib.rs
let specta_builder = /* ... */
    .typ::<extensions::my_extension::MyCapabilityPayload>()
    // ...
```

#### æ­¥éª¤ 4ï¼šå‰ç«¯åœ¨ Zustand Store ä¸­å®šä¹‰ Action

**åœ¨ `src/lib/app-store.ts` ä¸­æ·»åŠ  Actionï¼š**

```typescript
import { TauriClient } from '@/lib/tauri-client';
import type { MyCapabilityPayload } from '@/bindings';

export const useAppStore = create<AppStore>((set, get) => ({
  // ... å…¶ä»– state å’Œ actions ...

  // æ·»åŠ æ–°çš„ Action
  executeMyCapability: async (fileId: string, blockId: string, field1: string, field2: number) => {
    // æ„é€  Payload
    const payload: MyCapabilityPayload = {
      field1,
      field2,
    };

    // è°ƒç”¨ TauriClientï¼ˆåªåœ¨ Action å†…éƒ¨ä½¿ç”¨ï¼‰
    const events = await TauriClient.block.executeCommand(fileId, {
      cmd_id: crypto.randomUUID(),
      editor_id: get().activeEditorId || '',
      cap_id: 'my_extension.do_something',
      block_id: blockId,
      payload: payload as any,
      timestamp: new Date().toISOString(),
    });

    // é‡æ–°åŠ è½½å—ä»¥è·å–æœ€æ–°çŠ¶æ€
    const updatedBlock = await TauriClient.block.getBlock(fileId, blockId);
    set((state) => {
      const newBlocks = new Map(state.blocks);
      newBlocks.set(blockId, updatedBlock);
      return { blocks: newBlocks };
    });

    return events;
  },
}));
```

**åœ¨ç»„ä»¶ä¸­è°ƒç”¨ Actionï¼š**

```typescript
import { useAppStore } from '@/lib/app-store';

function MyComponent({ fileId, blockId }: Props) {
  const executeMyCapability = useAppStore((state) => state.executeMyCapability);

  async function handleExecute() {
    try {
      await executeMyCapability(fileId, blockId, 'value', 42);
      toast({ title: 'æ‰§è¡ŒæˆåŠŸ' });
    } catch (error) {
      toast({ title: 'æ‰§è¡Œå¤±è´¥', description: error.message });
    }
  }

  return <Button onClick={handleExecute}>æ‰§è¡Œèƒ½åŠ›</Button>;
}
```

---

## æ·»åŠ æ–°åŠŸèƒ½

### å®Œæ•´ç¤ºä¾‹ï¼šæ·»åŠ  "å›¾ç‰‡å—" åŠŸèƒ½

**éœ€æ±‚ï¼šæ”¯æŒå›¾ç‰‡å—ï¼ˆimage blockï¼‰ï¼Œå¯ä»¥ä¸Šä¼ å’Œæ˜¾ç¤ºå›¾ç‰‡**

#### 1. åç«¯ï¼šå®šä¹‰æ‰©å±•

**A. åˆ›å»ºæ‰©å±•ç›®å½•**

```bash
mkdir -p src-tauri/src/extensions/image
touch src-tauri/src/extensions/image/mod.rs
touch src-tauri/src/extensions/image/image_write.rs
```

**B. å®šä¹‰ Payload ç±»å‹** (`mod.rs`)

```rust
use serde::{Deserialize, Serialize};
use specta::Type;

/// Payload for image.write capability
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct ImageWritePayload {
    /// Base64 encoded image data
    pub image_data: String,
    /// Image format (png, jpg, etc.)
    pub format: String,
    /// Alt text
    pub alt_text: Option<String>,
}

pub mod image_write;
pub use image_write::handle_image_write;
```

**C. å®ç°èƒ½åŠ›å¤„ç†å™¨** (`image_write.rs`)

```rust
use capability_macros::capability;
use crate::capabilities::core::{CapResult, create_event};
use crate::models::{Block, Command, Event};
use super::ImageWritePayload;
use serde_json::json;

#[capability(id = "image.write", target = "image")]
fn handle_image_write(cmd: &Command, block: &Block) -> CapResult<Vec<Event>> {
    let payload: ImageWritePayload = serde_json::from_value(cmd.payload.clone())
        .map_err(|e| format!("Invalid payload: {}", e))?;

    // éªŒè¯
    if payload.image_data.is_empty() {
        return Err("Image data cannot be empty".into());
    }

    // æ„å»ºæ–°çŠ¶æ€
    let mut new_contents = serde_json::Map::new();
    new_contents.insert("image_data".to_string(), json!(payload.image_data));
    new_contents.insert("format".to_string(), json!(payload.format));
    if let Some(alt) = payload.alt_text {
        new_contents.insert("alt_text".to_string(), json!(alt));
    }

    // åˆ›å»ºäº‹ä»¶
    let event = create_event(
        block.block_id.clone(),
        format!("{}/{}", cmd.editor_id, cmd.cap_id),
        json!(new_contents),
        &cmd.timestamp,
    )?;

    Ok(vec![event])
}
```

**D. æ³¨å†Œæ‰©å±•**

```rust
// src/extensions/mod.rs
pub mod image;

// src/capabilities/registry.rs
use crate::extensions::image::handle_image_write;

impl CapabilityRegistry {
    pub fn register_extensions(&mut self) {
        // ...
        self.register_capability(handle_image_write());
    }
}

// src-tauri/src/lib.rs
let specta_builder = /* ... */
    .typ::<extensions::image::ImageWritePayload>()
    // ...
```

#### 2. å‰ç«¯ï¼šåˆ›å»º UI ç»„ä»¶

**A. åœ¨ Zustand Store ä¸­æ·»åŠ  Action** (`src/lib/app-store.ts`)

```typescript
import { TauriClient } from '@/lib/tauri-client';
import type { ImageWritePayload } from '@/bindings';

export const useAppStore = create<AppStore>((set, get) => ({
  // ... å…¶ä»– state å’Œ actions ...

  // æ·»åŠ ä¸Šä¼ å›¾ç‰‡çš„ Action
  uploadImage: async (fileId: string, blockId: string, imageData: string, format: string, altText: string) => {
    const payload: ImageWritePayload = {
      image_data: imageData,
      format,
      alt_text: altText,
    };

    await TauriClient.block.executeCommand(fileId, {
      cmd_id: crypto.randomUUID(),
      editor_id: get().activeEditorId || '',
      cap_id: 'image.write',
      block_id: blockId,
      payload: payload as any,
      timestamp: new Date().toISOString(),
    });

    // åˆ·æ–°å—çŠ¶æ€
    const updatedBlock = await TauriClient.block.getBlock(fileId, blockId);
    set((state) => {
      const newBlocks = new Map(state.blocks);
      newBlocks.set(blockId, updatedBlock);
      return { blocks: newBlocks };
    });
  },
}));
```

**B. åˆ›å»ºå›¾ç‰‡å—ç¼–è¾‘å™¨ç»„ä»¶** (`src/components/editor/ImageBlockEditor.tsx`)

```typescript
import { useState } from 'react';
import { useAppStore } from '@/lib/app-store';
import { Button } from '@/components/ui/button';
import { toast } from '@/hooks/use-toast';

interface ImageBlockEditorProps {
  fileId: string;
  blockId: string;
}

export function ImageBlockEditor({ fileId, blockId }: ImageBlockEditorProps) {
  const [uploading, setUploading] = useState(false);

  // ä» Store è·å–å—æ•°æ®å’Œ Action
  const block = useAppStore((state) => state.blocks.get(blockId));
  const uploadImage = useAppStore((state) => state.uploadImage);

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setUploading(true);

    try {
      // è¯»å–æ–‡ä»¶ä¸º Base64
      const reader = new FileReader();
      reader.onload = async (event) => {
        const base64 = event.target?.result as string;
        const imageData = base64.split(',')[1]; // ç§»é™¤ data:image/png;base64, å‰ç¼€
        const format = file.type.split('/')[1];

        try {
          // è°ƒç”¨ Zustand Action
          await uploadImage(fileId, blockId, imageData, format, file.name);

          toast({ title: 'ä¸Šä¼ æˆåŠŸ', description: 'å›¾ç‰‡å·²ä¿å­˜' });
        } catch (error) {
          toast({
            title: 'ä¸Šä¼ å¤±è´¥',
            description: error.message,
            variant: 'destructive'
          });
        }
      };

      reader.readAsDataURL(file);
    } catch (error) {
      console.error('Upload failed:', error);
      toast({ title: 'è¯»å–æ–‡ä»¶å¤±è´¥', description: error.message });
    } finally {
      setUploading(false);
    }
  };

  // æ¸²æŸ“å›¾ç‰‡
  const imageData = (block.contents as any).image_data;
  const format = (block.contents as any).format;

  return (
    <div className="space-y-4">
      {imageData ? (
        <img
          src={`data:image/${format};base64,${imageData}`}
          alt={(block.contents as any).alt_text || 'Image'}
          className="max-w-full"
        />
      ) : (
        <p>No image uploaded</p>
      )}

      <input
        type="file"
        accept="image/*"
        onChange={handleFileUpload}
        disabled={uploading}
      />
    </div>
  );
}
```

#### 3. æµ‹è¯•

**A. åç«¯æµ‹è¯•** (`src-tauri/src/extensions/image/mod.rs`)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_image_write() {
        // æµ‹è¯•ä»£ç 
    }
}
```

**B. å‰ç«¯æµ‹è¯•** (`src/components/editor/ImageBlockEditor.test.tsx`)

```typescript
import { render, screen } from '@testing-library/react';
import { ImageBlockEditor } from './ImageBlockEditor';

describe('ImageBlockEditor', () => {
  it('renders upload button', () => {
    // æµ‹è¯•ä»£ç 
  });
});
```

#### 4. æäº¤ä»£ç 

```bash
# åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout -b feat/image-block

# æäº¤åç«¯ä»£ç 
git add src-tauri/
git commit -m "feat(backend): add image block extension"

# æäº¤å‰ç«¯ä»£ç 
git add src/
git commit -m "feat(frontend): add image block editor UI"

# æ¨é€å¹¶åˆ›å»º PR
git push origin feat/image-block
```

---

## æµ‹è¯•ä¸è°ƒè¯•

### 1. å‰ç«¯è°ƒè¯•

**ä½¿ç”¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·ï¼š**

```typescript
// åœ¨ä»£ç ä¸­æ·»åŠ æ–­ç‚¹
debugger;

// ä½¿ç”¨ console
console.log('Debug:', data);
console.table(blocks);
console.error('Error:', error);
```

**åœ¨ Tauri å¼€å‘çª—å£ä¸­æ‰“å¼€ DevToolsï¼š**
- å³é”®ç‚¹å‡»çª—å£ â†’ "Inspect Element"
- æˆ–æŒ‰ `F12`

### 2. åç«¯è°ƒè¯•

**ä½¿ç”¨ println! è°ƒè¯•ï¼š**

```rust
println!("Debug: {:?}", value);
eprintln!("Error: {}", error);
```

**ä½¿ç”¨ rust-analyzer æ–­ç‚¹è°ƒè¯•ï¼š**

1. åœ¨ VS Code ä¸­å®‰è£… CodeLLDB æ‰©å±•
2. åœ¨ä»£ç ä¸­è®¾ç½®æ–­ç‚¹
3. è¿è¡Œ "Debug Rust" é…ç½®

**æŸ¥çœ‹æ—¥å¿—ï¼š**

```bash
# è¿è¡Œæ—¶ä¼šè¾“å‡ºåˆ°æ§åˆ¶å°
pnpm tauri dev
```

### 3. é›†æˆæµ‹è¯•

**æµ‹è¯•å®Œæ•´çš„å‘½ä»¤æµç¨‹ï¼š**

```rust
#[tokio::test]
async fn test_image_block_workflow() {
    // åˆ›å»ºæ–‡ä»¶
    let file_id = create_test_file().await;

    // åˆ›å»ºå›¾ç‰‡å—
    let block_id = create_block(file_id.clone(), "image").await;

    // ä¸Šä¼ å›¾ç‰‡
    let payload = ImageWritePayload {
        image_data: "base64data...".to_string(),
        format: "png".to_string(),
        alt_text: Some("Test image".to_string()),
    };

    let result = execute_image_write(file_id.clone(), block_id.clone(), payload).await;
    assert!(result.is_ok());

    // éªŒè¯çŠ¶æ€
    let block = get_block(file_id, block_id).await.unwrap();
    assert_eq!(block.block_type, "image");
}
```

---

## Git å·¥ä½œæµ

### 1. åˆ†æ”¯ç­–ç•¥

```
main (ç”Ÿäº§ç¯å¢ƒ)
  â†‘
dev (å¼€å‘ç¯å¢ƒ)
  â†‘
feature/xxx (åŠŸèƒ½åˆ†æ”¯)
bugfix/xxx (ä¿®å¤åˆ†æ”¯)
```

**ã€é‡è¦ã€‘ä¸è¦ç›´æ¥åœ¨ main/dev ä¸Šå¼€å‘**

### 2. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯

```bash
# ä» dev åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout dev
git pull origin dev
git checkout -b feat/my-feature

# å¼€å‘...

# æäº¤
git add .
git commit -m "feat: add new feature"

# æ¨é€
git push origin feat/my-feature
```

### 3. Commit è§„èŒƒ

ä½¿ç”¨ [Conventional Commits](https://www.conventionalcommits.org/) æ ¼å¼ï¼š

```
<type>(<scope>): <subject>

<body>

<footer>
```

**ç±»å‹ (type)ï¼š**
- `feat`: æ–°åŠŸèƒ½
- `fix`: Bug ä¿®å¤
- `docs`: æ–‡æ¡£æ›´æ–°
- `style`: ä»£ç æ ¼å¼ï¼ˆä¸å½±å“åŠŸèƒ½ï¼‰
- `refactor`: é‡æ„
- `test`: æµ‹è¯•ç›¸å…³
- `chore`: æ„å»º/å·¥å…·é…ç½®

**ç¤ºä¾‹ï¼š**

```bash
git commit -m "feat(editor): add image block support"
git commit -m "fix(backend): resolve permission check bug"
git commit -m "docs: update development guide"
```

### 4. åˆ›å»º Pull Request

1. æ¨é€åˆ†æ”¯åˆ°è¿œç¨‹
2. åœ¨ GitHub åˆ›å»º PRï¼ˆä» `feat/xxx` â†’ `dev`ï¼‰
3. å¡«å†™ PR æè¿°ï¼š
   - åŠŸèƒ½è¯´æ˜
   - æµ‹è¯•æƒ…å†µ
   - æˆªå›¾ï¼ˆå¦‚æœæœ‰ UI å˜æ›´ï¼‰
4. è¯·æ±‚ Code Review
5. åˆå¹¶ååˆ é™¤åˆ†æ”¯

---

## å¸¸è§ä»»åŠ¡å¿«é€ŸæŒ‡å—

### 1. æ·»åŠ æ–°çš„ Tauri Command

```bash
# 1. å®šä¹‰å‘½ä»¤
# src-tauri/src/commands/my_module.rs

#[tauri::command]
#[specta]
pub async fn my_command() -> Result<String, String> {
    Ok("result".to_string())
}

# 2. åœ¨ lib.rs ä¸­æ³¨å†Œï¼ˆdebug + releaseï¼‰

# 3. é‡å¯å¼€å‘æœåŠ¡å™¨
pnpm tauri dev

# 4. å‰ç«¯ä½¿ç”¨
import { commands } from '@/bindings';
await commands.myCommand();
```

### 2. æ·»åŠ æ–°çš„ Payload ç±»å‹

```rust
// 1. å®šä¹‰ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MyPayload {
    pub field: String,
}

// 2. åœ¨ lib.rs ä¸­æ³¨å†Œ
.typ::<extensions::my_extension::MyPayload>()

// 3. é‡å¯å¼€å‘æœåŠ¡å™¨
// 4. å‰ç«¯å¯¼å…¥
import type { MyPayload } from '@/bindings';
```

### 3. æ·»åŠ æ–°çš„èƒ½åŠ›

```rust
// 1. å®šä¹‰ Payload
#[derive(Serialize, Deserialize, Type)]
pub struct MyCapPayload { /* ... */ }

// 2. å®ç°å¤„ç†å™¨
#[capability(id = "ext.cap", target = "type")]
fn handle_my_cap(cmd: &Command, block: &Block) -> CapResult<Vec<Event>> {
    // ...
}

// 3. æ³¨å†Œèƒ½åŠ›
impl CapabilityRegistry {
    pub fn register_extensions(&mut self) {
        self.register_capability(handle_my_cap());
    }
}

// 4. æ³¨å†Œç±»å‹ï¼ˆlib.rsï¼‰
.typ::<extensions::my_extension::MyCapPayload>()
```

### 4. æ·»åŠ æ–°çš„ UI ç»„ä»¶

```bash
# 1. åˆ›å»ºç»„ä»¶æ–‡ä»¶
touch src/components/my-component/MyComponent.tsx

# 2. åˆ›å»ºæµ‹è¯•æ–‡ä»¶
touch src/components/my-component/MyComponent.test.tsx

# 3. å®ç°ç»„ä»¶å’Œæµ‹è¯•

# 4. å¯¼å‡ºç»„ä»¶
# src/components/my-component/index.ts
export { MyComponent } from './MyComponent';
```

### 5. è¿è¡Œç‰¹å®šæµ‹è¯•

```bash
# å‰ç«¯ï¼šè¿è¡Œç‰¹å®šæµ‹è¯•æ–‡ä»¶
pnpm test src/components/MyComponent.test.tsx

# åç«¯ï¼šè¿è¡Œç‰¹å®šæµ‹è¯•
cd src-tauri
cargo test test_my_function
```

---

## AI è¾…åŠ©å¼€å‘æŒ‡å—

### 1. ç»™ AI çš„ä¸Šä¸‹æ–‡

å½“ä½¿ç”¨ AI è¾…åŠ©å¼€å‘æ—¶ï¼Œæä¾›ä»¥ä¸‹ä¸Šä¸‹æ–‡ï¼š

**å‰ç«¯å¼€å‘ï¼š**
```
æˆ‘æ­£åœ¨å¼€å‘ Elfiee å‰ç«¯åŠŸèƒ½ã€‚è¯·å‚è€ƒï¼š
- å‰ç«¯å¼€å‘è§„èŒƒ: docs/mvp/dev/å‰ç«¯å¼€å‘è§„èŒƒ.md
- æˆ‘åªèƒ½é€šè¿‡ TauriClient è°ƒç”¨åç«¯ï¼ˆç¦æ­¢ç›´æ¥ä½¿ç”¨ commandsï¼‰
- ä¸èƒ½æ‰‹åŠ¨ç¼–è¾‘ bindings.tsï¼ˆç”± tauri-specta è‡ªåŠ¨ç”Ÿæˆï¼‰
- æ‰€æœ‰ Payload ç±»å‹ä» bindings.ts å¯¼å…¥
```

**åç«¯å¼€å‘ï¼š**
```
æˆ‘æ­£åœ¨å¼€å‘ Elfiee åç«¯åŠŸèƒ½ã€‚è¯·å‚è€ƒï¼š
- åç«¯å¼€å‘è§„èŒƒ: docs/mvp/dev/åç«¯å¼€å‘è§„èŒƒ.md
- æ‰€æœ‰å‰ç«¯æ¥å£å¿…é¡»æ˜¯ Tauri Commandï¼ˆæ·»åŠ  #[specta] å®ï¼‰
- æ¯ä¸ªèƒ½åŠ›å¿…é¡»å®šä¹‰ç±»å‹åŒ– Payloadï¼ˆæ·»åŠ  #[derive(Type)]ï¼‰
- éµå¾ªäº‹ä»¶æº¯æºæ¶æ„ï¼ˆé€šè¿‡ Event è®°å½•çŠ¶æ€å˜æ›´ï¼‰
- æ³¨æ„ Read vs Write èƒ½åŠ›çš„ Entity å­—æ®µåŒºåˆ«
```

### 2. AI å¼€å‘æ–°åŠŸèƒ½æ—¶çš„æ£€æŸ¥æ¸…å•

**åç«¯å¼€å‘æ£€æŸ¥ï¼š**
- [ ] å®šä¹‰äº† Payload ç±»å‹ï¼ˆæ·»åŠ  `#[derive(Type)]`ï¼‰
- [ ] Tauri Command æ·»åŠ äº† `#[specta]` å®
- [ ] åœ¨ lib.rs çš„ debug å’Œ release æ¨¡å¼éƒ½æ³¨å†Œäº†å‘½ä»¤
- [ ] åœ¨ lib.rs æ³¨å†Œäº†æ‰€æœ‰ Payload ç±»å‹
- [ ] ç¼–å†™äº†å•å…ƒæµ‹è¯•
- [ ] èƒ½åŠ›å¤„ç†å™¨ä½¿ç”¨ `#[capability]` å®
- [ ] åœ¨ CapabilityRegistry ä¸­æ³¨å†Œäº†èƒ½åŠ›

**å‰ç«¯å¼€å‘æ£€æŸ¥ï¼š**
- [ ] æ²¡æœ‰æ‰‹åŠ¨ç¼–è¾‘ `src/bindings.ts`
- [ ] ä½¿ç”¨ TauriClient è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ commands
- [ ] æ­£ç¡®å¤„ç† Result ç±»å‹
- [ ] ä½¿ç”¨ç”Ÿæˆçš„ Payload ç±»å‹ï¼ˆä» bindings å¯¼å…¥ï¼‰
- [ ] ä¸ç›´æ¥ä¿®æ”¹ Block å¯¹è±¡ï¼Œä½¿ç”¨å‘½ä»¤æ›´æ–°
- [ ] æ·»åŠ äº†é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ

### 3. å¸¸è§ AI é”™è¯¯

| é”™è¯¯ç±»å‹ | âŒ é”™è¯¯åšæ³• | âœ… æ­£ç¡®åšæ³• |
|---------|-----------|-----------|
| **å‰ç«¯è°ƒç”¨** | ç›´æ¥å¯¼å…¥åç«¯ä»£ç  | ä½¿ç”¨ TauriClient |
| **ç±»å‹ç»‘å®š** | æ‰‹åŠ¨ç¼–è¾‘ bindings.ts | åœ¨åç«¯å®šä¹‰ + lib.rs æ³¨å†Œ |
| **Payload** | æ‰‹åŠ¨è§£æ JSON | å®šä¹‰ç±»å‹ + serde_json::from_value |
| **çŠ¶æ€ä¿®æ”¹** | ç›´æ¥ä¿®æ”¹å¯¹è±¡ | ä½¿ç”¨ create_event() è¿”å› Event |
| **Entity** | Read ç”¨ block_id | Write=block_id, Read=editor_id |

**âœ… AI å¼€å‘å‰å¿…è¯»ï¼š**
```
1. å‰ç«¯åªèƒ½é€šè¿‡ TauriClient è°ƒç”¨åç«¯ï¼ˆç¦æ­¢ç›´æ¥ä½¿ç”¨ commandsï¼‰
2. ä¸è¦æ‰‹åŠ¨ç¼–è¾‘ bindings.tsï¼ˆç”± tauri-specta è‡ªåŠ¨ç”Ÿæˆï¼‰
3. æ‰€æœ‰ç±»å‹å¿…é¡»åœ¨ lib.rs çš„ debug å’Œ release éƒ½æ³¨å†Œ
4. èƒ½åŠ›å¤„ç†å™¨æ³¨æ„ Read/Write çš„ Entity åŒºåˆ«
5. ä½¿ç”¨ create_event() è€Œä¸æ˜¯ç›´æ¥ä¿®æ”¹çŠ¶æ€
```

---

## æ€»ç»“

### å¼€å‘æµç¨‹è¦ç‚¹

1. **ç¯å¢ƒæ­å»º** â†’ å®‰è£… Rust + Node.js + pnpm â†’ è¿è¡Œ `pnpm tauri dev`
2. **å¼€å‘æ¨¡å¼** â†’ å‰åç«¯çƒ­é‡è½½ â†’ bindings.ts è‡ªåŠ¨ç”Ÿæˆ
3. **æ·»åŠ åŠŸèƒ½** â†’ åç«¯å®šä¹‰æ¥å£ â†’ æ³¨å†Œå‘½ä»¤å’Œç±»å‹ â†’ å‰ç«¯ä½¿ç”¨
4. **æµ‹è¯•** â†’ ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯• â†’ è¿è¡Œæµ‹è¯•ç¡®ä¿æ­£ç¡®
5. **æäº¤ä»£ç ** â†’ éµå¾ª Git å·¥ä½œæµ â†’ åˆ›å»º PR â†’ Code Review â†’ åˆå¹¶

### æ ¸å¿ƒåŸåˆ™

1. **å‰åç«¯ä¸¥æ ¼åˆ†ç¦»** - é€šè¿‡ Tauri IPC é€šä¿¡
2. **è‡ªåŠ¨ç±»å‹ç”Ÿæˆ** - ä½¿ç”¨ tauri-specta ç¡®ä¿ç±»å‹å®‰å…¨
3. **äº‹ä»¶æº¯æº** - æ‰€æœ‰çŠ¶æ€å˜æ›´é€šè¿‡ Event è®°å½•
4. **èƒ½åŠ›ä¸ºä¸­å¿ƒ** - åŸºäº CBAC çš„æƒé™æ¨¡å‹
5. **æµ‹è¯•é©±åŠ¨** - ç¼–å†™æµ‹è¯•ç¡®ä¿ä»£ç è´¨é‡

### é‡åˆ°é—®é¢˜æ—¶

1. **æŸ¥çœ‹æ–‡æ¡£**:
   - [å‰ç«¯å¼€å‘è§„èŒƒ](./å‰ç«¯å¼€å‘è§„èŒƒ.md) - å‰ç«¯å¼€å‘è¯¦ç»†æŒ‡å—
   - [åç«¯å¼€å‘è§„èŒƒ](./åç«¯å¼€å‘è§„èŒƒ.md) - åç«¯å¼€å‘è¯¦ç»†æŒ‡å—ï¼ˆåŒ…å«å…³é”®æ¦‚å¿µï¼‰
   - [CLAUDE.md](../../CLAUDE.md) - é¡¹ç›®æ€»è§ˆ

2. **æ£€æŸ¥ bindings.ts**:
   ```bash
   # é‡æ–°ç”Ÿæˆ bindings
   pnpm tauri dev
   ```

3. **æŸ¥çœ‹æ—¥å¿—**:
   - å‰ç«¯ï¼šæµè§ˆå™¨å¼€å‘è€…å·¥å…· Console
   - åç«¯ï¼šç»ˆç«¯è¾“å‡º

4. **è¿è¡Œæµ‹è¯•**:
   ```bash
   pnpm test          # å‰ç«¯
   cd src-tauri && cargo test  # åç«¯
   ```

---

## ğŸ æµç¨‹è‡ªæŸ¥æ¸…å• (Checklist)

> åœ¨å®Œæˆä»»åŠ¡å‰ï¼Œè¯·å¯¹ç…§ä»¥ä¸‹äº‹é¡¹è¿›è¡Œè‡ªæŸ¥ã€‚

- [ ] **å‡†å¤‡é˜¶æ®µ**: æ˜¯å¦å®‰è£…å¹¶æ›´æ–°äº† `elfiee-ext-gen` å·¥å…·ï¼Ÿ
- [ ] **å¼€å‘é˜¶æ®µ**: æ˜¯å¦å…ˆè¿è¡Œäº† TDD æµ‹è¯•ç¡®ä¿å¤±è´¥ï¼Œç„¶åå†å¼€å§‹ç¼–å†™å®ç°ä»£ç ï¼Ÿ
- [ ] **éªŒè¯é˜¶æ®µ**: æ˜¯å¦è¿è¡Œäº† `elfiee-ext-gen validate` æ£€æŸ¥æ‰€æœ‰æ³¨å†Œé¡¹ï¼Ÿ
- [ ] **åŒæ­¥é˜¶æ®µ**: æ˜¯å¦è¿è¡Œäº† `pnpm tauri dev` ç¡®ä¿å‰ç«¯ `bindings.ts` å·²æ›´æ–°ï¼Ÿ
- [ ] **ä»£ç é£æ ¼**: æ˜¯å¦è¿è¡Œäº† `make fmt` æ ¼å¼åŒ–äº†å‰åç«¯ä»£ç ï¼Ÿ
- [ ] **Gitæäº¤**: æ˜¯å¦éµå¾ªäº† `Conventional Commits` è§„èŒƒï¼Ÿ

**æ›´å¤šè¯¦ç»†è§„åˆ™è¯·å‚è€ƒï¼š[AI_INDEX.md](./AI_INDEX.md)**

---

**ç›¸å…³æ–‡æ¡£ï¼š**
- [å‰ç«¯å¼€å‘è§„èŒƒ](./å‰ç«¯å¼€å‘è§„èŒƒ.md) - å‰ç«¯å¼€å‘è¯¦ç»†æŒ‡å—
- [åç«¯å¼€å‘è§„èŒƒ](./åç«¯å¼€å‘è§„èŒƒ.md) - åç«¯å¼€å‘è¯¦ç»†æŒ‡å—ï¼ˆåŒ…å«å…³é”®æ¦‚å¿µï¼‰
- [CLAUDE.md](../../CLAUDE.md) - é¡¹ç›®æ€»è§ˆ
- [AI_INDEX.md](./AI_INDEX.md) - AI åŠ©æ‰‹æ ¸å¿ƒè§„èŒƒç´¢å¼•
