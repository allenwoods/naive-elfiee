# Elfiee åç«¯å¼€å‘è§„èŒƒ

> æœ¬æ–‡æ¡£é¢å‘ Elfiee é¡¹ç›®çš„åç«¯å¼€å‘è€…ï¼ˆåŒ…æ‹¬ AI è¾…åŠ©å¼€å‘ï¼‰ï¼Œå®šä¹‰äº†åç«¯å¼€å‘çš„æ ¸å¿ƒåŸåˆ™ã€æ¶æ„è§„èŒƒå’Œæœ€ä½³å®è·µã€‚

## ğŸ¯ æ ¸å¿ƒé‡ç‚¹ï¼ˆå¿…è¯»ï¼‰

### âš ï¸ äº”å¤§ç¡¬æ€§è§„åˆ™

1. **ã€å¼ºåˆ¶ã€‘æ‰€æœ‰å‰ç«¯æ¥å£å¿…é¡»æ˜¯ Tauri Command**
   - æ·»åŠ  `#[tauri::command]` + `#[specta]` å®
   - åœ¨ lib.rs çš„ **debug å’Œ release** æ¨¡å¼éƒ½è¦æ³¨å†Œ

2. **ã€å¼ºåˆ¶ã€‘æ¯ä¸ªèƒ½åŠ›å¿…é¡»å®šä¹‰ç±»å‹åŒ– Payload**
   - æ·»åŠ  `#[derive(Serialize, Deserialize, Type)]`
   - åœ¨ lib.rs ä¸­æ³¨å†Œ `.typ::<MyPayload>()`

3. **ã€å…³é”®ã€‘Read vs Write èƒ½åŠ›çš„ Entity ä¸åŒ**
   - **Write**: `entity = block.block_id` (è¢«ä¿®æ”¹çš„å—)
   - **Read**: `entity = cmd.editor_id` (è¯»å–è€…)

4. **ã€å¼ºåˆ¶ã€‘é€šè¿‡ Event è®°å½•çŠ¶æ€å˜æ›´ï¼Œä¸ç›´æ¥ä¿®æ”¹**
   - âœ… ä½¿ç”¨ `create_event()` è¿”å› Event
   - âŒ ä¸ç›´æ¥ä¿®æ”¹ Block å¯¹è±¡

5. **ã€å¼ºåˆ¶ã€‘CBAC æˆæƒæ£€æŸ¥**
   - Owner æ€»æ˜¯æˆæƒ
   - é Owner éœ€è¦ Grant
   - ä½¿ç”¨ `#[capability]` å®è‡ªåŠ¨ç”Ÿæˆæˆæƒ

### ğŸ“‹ å¿«é€ŸæŸ¥é˜…

```rust
// 1. å®šä¹‰ Tauri Command
#[tauri::command]
#[specta]
pub async fn my_command(param: String) -> Result<MyResult, String> { }

// 2. å®šä¹‰ Payload ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MyPayload { pub field: String }

// 3. å®šä¹‰èƒ½åŠ›å¤„ç†å™¨
#[capability(id = "ext.write", target = "block_type")]
fn handle_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    let block = block.ok_or("Block required")?;
    let payload: MyPayload = serde_json::from_value(cmd.payload.clone())?;

    let event = create_event(
        block.block_id.clone(),  // Write: entity = block_id
        cmd.cap_id.as_str(),     // cap_id
        json!(new_contents),     // Value
        &cmd.editor_id,          // editor_id
        1,                       // vector clock count
    )?;

    Ok(vec![event])
}

// 4. åœ¨ lib.rs æ³¨å†Œ
.commands(collect_commands![my_command])
.typ::<MyPayload>()
```

---

## ç›®å½•

1. [æ ¸å¿ƒåŸåˆ™](#æ ¸å¿ƒåŸåˆ™)
2. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
3. [Tauri Command å¼€å‘](#tauri-command-å¼€å‘)
4. [èƒ½åŠ›ç³»ç»Ÿå¼€å‘](#èƒ½åŠ›ç³»ç»Ÿå¼€å‘)ï¼ˆâ­ åŒ…å« Read/Writeã€Payloadã€CBACï¼‰
5. [æ‰©å±•å¼€å‘](#æ‰©å±•å¼€å‘)
6. [äº‹ä»¶æº¯æº](#äº‹ä»¶æº¯æº)ï¼ˆâ­ åŒ…å«å‘é‡æ—¶é’Ÿï¼‰
7. [ç±»å‹å®‰å…¨ä¸è‡ªåŠ¨ç”Ÿæˆ](#ç±»å‹å®‰å…¨ä¸è‡ªåŠ¨ç”Ÿæˆ)
8. [æµ‹è¯•è§„èŒƒ](#æµ‹è¯•è§„èŒƒ)
9. [å¸¸è§é”™è¯¯ä¸é™·é˜±](#å¸¸è§é”™è¯¯ä¸é™·é˜±)

---

## æ ¸å¿ƒåŸåˆ™

### 1. å‰ç«¯åªèƒ½é€šè¿‡æš´éœ²çš„æ¥å£è®¿é—®åç«¯

**ã€ç¡¬æ€§è§„åˆ™ã€‘æ‰€æœ‰å‰ç«¯å¯è°ƒç”¨çš„åŠŸèƒ½å¿…é¡»å®šä¹‰ä¸º Tauri Command**

åç«¯ä»£ç è¿è¡Œåœ¨ç‹¬ç«‹çš„ Rust è¿›ç¨‹ä¸­ï¼Œå‰ç«¯ï¼ˆWebViewï¼‰æ— æ³•ç›´æ¥è®¿é—®ã€‚å‰ç«¯åªèƒ½é€šè¿‡ Tauri IPC è°ƒç”¨åç«¯ã€‚

**âœ… æ­£ç¡®åšæ³•ï¼šå®šä¹‰ Tauri Command**

```rust
#[tauri::command]
#[specta]
pub async fn execute_command(
    file_id: String,
    cmd: Command,
    state: State<'_, AppState>,
) -> Result<Vec<Event>, String> {
    // å®ç°é€»è¾‘
}
```

**âŒ é”™è¯¯åšæ³•ï¼šå®šä¹‰æ™®é€šå‡½æ•°ä½†æœŸæœ›å‰ç«¯è°ƒç”¨**

```rust
// âŒ å‰ç«¯æ— æ³•è°ƒç”¨è¿™ä¸ªå‡½æ•°
pub fn some_utility(file_id: String) -> Result<Block, String> {
    // å®ç°é€»è¾‘
}
```

### 2. ä½¿ç”¨ tauri-specta è‡ªåŠ¨ç”Ÿæˆç±»å‹

**ã€ç¡¬æ€§è§„åˆ™ã€‘æ‰€æœ‰ Tauri Command å’Œç›¸å…³ç±»å‹å¿…é¡»ä½¿ç”¨ tauri-specta**

- åœ¨ Tauri Command ä¸Šæ·»åŠ  `#[specta]` å®
- åœ¨æ•°æ®ç±»å‹ä¸Šæ·»åŠ  `#[derive(Type)]` å®
- åœ¨ `src-tauri/src/lib.rs` ä¸­æ³¨å†Œå‘½ä»¤å’Œç±»å‹

### 3. éµå¾ªäº‹ä»¶æº¯æºæ¶æ„

**ã€æ ¸å¿ƒæ¶æ„ã€‘æ‰€æœ‰çŠ¶æ€å˜æ›´é€šè¿‡ Event è®°å½•**

```
Command â†’ æˆæƒæ£€æŸ¥ â†’ Capability Handler â†’ Event â†’ State Projection
```

- ä¸ç›´æ¥ä¿®æ”¹çŠ¶æ€
- æ‰€æœ‰ä¿®æ”¹é€šè¿‡ç”Ÿæˆ Event å®ç°
- State ç”± Event é‡æ”¾æ„å»º

### 4. èƒ½åŠ›ä¸ºä¸­å¿ƒçš„æƒé™æ¨¡å‹ (CBAC)

**ã€æ ¸å¿ƒæ¶æ„ã€‘åŸºäºèƒ½åŠ›çš„è®¿é—®æ§åˆ¶**

- æ¯ä¸ªæ“ä½œç”± Capability å®šä¹‰
- æˆæƒé€šè¿‡ `certificator` æ£€æŸ¥
- Block Owner æ‹¥æœ‰æ‰€æœ‰æƒé™
- å…¶ä»– Editor éœ€è¦ Grant æˆæƒ

---

## æ¶æ„æ¦‚è§ˆ

### æŠ€æœ¯æ ˆ

- **è¯­è¨€**: Rust (Edition 2021)
- **æ¡†æ¶**: Tauri 2.x
- **æ•°æ®åº“**: SQLite (é€šè¿‡ rusqlite)
- **å¼‚æ­¥è¿è¡Œæ—¶**: Tokio
- **åºåˆ—åŒ–**: serde + serde_json
- **ç±»å‹ç”Ÿæˆ**: tauri-specta + specta

### ç›®å½•ç»“æ„

```
src-tauri/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs                 # Tauri å…¥å£
â”‚   â”œâ”€â”€ lib.rs                  # ã€å…³é”®ã€‘Tauri å‘½ä»¤æ³¨å†Œ + Specta é…ç½®
â”‚   â”œâ”€â”€ models/                 # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ block.rs            # Block å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ command.rs          # Command å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ event.rs            # Event å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ editor.rs           # Editor å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ grant.rs            # Grant å®šä¹‰
â”‚   â”‚   â””â”€â”€ payloads.rs         # Core payload ç±»å‹
â”‚   â”œâ”€â”€ commands/               # ã€é‡è¦ã€‘Tauri Commands
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ file.rs             # æ–‡ä»¶æ“ä½œå‘½ä»¤
â”‚   â”‚   â”œâ”€â”€ block.rs            # å—æ“ä½œå‘½ä»¤
â”‚   â”‚   â”œâ”€â”€ editor.rs           # ç¼–è¾‘å™¨æ“ä½œå‘½ä»¤
â”‚   â”‚   â”œâ”€â”€ event.rs            # äº‹ä»¶æ“ä½œå‘½ä»¤
â”‚   â”‚   â””â”€â”€ checkout.rs         # å·¥ä½œåŒºå¯¼å‡ºå‘½ä»¤
â”‚   â”œâ”€â”€ capabilities/           # èƒ½åŠ›ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ core.rs             # æ ¸å¿ƒèƒ½åŠ›æ¥å£
â”‚   â”‚   â”œâ”€â”€ registry.rs         # èƒ½åŠ›æ³¨å†Œè¡¨
â”‚   â”‚   â”œâ”€â”€ grants.rs           # æˆæƒè¡¨
â”‚   â”‚   â””â”€â”€ builtins/           # å†…ç½®èƒ½åŠ›
â”‚   â”‚       â”œâ”€â”€ create.rs
â”‚   â”‚       â”œâ”€â”€ delete.rs
â”‚   â”‚       â”œâ”€â”€ link.rs
â”‚   â”‚       â”œâ”€â”€ grant.rs
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ extensions/             # æ‰©å±•ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ markdown/           # Markdown æ‰©å±•
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ markdown_write.rs
â”‚   â”‚   â”‚   â””â”€â”€ markdown_read.rs
â”‚   â”‚   â”œâ”€â”€ code/               # Code æ‰©å±•
â”‚   â”‚   â””â”€â”€ directory/          # Directory æ‰©å±•
â”‚   â”œâ”€â”€ engine/                 # Elfile Engine (äº‹ä»¶æº¯æºå¼•æ“)
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ actor.rs            # Engine Actor
â”‚   â”‚   â”œâ”€â”€ manager.rs          # Engine Manager
â”‚   â”‚   â”œâ”€â”€ event_store.rs      # Event Store (SQLite)
â”‚   â”‚   â””â”€â”€ state.rs            # State Projector
â”‚   â”œâ”€â”€ elf/                    # .elf æ–‡ä»¶æ ¼å¼å¤„ç†
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ archive.rs          # ZIP æ¡£æ¡ˆæ“ä½œ
â”‚   â”œâ”€â”€ utils/                  # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ fs_scanner.rs
â”‚   â”‚   â”œâ”€â”€ path_validator.rs
â”‚   â”‚   â””â”€â”€ time.rs
â”‚   â”œâ”€â”€ state.rs                # å…¨å±€åº”ç”¨çŠ¶æ€
â”‚   â””â”€â”€ config.rs               # é…ç½®ç®¡ç†
â”œâ”€â”€ Cargo.toml                  # Rust ä¾èµ–
â”œâ”€â”€ tauri.conf.json             # Tauri é…ç½®
â””â”€â”€ build.rs                    # æ„å»ºè„šæœ¬
```

---

## Tauri Command å¼€å‘

### 1. å®šä¹‰ Tauri Command

**ã€è§„èŒƒã€‘æ‰€æœ‰æš´éœ²ç»™å‰ç«¯çš„å‡½æ•°å¿…é¡»ï¼š**
1. æ·»åŠ  `#[tauri::command]` å®
2. æ·»åŠ  `#[specta]` å®ï¼ˆç”¨äºç±»å‹ç”Ÿæˆï¼‰
3. åœ¨å‡½æ•°ä¸Šæ–¹å†™è¯¦ç»†çš„æ–‡æ¡£æ³¨é‡Š
4. è¿”å› `Result<T, String>` ç±»å‹

**ç¤ºä¾‹ï¼š**

```rust
use tauri::State;
use crate::models::{Block, Command, Event};
use crate::state::AppState;

/// Execute a command on a block in the specified file.
///
/// This is the primary way to modify blocks. Commands are processed by the engine actor,
/// which handles authorization, execution, and persistence.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file containing the block
/// * `cmd` - Command to execute (create, delete, link, write, etc.)
///
/// # Returns
/// * `Ok(events)` - Events generated by the command execution
/// * `Err(message)` - Error description if execution fails
#[tauri::command]
#[specta]
pub async fn execute_command(
    file_id: String,
    cmd: Command,
    state: State<'_, AppState>,
) -> Result<Vec<Event>, String> {
    // 1. è·å– Engine Manager
    let manager = state.engine_manager.read().await;

    // 2. è·å–æ–‡ä»¶çš„ Engine Actor
    let engine = manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File not open: {}", file_id))?;

    // 3. å‘é€å‘½ä»¤åˆ° Engine Actor
    engine.execute_command(cmd).await
}
```

### 2. åœ¨ lib.rs ä¸­æ³¨å†Œå‘½ä»¤

**ã€å…³é”®æ–‡ä»¶ã€‘`src-tauri/src/lib.rs`**

**å¿…é¡»åœ¨ä¸¤ä¸ªåœ°æ–¹æ³¨å†Œå‘½ä»¤ï¼š**

1. **Debug æ¨¡å¼** (ä½¿ç”¨ tauri-specta)ï¼š

```rust
#[cfg(debug_assertions)]
let builder = {
    let specta_builder = tauri_specta::Builder::<tauri::Wry>::new()
        .commands(tauri_specta::collect_commands![
            // æ–‡ä»¶æ“ä½œ
            commands::file::create_file,
            commands::file::open_file,
            commands::file::save_file,
            // å—æ“ä½œ
            commands::block::execute_command,
            commands::block::get_all_blocks,
            // ... å…¶ä»–å‘½ä»¤
        ])
        // æ³¨å†Œç±»å‹
        .typ::<models::Block>()
        .typ::<models::Command>()
        // ... å…¶ä»–ç±»å‹
        ;

    // å¯¼å‡º TypeScript ç»‘å®š
    specta_builder
        .export(
            Typescript::default().bigint(BigIntExportBehavior::Number),
            "../src/bindings.ts",
        )
        .expect("Failed to export TypeScript bindings");

    builder.invoke_handler(specta_builder.invoke_handler())
};
```

2. **Release æ¨¡å¼** (ä½¿ç”¨æ ‡å‡† Tauri handler)ï¼š

```rust
#[cfg(not(debug_assertions))]
let builder = builder.invoke_handler(tauri::generate_handler![
    // æ–‡ä»¶æ“ä½œ
    commands::file::create_file,
    commands::file::open_file,
    commands::file::save_file,
    // å—æ“ä½œ
    commands::block::execute_command,
    commands::block::get_all_blocks,
    // ... å…¶ä»–å‘½ä»¤ï¼ˆå¿…é¡»ä¸ debug æ¨¡å¼ä¸€è‡´ï¼‰
]);
```

**ã€é‡è¦ã€‘ä¸¤ä¸ªåˆ—è¡¨å¿…é¡»å®Œå…¨ä¸€è‡´ï¼**

### 3. å‘½ä»¤å‘½åè§„èŒƒ

**Rust å‡½æ•°å‘½åï¼š**
- ä½¿ç”¨ `snake_case`
- åŠ¨è¯åœ¨å‰ï¼š`create_file`, `execute_command`, `get_block`

**å‰ç«¯è‡ªåŠ¨ç”Ÿæˆå‘½åï¼š**
- è‡ªåŠ¨è½¬æ¢ä¸º `camelCase`
- `create_file` â†’ `createFile`
- `get_all_blocks` â†’ `getAllBlocks`

---

## èƒ½åŠ›ç³»ç»Ÿå¼€å‘

### 1. èƒ½åŠ›æ¶æ„

**Capability** æ˜¯ Elfiee çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®šä¹‰äº†å¯ä»¥å¯¹ Block æ‰§è¡Œçš„æ“ä½œã€‚

**èƒ½åŠ›ç»„æˆéƒ¨åˆ†ï¼š**

```rust
pub struct Capability {
    pub id: String,                          // èƒ½åŠ› ID (e.g., "markdown.write")
    pub target_block_type: Option<String>,   // ç›®æ ‡å—ç±»å‹ (None = æ‰€æœ‰ç±»å‹)
    pub certificator: Box<dyn Certificator>, // æˆæƒæ£€æŸ¥å™¨
    pub handler: Box<dyn CapabilityHandler>, // æ‰§è¡Œå¤„ç†å™¨
}
```

### 1.1 Read vs Write èƒ½åŠ›çš„åŒºåˆ«

**ã€å…³é”®æ¦‚å¿µã€‘Write å’Œ Read èƒ½åŠ›çš„ Event ç»“æ„ä¸åŒ**

èƒ½åŠ›åˆ†ä¸ºä¸¤å¤§ç±»ï¼Œå®ƒä»¬åœ¨ Event çš„ `entity` å­—æ®µä¸Šæœ‰æœ¬è´¨åŒºåˆ«ï¼š

#### Write èƒ½åŠ›ï¼ˆä¿®æ”¹çŠ¶æ€ï¼‰

**Entity = block.block_id**ï¼ˆè¢«ä¿®æ”¹çš„å—ï¼‰

```rust
/// Write èƒ½åŠ›ï¼šä¿®æ”¹ Block çš„å†…å®¹
#[capability(id = "markdown.write", target = "markdown")]
fn handle_markdown_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    let block = block.ok_or("Block not found")?;
    let payload: MarkdownWritePayload = serde_json::from_value(cmd.payload.clone())?;

    let mut new_contents = serde_json::Map::new();
    new_contents.insert("markdown".to_string(), json!(payload.content));

    // âœ… Entity æ˜¯è¢«ä¿®æ”¹çš„ Block
    let event = create_event(
        block.block_id.clone(),         // â† Entity: è¢«ä¿®æ”¹çš„å—
        cmd.cap_id.as_str(),            // cap_id (è‡ªåŠ¨æ‹¼æ¥ editor_id)
        json!(new_contents),            // Value: æ–°çŠ¶æ€
        &cmd.editor_id,                 // editor_id
        1,                              // vector clock count
    )?;

    Ok(vec![event])
}
```

**ä¸ºä»€ä¹ˆ Entity æ˜¯ block_idï¼Ÿ**
- StateProjector éœ€è¦çŸ¥é“**å“ªä¸ªå—è¢«ä¿®æ”¹äº†**
- é€šè¿‡é‡æ”¾äº‹ä»¶ï¼ŒStateProjector æ›´æ–°å¯¹åº”å—çš„çŠ¶æ€
- Entity æŒ‡å‘çŠ¶æ€å˜æ›´çš„ç›®æ ‡å¯¹è±¡

#### Read èƒ½åŠ›ï¼ˆè§‚å¯ŸçŠ¶æ€ï¼‰

**Entity = cmd.editor_id**ï¼ˆè¯»å–è€…ï¼‰

```rust
/// Read èƒ½åŠ›ï¼šè¯»å– Block çš„å†…å®¹ï¼ˆä¸ä¿®æ”¹ï¼‰
#[capability(id = "markdown.read", target = "markdown")]
fn handle_markdown_read(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    let block = block.ok_or("Block not found")?;

    let markdown = (block.contents.as_object()
        .and_then(|obj| obj.get("markdown"))
        .and_then(|v| v.as_str())
        .unwrap_or(""))
        .to_string();

    // âœ… Entity æ˜¯è¯»å–è€…ï¼ˆEditorï¼‰
    let event = create_event(
        cmd.editor_id.clone(),          // â† Entity: è¯»å–è€…
        cmd.cap_id.as_str(),            // cap_id
        json!({
            "block_id": block.block_id, // å“ªä¸ªå—è¢«è¯»å–
            "markdown": markdown,       // è¯»å–çš„æ•°æ®
        }),
        &cmd.editor_id,                 // editor_id
        1,
    )?;

    Ok(vec![event])
}
```

**ä¸ºä»€ä¹ˆ Entity æ˜¯ editor_idï¼Ÿ**
- Read æ“ä½œä¸ä¿®æ”¹ Block çŠ¶æ€
- Event è®°å½•çš„æ˜¯**è°è¯»å–äº†ä»€ä¹ˆ**ï¼ˆå®¡è®¡æ—¥å¿—ï¼‰
- Entity æŒ‡å‘æ‰§è¡Œè¯»å–çš„ Editor

#### å¯¹æ¯”æ€»ç»“

| èƒ½åŠ›ç±»å‹ | Entity | å«ä¹‰ | StateProjector è¡Œä¸º |
|---------|--------|------|-------------------|
| **Write** | `block.block_id` | è¢«ä¿®æ”¹çš„å— | æ›´æ–° Block çŠ¶æ€ |
| **Read** | `cmd.editor_id` | è¯»å–è€… | è®°å½•å®¡è®¡æ—¥å¿—ï¼Œä¸ä¿®æ”¹ Block |

### 2. ä½¿ç”¨ #[capability] å®å®šä¹‰èƒ½åŠ›

**ã€æ¨èã€‘ä½¿ç”¨å®ç®€åŒ–èƒ½åŠ›å®šä¹‰**

```rust
use capability_macros::capability;
use crate::capabilities::core::{CapResult, create_event};
use crate::models::{Block, Command, Event};

/// Handler for markdown.write capability.
///
/// Writes markdown content to a markdown block's contents.markdown field.
#[capability(id = "markdown.write", target = "markdown")]
fn handle_markdown_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    let block = block.ok_or("Block required")?;
    // 1. è§£æ payload
    let payload: MarkdownWritePayload = serde_json::from_value(cmd.payload.clone())
        .map_err(|e| format!("Invalid payload: {}", e))?;

    // 2. éªŒè¯
    if payload.content.is_empty() {
        return Err("Content cannot be empty".into());
    }

    // 3. æ„å»ºæ–°çŠ¶æ€
    let mut new_contents = serde_json::Map::new();
    new_contents.insert("markdown".to_string(), json!(payload.content));

    // 4. åˆ›å»ºäº‹ä»¶
    let event = create_event(
        block.block_id.clone(),
        cmd.cap_id.as_str(),
        json!(new_contents),
        &cmd.editor_id,
        1,
    )?;

    Ok(vec![event])
}
```

**å®è‡ªåŠ¨ç”Ÿæˆï¼š**
- `Certificator` å®ç°ï¼ˆé»˜è®¤æ£€æŸ¥ owner æˆ– grantï¼‰
- `CapabilityHandler` å®ç°
- èƒ½åŠ›æ³¨å†Œä»£ç 

### 3. Payload ç±»å‹å®šä¹‰

**ã€å…³é”®è§„åˆ™ã€‘æ¯ä¸ªèƒ½åŠ›å¿…é¡»å®šä¹‰ Payload ç±»å‹**

#### ä¸ºä»€ä¹ˆ Payload ç±»å‹å¾ˆé‡è¦ï¼Ÿ

**é—®é¢˜åœºæ™¯ï¼š**å‰ç«¯å’Œåç«¯å¯¹ Payload ç»“æ„çš„ç†è§£ä¸ä¸€è‡´ï¼Œå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯ã€‚

#### âŒ Bad Practice - æ‰‹åŠ¨ JSON è§£æ

**åç«¯ï¼š**
```rust
// âŒ æ‰‹åŠ¨ä» JSON æå–å­—æ®µ
#[capability(id = "markdown.write", target = "markdown")]
fn handle_markdown_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    // æ‰‹åŠ¨è§£æ
    let content = cmd.payload.get("content")
        .and_then(|v| v.as_str())
        .ok_or("Missing 'content' in payload")?;

    // ... å®ç°é€»è¾‘
}
```

**å‰ç«¯ï¼š**
```typescript
// âŒ æ‰‹åŠ¨å®šä¹‰æ¥å£ï¼ˆå¯èƒ½ä¸åç«¯ä¸ä¸€è‡´ï¼‰
interface WriteBlockPayload {
  content: { type: 'text', data: string }  // â† é”™è¯¯çš„ç»“æ„ï¼
}

await TauriClient.block.executeCommand(fileId, {
  // ... å…¶ä»–å­—æ®µ ...
  payload: {
    content: { type: 'text', data: 'Hello' }  // â† åµŒå¥—å¯¹è±¡ï¼Œä¸åç«¯æœŸæœ›ä¸ç¬¦
  },
});
```

**è¿è¡Œæ—¶é”™è¯¯ï¼š**
```
Error: Missing 'content' in payload
```

**é—®é¢˜åŸå› ï¼š**
- åç«¯æœŸæœ› `content` æ˜¯ `String`
- å‰ç«¯å‘é€çš„æ˜¯ `{ type: 'text', data: 'Hello' }`
- ç±»å‹ä¸åŒ¹é…ï¼Œä½† TypeScript æ— æ³•æ£€æµ‹ï¼ˆå› ä¸º payload æ˜¯ `any`ï¼‰

#### âœ… Good Practice - ç±»å‹åŒ– Payload

**åç«¯ï¼šå®šä¹‰ Payload ç±»å‹**

```rust
// src/extensions/markdown/mod.rs
use serde::{Deserialize, Serialize};
use specta::Type;

/// Payload for markdown.write capability
///
/// This payload is used to write markdown content to a markdown block.
/// The content is stored directly as a string in the block's contents.markdown field.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MarkdownWritePayload {
    /// The markdown content to write to the block
    pub content: String,  // â† ç›´æ¥æ˜¯ Stringï¼Œä¸æ˜¯åµŒå¥—å¯¹è±¡
}
```

**åœ¨ lib.rs ä¸­æ³¨å†Œç±»å‹ï¼š**

```rust
#[cfg(debug_assertions)]
let specta_builder = tauri_specta::Builder::<tauri::Wry>::new()
    // ... å‘½ä»¤æ³¨å†Œ ...
    .typ::<extensions::markdown::MarkdownWritePayload>()  // â† æ³¨å†Œç±»å‹
    // ...
```

**åç«¯å¤„ç†å™¨ä½¿ç”¨ç±»å‹åŒ– Payloadï¼š**

```rust
// src/extensions/markdown/markdown_write.rs
use super::MarkdownWritePayload;

#[capability(id = "markdown.write", target = "markdown")]
fn handle_markdown_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    // âœ… ç±»å‹å®‰å…¨çš„ååºåˆ—åŒ–
    let payload: MarkdownWritePayload = serde_json::from_value(cmd.payload.clone())
        .map_err(|e| format!("Invalid payload: {}", e))?;

    // âœ… ç›´æ¥ä½¿ç”¨å­—æ®µï¼ŒTypeScript ç±»å‹æ£€æŸ¥ç¡®ä¿æ­£ç¡®
    let content = payload.content;

    // ... å®ç°é€»è¾‘
}
```

**å‰ç«¯è‡ªåŠ¨è·å¾—ç±»å‹ï¼š**

```typescript
// src/bindings.ts (è‡ªåŠ¨ç”Ÿæˆ)
export type MarkdownWritePayload = {
  content: string  // â† è‡ªåŠ¨ç”Ÿæˆï¼Œä¸ Rust ä¸€è‡´
}
```

**å‰ç«¯ä½¿ç”¨ç±»å‹åŒ– Payloadï¼š**

```typescript
// âš ï¸ æ³¨æ„ï¼šä»¥ä¸‹ç¤ºä¾‹ä»…ç”¨äºè¯´æ˜ç±»å‹ç³»ç»Ÿ
// å®é™…å¼€å‘ä¸­åº”è¯¥åœ¨ Zustand Actions ä¸­ä½¿ç”¨ TauriClient
// ç»„ä»¶ä¸åº”è¯¥ç›´æ¥è°ƒç”¨ TauriClient

import { TauriClient } from '@/lib/tauri-client';
import type { MarkdownWritePayload } from '@/bindings';

// âœ… TypeScript ç±»å‹æ£€æŸ¥ç¡®ä¿ Payload æ­£ç¡®
const payload: MarkdownWritePayload = {
  content: 'Hello World'  // â† ç›´æ¥æ˜¯ string
};

// å¦‚æœå†™é”™äº†ï¼ŒTypeScript ä¼šåœ¨ç¼–è¯‘æ—¶æŠ¥é”™
const wrongPayload: MarkdownWritePayload = {
  content: { type: 'text', data: 'Hello' }  // âŒ ç¼–è¯‘é”™è¯¯
  // Error: Type '{ type: string; data: string; }' is not assignable to type 'string'
};

// âš ï¸ ä»¥ä¸‹ä»£ç åº”è¯¥åœ¨ Zustand Actions ä¸­æ‰§è¡Œï¼Œä¸æ˜¯åœ¨ç»„ä»¶ä¸­
await TauriClient.block.executeCommand(fileId, {
  // ... å…¶ä»–å­—æ®µ ...
  payload: payload as any,
});
```

**âœ… å®é™…å¼€å‘ä¸­çš„æ­£ç¡®åšæ³•ï¼š**

```typescript
// src/lib/app-store.ts
import { TauriClient } from '@/lib/tauri-client';
import type { MarkdownWritePayload } from '@/bindings';

export const useAppStore = create<AppStore>((set) => ({
  writeMarkdown: async (fileId: string, blockId: string, content: string) => {
    // åœ¨ Action ä¸­ä½¿ç”¨ç±»å‹åŒ– Payload
    const payload: MarkdownWritePayload = { content };

    await TauriClient.block.executeCommand(fileId, {
      // ...
      payload: payload as any,
    });

    // æ›´æ–° Store çŠ¶æ€...
  },
}));

// ç»„ä»¶ä¸­è°ƒç”¨ Action
function MyComponent() {
  const writeMarkdown = useAppStore((state) => state.writeMarkdown);
  await writeMarkdown(fileId, blockId, 'Hello World');
}
```

#### å¯¹æ¯”æ€»ç»“

| æ–¹å¼ | åç«¯è§£æ | å‰ç«¯ç±»å‹ | é”™è¯¯æ£€æµ‹æ—¶æœº | ç»´æŠ¤æˆæœ¬ |
|------|---------|---------|-------------|---------|
| **æ‰‹åŠ¨è§£æ** | `payload.get("field")` | æ‰‹åŠ¨å®šä¹‰æ¥å£ | **è¿è¡Œæ—¶**ï¼ˆç”¨æˆ·é‡åˆ°é”™è¯¯ï¼‰ | é«˜ï¼ˆéœ€æ‰‹åŠ¨åŒæ­¥ï¼‰ |
| **ç±»å‹åŒ– Payload** | `serde_json::from_value` | è‡ªåŠ¨ç”Ÿæˆ | **ç¼–è¯‘æ—¶**ï¼ˆTypeScript æ£€æŸ¥ï¼‰ | ä½ï¼ˆè‡ªåŠ¨åŒæ­¥ï¼‰ |

#### Payload å®šä¹‰ä½ç½®è§„åˆ™

- **æ‰©å±•ä¸“ç”¨** Payload â†’ `src/extensions/{extension_name}/mod.rs`
- **æ ¸å¿ƒ** Payload â†’ `src/models/payloads.rs`

è¿™æ ·å¯ä»¥ä¿æŒæ‰©å±•æ¨¡å—åŒ–å’Œè‡ªåŒ…å«ã€‚

### 4. åœ¨ CapabilityRegistry ä¸­æ³¨å†Œ

```rust
// src/capabilities/registry.rs
use crate::extensions::markdown::handle_markdown_write;

impl CapabilityRegistry {
    pub fn register_extensions(&mut self) {
        // Markdown æ‰©å±•
        self.register_capability(handle_markdown_write());

        // å…¶ä»–æ‰©å±•...
    }
}
```

### 5. CBAC æˆæƒç³»ç»Ÿè¯¦è§£

**åŸºäºèƒ½åŠ›çš„è®¿é—®æ§åˆ¶ (Capability-Based Access Control)**

Elfiee ä½¿ç”¨ CBAC æ¨¡å‹ï¼Œè€Œä¸æ˜¯ä¼ ç»Ÿçš„ RBACï¼ˆåŸºäºè§’è‰²ï¼‰æˆ– ACLï¼ˆè®¿é—®æ§åˆ¶åˆ—è¡¨ï¼‰ã€‚

#### æ ¸å¿ƒæ¦‚å¿µ

```rust
pub struct Grant {
    pub editor_id: String,   // è°è¢«æˆæƒ
    pub cap_id: String,      // è¢«æˆæƒçš„èƒ½åŠ›
    pub block_id: String,    // ç›®æ ‡å—ï¼ˆæˆ– "*" è¡¨ç¤ºæ‰€æœ‰å—ï¼‰
}
```

#### æˆæƒè§„åˆ™

**è§„åˆ™ 1ï¼šBlock Owner æ€»æ˜¯è¢«æˆæƒ**

```rust
// åœ¨ Certificator ä¸­
if block.owner == cmd.editor_id {
    return Ok(());  // Owner æ€»æ˜¯æœ‰æƒé™
}
```

**è§„åˆ™ 2ï¼šé Owner éœ€è¦æ˜¾å¼ Grant**

```rust
// æ£€æŸ¥ GrantsTable
let has_grant = grants_table.has_grant(
    &cmd.editor_id,
    &cmd.cap_id,
    &block.block_id,
);

if !has_grant {
    return Err(format!(
        "Permission denied: {} does not have {} on block {}",
        cmd.editor_id, cmd.cap_id, block.block_id
    ));
}
```

**è§„åˆ™ 3ï¼šWildcard Grant ("*") é€‚ç”¨äºæ‰€æœ‰å—**

```rust
// æ£€æŸ¥é€šé…ç¬¦ Grant
let has_wildcard = grants_table.has_grant(
    &cmd.editor_id,
    &cmd.cap_id,
    "*",  // å¯¹æ‰€æœ‰å—æœ‰æ•ˆ
);
```

#### å®Œæ•´çš„æˆæƒæ£€æŸ¥æµç¨‹

```rust
/// Certificator å®ç°ï¼ˆç”± #[capability] å®è‡ªåŠ¨ç”Ÿæˆï¼‰
pub fn check_authorization(
    cmd: &Command,
    block: Option<&Block>,
    grants_table: &GrantsTable,
) -> CapResult<()> {
    let block = block.ok_or("Block not found")?;

    // 1. Owner æ€»æ˜¯è¢«æˆæƒ
    if block.owner == cmd.editor_id {
        return Ok(());
    }

    // 2. æ£€æŸ¥ç‰¹å®š Block çš„ Grant
    if grants_table.has_grant(&cmd.editor_id, &cmd.cap_id, &block.block_id) {
        return Ok(());
    }

    // 3. æ£€æŸ¥ Wildcard Grant
    if grants_table.has_grant(&cmd.editor_id, &cmd.cap_id, "*") {
        return Ok(());
    }

    // 4. æ‹’ç»è®¿é—®
    Err(format!(
        "Permission denied: {} does not have {} on block {}",
        cmd.editor_id, cmd.cap_id, block.block_id
    ))
}
```

#### æˆæƒæµ‹è¯•ç¤ºä¾‹

**æµ‹è¯• 1ï¼šOwner æ€»æ˜¯è¢«æˆæƒ**

```rust
#[tokio::test]
async fn test_authorization_owner() {
    let registry = CapabilityRegistry::new();
    let grants_table = GrantsTable::new();

    let block = Block {
        block_id: "block-1".to_string(),
        name: "Test Block".to_string(),
        block_type: "markdown".to_string(),
        contents: json!({}),
        children: HashMap::new(),
        owner: "alice".to_string(),  // â† Alice æ˜¯ Owner
        metadata: BlockMetadata::default(),
    };

    let cmd = Command {
        cmd_id: "cmd-1".to_string(),
        editor_id: "alice".to_string(),  // â† Alice æ‰§è¡Œå‘½ä»¤
        cap_id: "markdown.write".to_string(),
        block_id: "block-1".to_string(),
        payload: json!({ "content": "Hello" }),
        timestamp: chrono::Utc::now(),
    };

    // âœ… Owner æ€»æ˜¯è¢«æˆæƒ
    let result = registry.execute(&cmd, Some(&block), &grants_table).await;
    assert!(result.is_ok());
}
```

**æµ‹è¯• 2ï¼šé Owner æ— æˆæƒæ—¶è¢«æ‹’ç»**

```rust
#[tokio::test]
async fn test_authorization_denied() {
    let registry = CapabilityRegistry::new();
    let grants_table = GrantsTable::new();  // â† ç©ºçš„ GrantsTable

    let block = Block {
        block_id: "block-1".to_string(),
        name: "Test Block".to_string(),
        block_type: "markdown".to_string(),
        contents: json!({}),
        children: HashMap::new(),
        owner: "alice".to_string(),  // â† Alice æ˜¯ Owner
        metadata: BlockMetadata::default(),
    };

    let cmd = Command {
        cmd_id: "cmd-1".to_string(),
        editor_id: "bob".to_string(),  // â† Bob ä¸æ˜¯ Owner
        cap_id: "markdown.write".to_string(),
        block_id: "block-1".to_string(),
        payload: json!({ "content": "Hello" }),
        timestamp: Utc::now().to_rfc3339(),
    };

    // âŒ Bob æ²¡æœ‰æˆæƒ
    let result = registry.execute(&cmd, Some(&block), &grants_table).await;
    assert!(result.is_err());
    assert!(result.unwrap_err().contains("Permission denied"));
}
```

**æµ‹è¯• 3ï¼šé Owner æœ‰æˆæƒåå¯æ‰§è¡Œ**

```rust
#[tokio::test]
async fn test_authorization_granted() {
    let registry = CapabilityRegistry::new();
    let mut grants_table = GrantsTable::new();

    // âœ… æˆäºˆ Bob æƒé™
    grants_table.add_grant(Grant {
        editor_id: "bob".to_string(),
        cap_id: "markdown.write".to_string(),
        block_id: "block-1".to_string(),  // æˆ– "*" è¡¨ç¤ºæ‰€æœ‰å—
    });

    let block = Block {
        block_id: "block-1".to_string(),
        name: "Test Block".to_string(),
        block_type: "markdown".to_string(),
        contents: json!({}),
        children: HashMap::new(),
        owner: "alice".to_string(),  // â† Alice æ˜¯ Owner
        metadata: BlockMetadata::default(),
    };

    let cmd = Command {
        cmd_id: "cmd-1".to_string(),
        editor_id: "bob".to_string(),  // â† Bob æœ‰æˆæƒ
        cap_id: "markdown.write".to_string(),
        block_id: "block-1".to_string(),
        payload: json!({ "content": "Hello" }),
        timestamp: Utc::now().to_rfc3339(),
    };

    // âœ… Bob æœ‰æˆæƒï¼Œå¯ä»¥æ‰§è¡Œ
    let result = registry.execute(&cmd, Some(&block), &grants_table).await;
    assert!(result.is_ok());
}
```

#### æˆæƒäº‹ä»¶

æˆæƒæœ¬èº«ä¹Ÿé€šè¿‡äº‹ä»¶è®°å½•ï¼š

**Grant äº‹ä»¶ï¼š**
```rust
Event {
    event_id: "event-1",
    entity: "bob",           // è¢«æˆæƒçš„ Editor
    attribute: "alice/core.grant",  // Alice æˆäºˆæƒé™
    value: {
        "cap_id": "markdown.write",
        "block_id": "block-1"
    },
    timestamp: {...},
    created_at: "2025-01-05T12:00:00Z",
}
```

**Revoke äº‹ä»¶ï¼š**
```rust
Event {
    event_id: "event-2",
    entity: "bob",           // è¢«æ’¤é”€çš„ Editor
    attribute: "alice/core.revoke",  // Alice æ’¤é”€æƒé™
    value: {
        "cap_id": "markdown.write",
        "block_id": "block-1"
    },
    timestamp: {...},
    created_at: "2025-01-05T13:00:00Z",
}
```

---

## æ‰©å±•å¼€å‘

### 1. åˆ›å»ºæ–°æ‰©å±•

**æ­¥éª¤ï¼š**

1. **åˆ›å»ºæ‰©å±•ç›®å½•**

```bash
mkdir -p src/extensions/my_extension
```

2. **å®šä¹‰æ¨¡å—** (`src/extensions/my_extension/mod.rs`)

```rust
/// My Extension for Elfiee.
///
/// Description of what this extension does.
///
/// ## Capabilities
///
/// - `my_extension.read`: Read data from blocks
/// - `my_extension.write`: Write data to blocks

// å­æ¨¡å—
pub mod my_capability;

// Payload ç±»å‹
use serde::{Deserialize, Serialize};
use specta::Type;

/// Payload for my_extension.write
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MyWritePayload {
    pub data: String,
}

// å¯¼å‡ºèƒ½åŠ›å¤„ç†å™¨
pub use my_capability::handle_my_write;

#[cfg(test)]
mod tests {
    // æµ‹è¯•ä»£ç 
}
```

3. **å®ç°èƒ½åŠ›å¤„ç†å™¨** (`src/extensions/my_extension/my_capability.rs`)

```rust
use capability_macros::capability;
use crate::capabilities::core::{CapResult, create_event};
use crate::models::{Block, Command, Event};
use super::MyWritePayload;
use serde_json::json;

/// Handler for my_extension.write capability.
#[capability(id = "my_extension.write", target = "my_block_type")]
fn handle_my_write(cmd: &Command, block: &Block) -> CapResult<Vec<Event>> {
    // è§£æ payload
    let payload: MyWritePayload = serde_json::from_value(cmd.payload.clone())
        .map_err(|e| format!("Invalid payload: {}", e))?;

    // éªŒè¯
    if payload.data.is_empty() {
        return Err("Data cannot be empty".into());
    }

    // æ„å»ºæ–°çŠ¶æ€
    let mut new_contents = serde_json::Map::new();
    new_contents.insert("data".to_string(), json!(payload.data));

    // åˆ›å»ºäº‹ä»¶
    let event = create_event(
        block.block_id.clone(),
        format!("{}/{}", cmd.editor_id, cmd.cap_id),
        json!(new_contents),
        &cmd.timestamp,
    )?;

    Ok(vec![event])
}
```

4. **åœ¨ extensions/mod.rs ä¸­å¯¼å‡º**

```rust
// src/extensions/mod.rs
pub mod markdown;
pub mod code;
pub mod directory;
pub mod my_extension; // æ·»åŠ æ–°æ‰©å±•
```

5. **åœ¨ CapabilityRegistry ä¸­æ³¨å†Œ**

```rust
// src/capabilities/registry.rs
use crate::extensions::my_extension::handle_my_write;

impl CapabilityRegistry {
    pub fn register_extensions(&mut self) {
        // å·²æœ‰æ‰©å±•...

        // æ–°æ‰©å±•
        self.register_capability(handle_my_write());
    }
}
```

6. **åœ¨ lib.rs ä¸­æ³¨å†Œç±»å‹**

```rust
#[cfg(debug_assertions)]
let specta_builder = tauri_specta::Builder::<tauri::Wry>::new()
    // ... å‘½ä»¤ ...
    .typ::<extensions::my_extension::MyWritePayload>()
    // ... å…¶ä»–ç±»å‹ ...
```

### 2. æ‰©å±•å¼€å‘æœ€ä½³å®è·µ

**æ¨¡å—åŒ–ï¼š**
- æ¯ä¸ªèƒ½åŠ›ä¸€ä¸ªæ–‡ä»¶
- Payload ç±»å‹å®šä¹‰åœ¨ mod.rs ä¸­
- å¯¼å‡ºæ‰€æœ‰èƒ½åŠ›å¤„ç†å™¨

**æ–‡æ¡£ï¼š**
- è¯¦ç»†çš„æ–‡æ¡£æ³¨é‡Š
- Payload å­—æ®µè¯´æ˜
- ç¤ºä¾‹ç”¨æ³•

**æµ‹è¯•ï¼š**
- å•å…ƒæµ‹è¯•èƒ½åŠ›å¤„ç†å™¨
- é›†æˆæµ‹è¯•å®Œæ•´å‘½ä»¤æµç¨‹
- æµ‹è¯•æˆæƒæ£€æŸ¥

---

## äº‹ä»¶æº¯æº

### 1. äº‹ä»¶ç»“æ„

```rust
pub struct Event {
    pub event_id: String,                        // äº‹ä»¶å”¯ä¸€ ID
    pub entity: String,                          // å®ä½“ ID (block_id æˆ– editor_id)
    pub attribute: String,                       // "{editor_id}/{cap_id}"
    pub value: JsonValue,                        // çŠ¶æ€å˜æ›´æ•°æ®
    pub timestamp: HashMap<String, u64>,         // å‘é‡æ—¶é’Ÿ
    pub created_at: String,                      // åˆ›å»ºæ—¶é—´æˆ³ (ISO 8601)
}
```

### 2. åˆ›å»ºäº‹ä»¶

**ä½¿ç”¨å·¥å…·å‡½æ•°ï¼š**

```rust
use crate::capabilities::core::create_event;
use serde_json::json;

let event = create_event(
    block.block_id.clone(),                          // Entity
    format!("{}/{}", cmd.editor_id, cmd.cap_id),     // Attribute
    json!(new_contents),                             // Value
    &cmd.timestamp,                                  // Timestamp (vector clock)
)?;
```

### 3. äº‹ä»¶å­˜å‚¨

**EventStore** ä½¿ç”¨ SQLite å­˜å‚¨äº‹ä»¶ï¼š

```sql
CREATE TABLE events (
    event_id TEXT PRIMARY KEY,
    entity TEXT NOT NULL,
    attribute TEXT NOT NULL,
    value TEXT NOT NULL,        -- JSON
    timestamp TEXT NOT NULL,    -- JSON (vector clock)
    created_at TEXT NOT NULL    -- ISO 8601
);
```

**æ’å…¥äº‹ä»¶ï¼š**

```rust
event_store.append_events(&events).await?;
```

### 4. çŠ¶æ€æŠ•å½±

**StateProjector** é€šè¿‡é‡æ”¾äº‹ä»¶æ„å»ºçŠ¶æ€ï¼š

```rust
let mut projector = StateProjector::new();

// é‡æ”¾æ‰€æœ‰äº‹ä»¶
for event in events {
    projector.apply_event(&event)?;
}

// è·å–æœ€ç»ˆçŠ¶æ€
let blocks = projector.get_blocks();
let editors = projector.get_editors();
let grants = projector.get_grants();
```

### 5. å‘é‡æ—¶é’Ÿä¸å¹¶å‘æ§åˆ¶

#### ä¸ºä»€ä¹ˆéœ€è¦å‘é‡æ—¶é’Ÿï¼Ÿ

åœ¨å¤šç”¨æˆ·åä½œç¯å¢ƒä¸­ï¼Œäº‹ä»¶å¯èƒ½å¹¶å‘å‘ç”Ÿï¼š
- Alice å’Œ Bob åŒæ—¶ç¼–è¾‘åŒä¸€ä¸ªå—
- éœ€è¦æ£€æµ‹å†²çªå¹¶æ‹’ç»è¿‡æœŸçš„å‘½ä»¤

#### å‘é‡æ—¶é’Ÿç»“æ„

```rust
pub struct Event {
    pub timestamp: HashMap<String, u64>,  // â† å‘é‡æ—¶é’Ÿ
    // editor_id â†’ transaction_count
}
```

**ç¤ºä¾‹ï¼š**
```rust
timestamp: {
    "alice": 5,  // Alice çš„ç¬¬ 5 ä¸ªæ“ä½œ
    "bob": 3,    // Bob çš„ç¬¬ 3 ä¸ªæ“ä½œ
}
```

#### å‘é‡æ—¶é’Ÿæ¯”è¾ƒ

**äº‹ä»¶ A å…ˆäºäº‹ä»¶ Bï¼ˆA â†’ Bï¼‰ï¼š**
```rust
// A çš„æ‰€æœ‰è®¡æ•°å™¨ â‰¤ B çš„è®¡æ•°å™¨ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ª <
A.timestamp = { "alice": 3, "bob": 2 }
B.timestamp = { "alice": 4, "bob": 2 }  // alice çš„è®¡æ•°å™¨å¢åŠ äº†
// A â†’ B (A å…ˆäº B)
```

**å¹¶å‘äº‹ä»¶ï¼ˆA || Bï¼‰ï¼š**
```rust
A.timestamp = { "alice": 3, "bob": 2 }
B.timestamp = { "alice": 2, "bob": 3 }  // æ— æ³•æ¯”è¾ƒ
// A || B (å¹¶å‘)
```

#### å†²çªæ£€æµ‹

**Engine åœ¨æ‰§è¡Œå‘½ä»¤å‰æ£€æŸ¥å‘é‡æ—¶é’Ÿï¼š**

```rust
// ä¼ªä»£ç 
fn execute_command(cmd: Command) -> Result<Vec<Event>, String> {
    // 1. è·å–å½“å‰çŠ¶æ€çš„å‘é‡æ—¶é’Ÿ
    let current_vc = state.get_vector_clock();

    // 2. æ¯”è¾ƒå‘½ä»¤çš„å‘é‡æ—¶é’Ÿ
    if !is_compatible(cmd.timestamp, current_vc) {
        return Err("Conflict detected: stale command".to_string());
    }

    // 3. æ‰§è¡Œå‘½ä»¤
    let events = capability.handler(&cmd, block)?;

    // 4. æ›´æ–°å‘é‡æ—¶é’Ÿ
    for event in &events {
        // å¢åŠ å½“å‰ editor çš„è®¡æ•°å™¨
        event.timestamp.insert(
            cmd.editor_id.clone(),
            current_vc.get(&cmd.editor_id).unwrap_or(&0) + 1,
        );
    }

    Ok(events)
}
```

#### create_event è‡ªåŠ¨å¤„ç†å‘é‡æ—¶é’Ÿ

```rust
pub fn create_event(
    entity: String,
    attribute: String,
    value: JsonValue,
    base_timestamp: &str,  // â† å‘½ä»¤çš„æ—¶é—´æˆ³ï¼ˆç”¨äºå‘é‡æ—¶é’Ÿï¼‰
) -> CapResult<Event> {
    // è§£æåŸºç¡€å‘é‡æ—¶é’Ÿ
    let timestamp = parse_vector_clock(base_timestamp)?;

    Ok(Event {
        event_id: Uuid::new_v4().to_string(),
        entity,
        attribute,
        value,
        timestamp,  // â† ç»§æ‰¿å¹¶é€’å¢
        created_at: Utc::now().to_rfc3339(),
    })
}
```

#### å®é™…ä½¿ç”¨

**èƒ½åŠ›å¤„ç†å™¨ä¸­ï¼š**

```rust
#[capability(id = "markdown.write", target = "markdown")]
fn handle_markdown_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    // ... è§£æ payload ...

    // âœ… create_event è‡ªåŠ¨å¤„ç†å‘é‡æ—¶é’Ÿ
    let event = create_event(
        block.block_id.clone(),
        format!("{}/{}", cmd.editor_id, cmd.cap_id),
        json!(new_contents),
        &cmd.timestamp,  // â† ä¼ å…¥å‘½ä»¤çš„æ—¶é—´æˆ³
    )?;

    Ok(vec![event])
}
```

**å‰ç«¯æ„é€ å‘½ä»¤æ—¶ï¼š**

```typescript
const cmd: Command = {
  cmd_id: crypto.randomUUID(),
  editor_id: editorId,
  cap_id: 'markdown.write',
  block_id: blockId,
  payload: payload as any,
  timestamp: new Date().toISOString(),  // â† ISO 8601 æ ¼å¼
};
```

**ã€é‡è¦ã€‘å‰ç«¯ä¸éœ€è¦æ‰‹åŠ¨ç®¡ç†å‘é‡æ—¶é’Ÿ**ï¼Œåç«¯ Engine ä¼šè‡ªåŠ¨å¤„ç†ã€‚

---

## ç±»å‹å®‰å…¨ä¸è‡ªåŠ¨ç”Ÿæˆ

### 1. ç±»å‹å®šä¹‰è§„èŒƒ

**ã€è§„åˆ™ã€‘æ‰€æœ‰å‰ç«¯å¯è§ç±»å‹å¿…é¡»ï¼š**
1. æ·»åŠ  `#[derive(Serialize, Deserialize)]`
2. æ·»åŠ  `#[derive(Type)]` (æ¥è‡ª specta)
3. å†™æ¸…æ™°çš„æ–‡æ¡£æ³¨é‡Š

**ç¤ºä¾‹ï¼š**

```rust
use serde::{Deserialize, Serialize};
use specta::Type;

/// Represents a block in the Elfiee system.
///
/// Blocks are the fundamental data units, similar to documents or notes.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct Block {
    /// Unique identifier for this block
    pub block_id: String,

    /// Display name of the block
    pub name: String,

    /// Type of the block (e.g., "markdown", "code", "directory")
    pub block_type: String,

    /// Block contents (JSON format, structure depends on block_type)
    pub contents: JsonValue,

    /// Relations to other blocks (relation_type -> [block_ids])
    pub children: HashMap<String, Vec<String>>,

    /// Owner editor ID (has all permissions)
    pub owner: String,

    /// Block metadata
    pub metadata: BlockMetadata,
}
```

### 2. ç±»å‹æ³¨å†Œæ¸…å•

**åœ¨ lib.rs ä¸­æ³¨å†Œæ‰€æœ‰ç±»å‹ï¼š**

```rust
let specta_builder = tauri_specta::Builder::<tauri::Wry>::new()
    .commands(/* ... */)
    // Core æ¨¡å‹
    .typ::<models::Block>()
    .typ::<models::Command>()
    .typ::<models::Event>()
    .typ::<models::Editor>()
    .typ::<models::Grant>()
    // Core Payload ç±»å‹
    .typ::<models::CreateBlockPayload>()
    .typ::<models::LinkBlockPayload>()
    .typ::<models::GrantPayload>()
    // æ‰©å±• Payload ç±»å‹
    .typ::<extensions::markdown::MarkdownWritePayload>()
    .typ::<extensions::code::CodeWritePayload>()
    .typ::<extensions::directory::DirectoryCreatePayload>()
    // å…¶ä»–ç±»å‹
    .typ::<commands::FileMetadata>()
    ;
```

### 3. ç±»å‹ç”Ÿæˆæµç¨‹

```
Rust ç±»å‹å®šä¹‰ (#[derive(Type)])
    â†“
lib.rs æ³¨å†Œ (.typ::<MyType>())
    â†“
pnpm tauri dev è¿è¡Œ
    â†“
tauri-specta æ‰«æç±»å‹
    â†“
ç”Ÿæˆ src/bindings.ts
    â†“
å‰ç«¯å¯¼å…¥ä½¿ç”¨ (import { type MyType } from '@/bindings')
```

---

## æµ‹è¯•è§„èŒƒ

### 1. å•å…ƒæµ‹è¯•

**æµ‹è¯•èƒ½åŠ›å¤„ç†å™¨ï¼š**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{Block, Command};
    use serde_json::json;

    #[test]
    fn test_markdown_write() {
        let block = Block {
            block_id: "block-1".to_string(),
            name: "Test Block".to_string(),
            block_type: "markdown".to_string(),
            contents: json!({}),
            children: HashMap::new(),
            owner: "alice".to_string(),
            metadata: BlockMetadata::default(),
        };

        let cmd = Command {
            cmd_id: "cmd-1".to_string(),
            editor_id: "alice".to_string(),
            cap_id: "markdown.write".to_string(),
            block_id: "block-1".to_string(),
            payload: json!({
                "content": "# Hello World"
            }),
            timestamp: chrono::Utc::now().to_rfc3339(),
        };

        let result = handle_markdown_write(&cmd, &block);
        assert!(result.is_ok());

        let events = result.unwrap();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].entity, "block-1");
    }
}
```

### 2. é›†æˆæµ‹è¯•

**æµ‹è¯•å®Œæ•´å‘½ä»¤æµç¨‹ï¼š**

```rust
#[tokio::test]
async fn test_create_and_write_block() {
    // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
    let temp_dir = tempfile::tempdir().unwrap();
    let file_path = temp_dir.path().join("test.elf");

    // åˆ›å»ºæ–‡ä»¶
    let file_id = create_file(file_path.to_str().unwrap().to_string())
        .await
        .unwrap();

    // æ‰“å¼€æ–‡ä»¶
    let file_id = open_file(file_path.to_str().unwrap().to_string())
        .await
        .unwrap();

    // åˆ›å»ºå—
    let create_cmd = Command {
        cmd_id: Uuid::new_v4().to_string(),
        editor_id: "system".to_string(),
        cap_id: "core.create".to_string(),
        block_id: "*".to_string(),
        payload: json!({
            "name": "Test Block",
            "block_type": "markdown"
        }),
        timestamp: Utc::now().to_rfc3339(),
    };

    let events = execute_command(file_id.clone(), create_cmd)
        .await
        .unwrap();

    let block_id = events[0].entity.clone();

    // å†™å…¥å†…å®¹
    let write_cmd = Command {
        cmd_id: Uuid::new_v4().to_string(),
        editor_id: "system".to_string(),
        cap_id: "markdown.write".to_string(),
        block_id: block_id.clone(),
        payload: json!({
            "content": "# Hello World"
        }),
        timestamp: Utc::now().to_rfc3339(),
    };

    let result = execute_command(file_id.clone(), write_cmd).await;
    assert!(result.is_ok());

    // éªŒè¯çŠ¶æ€
    let block = get_block(file_id, block_id, None).await.unwrap();
    assert_eq!(block.block_type, "markdown");
}
```

### 3. æˆæƒæµ‹è¯•

**æµ‹è¯• CBAC æƒé™æ£€æŸ¥ï¼š**

```rust
#[tokio::test]
async fn test_permission_denied() {
    let file_id = create_test_file().await;

    // åˆ›å»ºå—ï¼ˆowner: aliceï¼‰
    let block_id = create_block_as_editor(file_id.clone(), "alice").await;

    // Bob å°è¯•å†™å…¥ï¼ˆæ²¡æœ‰æˆæƒï¼‰
    let write_cmd = Command {
        cmd_id: Uuid::new_v4().to_string(),
        editor_id: "bob".to_string(),
        cap_id: "markdown.write".to_string(),
        block_id: block_id.clone(),
        payload: json!({
            "content": "Hacked!"
        }),
        timestamp: Utc::now().to_rfc3339(),
    };

    let result = execute_command(file_id, write_cmd).await;
    assert!(result.is_err());
    assert!(result.unwrap_err().contains("Permission denied"));
}
```

---

## å¸¸è§é”™è¯¯ä¸é™·é˜±

### âŒ é”™è¯¯ 1ï¼šå¿˜è®°åœ¨ lib.rs æ³¨å†Œå‘½ä»¤æˆ–ç±»å‹
**åæœï¼š** å‰ç«¯æŠ¥é”™ "Command not found" æˆ–ç±»å‹ç¼ºå¤±
**è§£å†³ï¼š** åœ¨ lib.rs çš„ **debug å’Œ release** æ¨¡å¼éƒ½è¦æ³¨å†Œ

### âŒ é”™è¯¯ 2ï¼šRead/Write èƒ½åŠ›çš„ Entity é”™è¯¯
```rust
// âŒ é”™è¯¯ï¼šRead èƒ½åŠ›ä½¿ç”¨äº† block_id
let event = create_event(
    block.block_id.clone(),  // âŒ Read åº”è¯¥ç”¨ editor_id
    // ...
);

// âœ… æ­£ç¡®ï¼šæ ¹æ®èƒ½åŠ›ç±»å‹é€‰æ‹© Entity
// Write: entity = block.block_id (è¢«ä¿®æ”¹çš„å—)
// Read: entity = cmd.editor_id (è¯»å–è€…)
```

### âŒ é”™è¯¯ 3ï¼šæ‰‹åŠ¨è§£æ Payload è€Œä¸ç”¨ç±»å‹
```rust
// âŒ é”™è¯¯ï¼šæ‰‹åŠ¨è§£æå®¹æ˜“å‡ºé”™
let content = cmd.payload.get("content")
    .and_then(|v| v.as_str())
    .ok_or("Missing 'content'")?;

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ç±»å‹åŒ– Payload
let payload: MarkdownWritePayload = serde_json::from_value(cmd.payload.clone())?;
let content = payload.content;
```

### âŒ é”™è¯¯ 4ï¼šç›´æ¥ä¿®æ”¹çŠ¶æ€è€Œä¸ç”¨ Event
```rust
// âŒ é”™è¯¯ï¼šè¿åäº‹ä»¶æº¯æºåŸåˆ™
block.contents = json!({ "new": "data" });

// âœ… æ­£ç¡®ï¼šé€šè¿‡ Event è®°å½•å˜æ›´
let event = create_event(
    block.block_id.clone(),
    format!("{}/{}", cmd.editor_id, cmd.cap_id),
    json!(new_contents),
    &cmd.timestamp,
)?;
```

### âŒ é”™è¯¯ 5ï¼šå¿˜è®°æµ‹è¯•æˆæƒ
**åæœï¼š** æƒé™æ¼æ´ï¼Œä»»ä½•äººéƒ½èƒ½ä¿®æ”¹
**è§£å†³ï¼š** æ·»åŠ ä¸‰ä¸ªæµ‹è¯•ï¼šOwner æˆæƒã€é Owner æ‹’ç»ã€é Owner æœ‰ Grant

---

## æ€»ç»“

### åç«¯å¼€å‘è€…å¿…é¡»éµå®ˆçš„è§„åˆ™

1. **ã€ä¸¥æ ¼ã€‘** æ‰€æœ‰å‰ç«¯å¯è°ƒç”¨åŠŸèƒ½å¿…é¡»å®šä¹‰ä¸º Tauri Command
2. **ã€ä¸¥æ ¼ã€‘** ä½¿ç”¨ `#[specta]` å®ç”Ÿæˆç±»å‹ç»‘å®š
3. **ã€ä¸¥æ ¼ã€‘** åœ¨ lib.rs ä¸­æ³¨å†Œæ‰€æœ‰å‘½ä»¤å’Œç±»å‹
4. **ã€ä¸¥æ ¼ã€‘** éµå¾ªäº‹ä»¶æº¯æºæ¶æ„ï¼Œé€šè¿‡ Event è®°å½•çŠ¶æ€å˜æ›´
5. **ã€æ¨èã€‘** ä½¿ç”¨ `#[capability]` å®å®šä¹‰èƒ½åŠ›
6. **ã€æ¨èã€‘** ä¸ºæ¯ä¸ªèƒ½åŠ›å®šä¹‰ Payload ç±»å‹
7. **ã€æ¨èã€‘** åœ¨èƒ½åŠ›å¤„ç†å™¨ä¸­ä½¿ç”¨ `serde_json::from_value` è§£æ Payload
8. **ã€æ¨èã€‘** ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
9. **ã€æ¨èã€‘** æµ‹è¯•æˆæƒæ£€æŸ¥å’Œé”™è¯¯å¤„ç†

### æ ¸å¿ƒå¼€å‘æµç¨‹

```
1. å®šä¹‰æ•°æ®æ¨¡å‹ï¼ˆæ·»åŠ  #[derive(Type)]ï¼‰
2. å®šä¹‰ Payload ç±»å‹ï¼ˆæ·»åŠ  #[derive(Type)]ï¼‰
3. å®ç°èƒ½åŠ›å¤„ç†å™¨ï¼ˆä½¿ç”¨ #[capability] å®ï¼‰
4. åœ¨ CapabilityRegistry ä¸­æ³¨å†Œèƒ½åŠ›
5. å®šä¹‰ Tauri Commandï¼ˆæ·»åŠ  #[tauri::command] + #[specta]ï¼‰
6. åœ¨ lib.rs ä¸­æ³¨å†Œå‘½ä»¤å’Œç±»å‹ï¼ˆdebug + releaseï¼‰
7. è¿è¡Œ pnpm tauri dev ç”Ÿæˆç±»å‹ç»‘å®š
8. å‰ç«¯ä½¿ç”¨ç”Ÿæˆçš„ç±»å‹å’Œå‘½ä»¤
```

### æ·»åŠ æ–°åŠŸèƒ½æ—¶

å½“éœ€è¦æ·»åŠ æ–°åŠŸèƒ½æ—¶ï¼š
1. ç¡®å®šæ˜¯å¦éœ€è¦æ–°çš„ Tauri Command
2. ç¡®å®šæ˜¯å¦éœ€è¦æ–°çš„ Capability
3. å®šä¹‰ Payload ç±»å‹ï¼ˆå¦‚æœéœ€è¦ï¼‰
4. å®ç°èƒ½åŠ›å¤„ç†å™¨
5. æ³¨å†Œå‘½ä»¤å’Œç±»å‹
6. ç¼–å†™æµ‹è¯•
7. æ›´æ–°æ–‡æ¡£

---

**ç›¸å…³æ–‡æ¡£ï¼š**
- [å‰ç«¯å¼€å‘è§„èŒƒ](./å‰ç«¯å¼€å‘è§„èŒƒ.md) - å‰ç«¯å¼€å‘è¯¦ç»†æŒ‡å—
- [å¼€å‘æµç¨‹](./å¼€å‘æµç¨‹.md) - å®Œæ•´å¼€å‘æµç¨‹å’Œåä½œè§„èŒƒ
- [CLAUDE.md](../../CLAUDE.md) - é¡¹ç›®æ€»è§ˆå’Œ AI è¾…åŠ©å¼€å‘
- [EXTENSION_DEVELOPMENT.md](../../guides/EXTENSION_DEVELOPMENT.md) - æ‰©å±•å¼€å‘è¯¦ç»†æŒ‡å—
