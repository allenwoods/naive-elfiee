
- **目标**：识别并拆解：在真实 PM × Design × Dev 协作流程中，哪些产品或使用方式，通过“非传统文档 / 项目管理手段”，实现了“决策过程的（部分）可学习性”。
- **研究问题**：
	- 决策载体是什么？（规则、diff、评价、假设、状态变更）
	- 决策何时被记录？（事前 / 事中 / 事后）
	- 决策是否与结果建立连接？
	- 这个判断后来能被证实、证伪吗？
	- 是否对下一次决策产生影响？（回滚？复用？改变 AI / 人的默认行为？）
- **两个场景**：
	- 1. 原型驱动开发
	- 2. 文档驱动开发
- **预期产出**
	- MVP的切入点
	- 哪些北极星能力必须被拆小、延后

#### insight 1: “可学习决策”的3种范式

- 来源：分析cursor rules，CodeStream，Stepsize，windsurf Cascade，Linear Project Updates & Spec History， Jira Product Discovery，LangSmith，Evals，并初步分类。
- 长期记忆/行为准则类（cursor rules, claude skills）
	- 执行效率高
	- 缺少校准反馈，假定用户写下的规则永远是对的
- 连接意图与执行类（stepwise，codestream，linear，jira product discovery）
	- 交互形态（选区、打标），可参考
	- 数据去向目前主要是给人看，可以升级到给AI看
	- 记录了大颗粒度决策（做/不做），丢失reasoning
- 给输出结果打分类（LangSmith / Evals，TDD）
	- 用户体验太工程师
	- 待研究：事前or事后，在Prototype- driven 和 document-driven 两种场景各有什么得与失？

#### insight 2: 原型驱动开发中，重要决策易流失的场景

- 来源：回溯我自己使用lovable做原型、给dev开发的 customer journey 中，哪些决策流失了。
- 重要决策易流失的场景
	- 被否定的方案、改稿过程
	- 被隐式采纳的设计假设
	- 带有隐性意图的设计被写死
- 干脆没有留下决策的常见场景：失败状态、空状态
- 原型驱动开发中，如果我们想要更好的获得“可学习决策”，需要工具能区分：
	- 样式原因 vs. 规则/原则原因 vs. 意图原因
	- 例如：Lovable 只记录了最终结果是红色，AI 无法反推出“警告必须为红色”这个规则，下次生成警告弹窗时可能又是蓝色。


#### 实验一：用户为了做出可学习的决策，愿意付出多大的交互成本？

- 实验假设：当“否定行为”发生时，PM 愿意为这次否定留下一个“最小可复用的理由”，其前提是不打断当前工作流。
- 触发场景：仅当用户在 MVP 编辑器中，主动删除一段 AI 生成 的代码 Block 时。
- 参考竞品： Stepsize (在 IDE 里的轻量级弹窗)
- 场景： 当 用户 在 MVP 编辑器里删除一段 AI 生成的代码 Block 时。
- 设计： 
	- A 即时标记：用户发出指令后，根据用户指令的内容弹出“Why remove/add ……”气泡，给用户可选项。
	- B 即时标记：用户发出指令后、lovable 进行调整等待时间内，根据用户指令的内容弹出“Why remove/add ……”气泡，给用户可选项。
	- C 延迟反馈：被用户主动放弃的方案，被存放起来，并在特定时机邀请用户来这里选择放弃的原因/没有满足的意图。
- 待设计对照组 