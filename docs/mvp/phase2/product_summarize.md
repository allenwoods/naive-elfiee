# 1. 一阶段工作回顾

## 1.1. 总体目标
聚焦"统一工作面"和"决策资产化"，开发和验证 Elfiee 作为多角色协作平台的基础能力。

## 1.2. 产品工作：
* 原型搭建
* 竞品分析
* 用户故事快速实验

## 1.3. 研发工作
* Dashboard、Directory、编辑界面、协作者/权限、Event记录和回溯等功能开发
* 完成一个在“单人单机”场景下，支持“多角色协同文件管理和编辑”和“记录/回溯操作历史”的Demo。

# 2. 产品关注的核心命题

## 2.1. 痛点分析

* 需求分散记录：需求以PRD、聊天记录等形式存在，无法区分硬性约束、背景信息、验收标准等内容，也无法形成逻辑链条。这类分散的记录方式在提高循环迭代，特别是AI参与的敏捷任务中，显得笨重和低效。

* 记录无法复用：需求、实现、验证没有被沉淀为可复用的资产，无法服务于效率高可验证性差的AI协同和开发。

## 核心命题：

“让决策可学习”：

为了解决上述痛点，我们将核心命题拆解为两个递进的价值维度：


| 维度 | 目标 | 对抗的问题 | 关键角色 |
| :--- | :--- | :--- | :--- |
| **Record (记录)** | **把决策记录下来** | 决策失忆 | **AI (作为秘书)**：降低记录门槛，对抗人类惰性 |
| **Learn (学习)** | **让记录的内容可学习** | 知识无法资产化 | **AI (作为执行者)**：消费记录资产，转化为生产力 |


**Elfiee定位**：AI原生编辑器 -- 把意图、实现、验证、逻辑链条串在一起的中间媒介，记录全链条决策，并沉淀为可复用资产，反哺AI时代的敏捷开发和验证。

# 3. 一阶段的产品工作

| 工作模块 | 具体内容 | 产出物 |
| :--- | :--- | :--- |
| **竞品分析** | 三种代表性流程（大厂、Google、Vibe Coding）的共性问题分析 | `竞品分析 insight 1.md`, `insight 2-3.md` |
| **实验设计** | 两个核心实验：① 记录行为的 Effort vs Value ② 不同记录形式的 Benefit 对比 | `实验设计.md` |
| **实验执行与报告** | 定量（Coverage/Accuracy）+ 定性（Difficulty/Confidence/Helpfulness）结果 | `实验报告.md` |
| **产品方向收束** | 从「让决策可学习」出发，收束产品方向 | `Phase_1_Summary_让决策可学习.md` |

# 4. 一阶段的产品工作结论

## 4.1. 核心发现

1. 单纯的 Log 是无效的：信息密度太低，增加阅读负担
2. 结构化 Tag 不够：用户需要脑补，反而降低信心
3. Summary 是方向：主观体验最好，但在复杂决策中会产生「主观信心 ≠ 客观正确」的幻觉
4. 必须配合 Traceability：Summary 不能是黑盒，必须能回溯证据链

## 4.2. 关键结论

* ❌ **不成立的假设**："只要把决策记录下来效率就会提升"
* ✅ **成立的假设**：“在提高效率的前提下，用户接受将决策记录下来的动作。”
	* ❌ 但用户不愿意进行提炼和总结，而是更倾向于由 AI 协助自己完成提炼和总结，然后自己审查并决定是否接受（Reviewer 模式）；
	* 同时，用户有按照自己需要进行‘随手记’（Memo）需求，用于捕捉个人灵感或备忘，这个随手记的内容不一定是给下游同事（无论人还是AI）的提炼和总结，而更可能是给自己的备忘。
* 推论：决策资产化对AI和对人的价值，需要以不同的方式来体现。
    * **对于 AI**，我们还未验证的假设：重点是结构化、全量的上下文（Prompt Context），用于精准执行。
    * **对于 人**，我们已验证的结论：重点是高信噪比的摘要和可视化的逻辑链（Summary/Graph），用于激发创造性思考和快速回忆，服务于人类的思考方式和灵感创造。

# 5. 一阶段的工作Gap

反观一阶段，我们发现产品目前的 Gap 是结构性的。核心问题在于我们搭建了“舞台”（编辑器），但缺少了“主角”（AI）和“验证手段”（Terminal），导致闭环尚未打通。

我们按**优先级**和**依赖关系**将 Gap 梳理如下：

| 维度 | Gap (核心缺失) | 优先级 | 依赖关系 | 描述 | 后果 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Learn (学习)** | **AI 未接入** | **P0 (核心)** | 依赖结构化数据 | 系统目前只有“人类角色”，没有任何 AI Agent 接入来消费数据。 | 积累的数据堆积在库里，没有任何自动化产出，无法验证“决策资产化”能否转化为生产力。 |
| **Learn (学习)** | **验证闭环缺失** | **P0 (核心)** | 依赖 Terminal | 无法连接外部工具链（Terminal），无法运行代码或测试。 | 无法证明 AI（或人）生成的决策是正确的，“验证鸿沟”依然存在。 |
| **Record (记录)** | **因果链条断裂 (Relation)** | **P1 (基石)** | 被 AI/可视化依赖 | 只有线性的 Event Log，缺乏 Event 之间的因果引用关系（DAG）。 | 上下文是破碎的。无论是 AI 还是人，都难以从散乱的 Log 中还原出完整的决策逻辑链。 |
| **Record (记录)** | **输入摩擦力大** | **P2 (体验)** | - | 记录过程仍需大量手动操作，缺乏辅助手段。 | 用户记录意愿低，导致数据源头可能枯竭（这是 Reviewer 模式要解决的问题，但优先级次于架构闭环）。 |



# 6. 一阶段Gap归因分析

1. 请从产品优先级排序的角度解释：为什么一阶段没有做这些？
  * **基础设施依赖**：AI Agent 的接入依赖于稳定的 Block 数据结构；Terminal 的集成依赖于稳定的 Editor 框架。一阶段的核心任务是夯实这些地基（Event Sourcing / Editor Canvas）。
2. 这些没做是主动取舍（资源有限、验证优先级不高），还是被动遗留（没想到、低估了重要性）？
  * 主动取舍：资源有限，需要按依赖关系逐步推进。
3. 这些是不是二阶段的工作方向和目标？
  * 二阶段必须优先解决 **“AI 接入”**（让数据有用）和 **“Terminal 集成”**（让结果可信），并辅以 **“Relation 构建”**（让逻辑连通）。
  * 至于输入体验（如 Reviewer 模式、Memo），是降低门槛的优化项，需在保证核心链路跑通的前提下推进。

# 7. 二阶段工作方向

## 7.1. 一阶段实验的启示：

从实验结论说明，提供更多信息给人效果不显著（F2/F3/F4 的定量指标均未优于F1），而让 AI参与消费决策尚未验证，但这是让决策可学习的核心路径。二阶段的核心策略是**引入 AI 和 验证闭环**，让记录真正变成资产。

## 7.2. 二阶段聚焦点：

### 2.1   方向 A：“把决策记录下来” (Record)
*目标：填补 P1 (因果链) 和 P2 (输入体验) Gap，降低记录门槛，建立数据关联。*

| 模块 | 解决痛点 | 方案描述 |
| :--------------------------- | :---------------- | :------------------------------------------- |
| **Relation (因果索引)**          | **P1 (核心)**：上下文破碎 | 建立 Block 与 Event 之间的引用关系，为 AI 推理和人类回溯提供逻辑路径。 |
| **AI Summary (Reviewer 模式)** | **P2**：从0开始记录的摩擦力     | 变“填空题”为“判断题”。AI 监听变更自动生成 Summary，用户仅需确认。     |
| **随手记 (Memo)**               | **P3**：人类的灵感存放    | 提供非结构化的轻量级入口，捕捉个人灵感和备忘，作为正式决策的补充。            |

### 2.2   方向 B：“让记录的内容可学习” (Learn)
*目标：填补 P0 (AI 接入) 和 P0 (验证闭环) Gap，验证资产化数据的生产力价值。*

| 模块 | 解决痛点 | 方案描述 |
| :--- | :--- | :--- |
| **Agent 协作 (AI Access)** | **P0 (核心)**：AI 未接入 | 引入 Coding Agent，消费 Block 上下文、Relation 和 Memo，并生成可执行的代码提案 (Proposal)。 |
| **Terminal (验证闭环)** | **P0 (核心)**：验证缺失 | 连接外部工具链，在 Elfiee 内直接运行测试，验证 Agent 生成的代码是否有效（Traceability 终点）。 |



## 7.3. 二阶段不做什么

| 不做 | 原因 |
| :--- | :--- |
| ❌ **更细的 Log 系统** | 实验证明：信息密度太低，对人无效 |
| ❌ **复杂的 DAG 可视化** | 数据结构先行，可视化推迟到三阶段 |
| ❌ **决策形式的深度优化 (Rule / Flow)** | 等 AI 接入后，再验证 AI 消费决策的效果 |
| ❌ **CBAC 权限的细化** | 已具备基础能力，暂不深入 |

# 8. 二阶段场景：Dogfooding
1. Dogfooding：用 Elfiee 开发 Elfiee，让团队自己成为第一批用户。

2. Dogfooding要验证什么：

| 验证方向 | 验证目标 | 具体指标 | 判断标准 |
| :--- | :--- | :--- | :--- |
|**Learn**| **AI 能作为协作者** | Agent 能读取需求、生成代码、建立 Relation | 完成一个完整的「需求→代码→测试」流程 |
|**Learn**| **验证闭环成立** | 在 Terminal 中运行测试并通过 | 不需要离开 Elfiee 去外部终端 |
|**Learn**| **决策可追溯** | Agent 生成的代码能追溯到需求 Block | 通过 Relation 可视化查看原始决策所需的时间 < 30秒 |
| **Record** | **输入体验和价值可接受** | **记录功能活跃度**       | 平均每个 Feature 开发过程中，在block内容之外产生 > 3 条记录|
| **Record** | **输入体验可接受** | **Summary 采纳率**    | **> 80%** 的 Summary 仅需点击确认或微调（证明 AI 真的降低了记录负担）。        |

3.  Dogfooding的成功标准
* 完成一个真实功能开发
* 完成完整记录
* 记录喂给AI有帮助等等数值标准
#### (1) 交付物标准 (Base)
* ✅ **真实功能落地**：完成1 个具备完整业务逻辑的功能的开发。
* ✅ **资产完整性**：该功能对应的 Block 包含完整的 Requirement、Implementation Code 以及关联的 Event Log，**Relation 覆盖率达到 100%**（code 和 log，100%关联到需求）。

#### (2) 价值验证标准 (Metrics)

| 维度 | 指标名称 | 成功基准 | 验证意图 |
| :--- | :--- | :--- | :--- |
| **Learn (AI)** | **Proposal 首次通过率 (FPY)** | > 60% | Agent 读取 Context 后生成的代码/指令，首次执行即可成功（无 Syntax Error 且符合意图）的比例|
| **Learn (闭环)** | **逻辑回溯时间** | < 30 秒 | 面对一个已实现的代码 Block，通过 Relation Graph 找到其原始需求 Block 所需的时间 |
| **Learn (闭环)** | **Terminal 修复闭环率** | > 90% | 当测试报错时，能不离开 Elfiee，直接通过 @Agent 或 Terminal 修复并验证通过的比例 |
| **Record (人)** | **Summary 采纳率** | > 80% | AI 自动生成的决策总结，用户仅需“一键确认”或修改字数少于 20% |
| **Record (人)** | **Memo 使用频次** | > 3 条/功能 | 在开发过程中，在block之外，自发创建不少于 3 条记录|

# 9. 二阶段产品核心产物
1. 产研分工

| 职责 | 产品 | 研发 |
| :--- | :---: | :---: |
| **定义 What** | ✅ 主导 | 评审 |
| **定义 How it works（数据结构、API）** | 评审 | ✅ 主导 |
| **定义 How it looks（UI/UX）** | 规范输出 | 最小实现 → 迭代优化 |
| **Dogfooding 跟踪** | ✅ 主导 | 配合 |*
| **问题收集与优先级排序** | ✅ 主导 | 执行 |

2. 产品二阶段产出物
**(需要确认和补充)**
| 产出物 | 描述 | 
| :--- | :--- | 
| **本报告（一阶段总结）** | 收束一阶段，指导二阶段方向 | 
| **Agent 交互规范** | 定义 Proposal 结构、Agent 触发方式、输入输出 Schema |
| **Terminal 交互规范** | 定义导出检查的触发条件、用户选项 | 
| **Dogfooding 问题清单** | 持续记录 Dogfooding 过程中的问题和改进建议 | 
| **迭代方案（可选）** | 基于 Dogfooding 反馈的改进设计 | 

# 10 交互规范格式建议：
··· yaml
# Agent 交互规范 v1

## 1. 触发方式
- 用户在任意 Block 中 @AgentName
- 用户点击 Agent Block 的「Invoke」按钮

## 2. Agent 输入
- 当前 Block 的内容
- Agent 关联的 children Blocks（Directory、Terminal）的元信息

## 3. Agent 输出（Proposal 结构）
{
  "proposal_id": "uuid",
  "proposed_commands": [
    {
      "action": "block.create",
      "params": { "type": "code", "path": "src/pdf.rs" }
    },
    {
      "action": "code.write",
      "params": { "block_id": "xxx", "content": "..." }
    }
  ],
  "reasoning": "根据需求 Block 的描述，我建议创建..."
}

## 4. 审批流程
- 用户看到 Proposal 卡片（包含 Diff 预览）
- 用户点击 Approve → 系统依次执行 commands
- 用户点击 Reject → Proposal 标记为 Rejected，不执行
```