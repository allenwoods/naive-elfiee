//! Tests for {{ extension_name_pascal }} extension
//!
//! Generated by elfiee-ext-gen - Implement the TODO markers.
//!
//! Test categories included:
//! - Payload deserialization tests
//! - Basic capability functionality tests
{% if with_auth_tests %}//! - Authorization/CBAC tests
{% endif %}{% if with_workflow_tests %}//! - Integration workflow tests
{% endif %}

use super::*;
use crate::capabilities::registry::CapabilityRegistry;
{% if with_auth_tests %}use crate::capabilities::grants::GrantsTable;
{% endif %}
use crate::models::{Block, Command};

{% for capability in capabilities %}
// ============================================
// {{ capability.struct_name }} - Payload Tests
// ============================================

#[test]
fn test_{{ capability.id_snake }}_payload_deserialize() {
    // TODO: After defining Payload fields in mod.rs, fill in example JSON
    let json = serde_json::json!({
        // TODO: Add fields matching {{ capability.struct_name }}Payload
        // Example: "field_name": "value"
    });

    let result: Result<{{ capability.struct_name }}Payload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    // TODO: Add assertions to verify field values
    // let payload = result.unwrap();
    // assert_eq!(payload.field_name, "expected_value");
}

// ============================================
// {{ capability.struct_name }} - Functionality Tests
// ============================================

#[test]
fn test_{{ capability.id_snake }}_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("{{ extension_name }}.{{ capability.id }}")
        .expect("{{ extension_name }}.{{ capability.id }} should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "{{ block_type }}".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "{{ extension_name }}.{{ capability.id }}".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            // TODO: Fill in payload fields
        }),
    );

    // TODO: After implementing handler, this should pass
    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Handler should execute successfully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/{{ extension_name }}.{{ capability.id }}");

    // TODO: Add assertions to verify event contents
    // let contents = events[0].value.get("contents").unwrap();
    // assert_eq!(contents.get("field"), expected_value);
}

{% if with_auth_tests %}
// ============================================
// {{ capability.struct_name }} - Authorization Tests
// ============================================

#[test]
fn test_{{ capability.id_snake }}_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "{{ block_type }}".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "{{ extension_name }}.{{ capability.id }}", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_{{ capability.id_snake }}_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "{{ block_type }}".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "{{ extension_name }}.{{ capability.id }}", &block.block_id);

    assert!(!is_authorized, "Non-owner without grant should not be authorized");
}

#[test]
fn test_{{ capability.id_snake }}_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "{{ block_type }}".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "{{ extension_name }}.{{ capability.id }}".to_string(),
        block.block_id.clone(),
    );

    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "{{ extension_name }}.{{ capability.id }}", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}
{% endif %}

{% endfor %}
{% if with_workflow_tests %}
// ============================================
// Integration Workflow Test
// ============================================

#[test]
fn test_full_workflow() {
    // TODO: Implement a complete workflow test that exercises multiple capabilities
    // This test should demonstrate a realistic usage scenario

    let registry = CapabilityRegistry::new();
    let mut block = Block::new(
        "Workflow Test Block".to_string(),
        "{{ block_type }}".to_string(),
        "alice".to_string(),
    );

    // TODO: Step 1 - Use first capability
    // Example: create/add an item

    // TODO: Step 2 - Update block state (simulate StateProjector)
    // block.contents = events[0].value.get("contents").unwrap().clone();

    // TODO: Step 3 - Use second capability on updated state
    // Example: toggle/modify the item

    // TODO: Step 4 - Verify final state
    // assert_eq!(final_state, expected_state);

    todo!("Implement complete workflow test with multiple capability interactions");
}
{% endif %}
