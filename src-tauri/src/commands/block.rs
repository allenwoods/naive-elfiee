use crate::config;
use crate::models::{Block, Command, Event};
use crate::state::AppState;
use specta::specta;
use tauri::State;

/// Execute a command on a block in the specified file.
///
/// This is the primary way to modify blocks. Commands are processed by the engine actor,
/// which handles authorization, execution, and persistence.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file containing the block
/// * `cmd` - Command to execute (create, delete, link, write, etc.)
///
/// # Returns
/// * `Ok(events)` - Events generated by the command execution
/// * `Err(message)` - Error description if execution fails
#[tauri::command]
#[specta]
pub async fn execute_command(
    file_id: String,
    cmd: Command,
    state: State<'_, AppState>,
) -> Result<Vec<Event>, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Process command through engine actor
    handle.process_command(cmd).await
}

/// Get a specific block by ID from a file.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file containing the block
/// * `block_id` - Unique identifier of the block to retrieve
///
/// # Returns
/// * `Ok(block)` - The requested block
/// * `Err(message)` - Error if file not open or block not found
#[tauri::command]
#[specta]
pub async fn get_block(
    file_id: String,
    block_id: String,
    state: State<'_, AppState>,
) -> Result<Block, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get block from engine
    handle
        .get_block(block_id)
        .await
        .ok_or_else(|| "Block not found".to_string())
}

/// Get all blocks from a file.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file
///
/// # Returns
/// * `Ok(blocks)` - Vector of all blocks in the file
/// * `Err(message)` - Error if file is not open
#[tauri::command]
#[specta]
pub async fn get_all_blocks(
    file_id: String,
    state: State<'_, AppState>,
) -> Result<Vec<Block>, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get all blocks from engine
    let blocks_map = handle.get_all_blocks().await;

    // Convert HashMap to Vec
    let blocks: Vec<Block> = blocks_map.into_values().collect();

    Ok(blocks)
}

/// Update block metadata.
///
/// This generates a Command with core.update_metadata capability and processes it through
/// the engine actor. The metadata is merged with existing metadata and updated via event replay.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file containing the block
/// * `block_id` - Unique identifier of the block to update
/// * `metadata` - Metadata fields to update (will be merged with existing metadata)
///
/// # Returns
/// * `Ok(())` - Metadata updated successfully
/// * `Err(message)` - Error description if update fails
#[tauri::command]
#[specta]
pub async fn update_block_metadata(
    file_id: String,
    block_id: String,
    metadata: serde_json::Value,
    state: State<'_, AppState>,
) -> Result<(), String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get current active editor (or fallback to system editor)
    // Block metadata updates should be attributed to an editor identity.
    // If no active editor is set, use the system editor as fallback.
    let editor_id = state
        .get_active_editor(&file_id)
        .unwrap_or_else(|| config::get_system_editor_id().unwrap_or_else(|_| "system".to_string()));

    // Create command to update metadata
    let cmd = Command::new(
        editor_id,
        "core.update_metadata".to_string(),
        block_id,
        serde_json::json!({ "metadata": metadata }),
    );

    // Process command through engine
    handle.process_command(cmd).await?;

    Ok(())
}
