use crate::models::{Block, Command, Event};
use crate::state::AppState;
use specta::specta;
use tauri::{AppHandle, Emitter, State};

/// Execute a command on a block in the specified file.
///
/// This is the primary way to modify blocks. Commands are processed by the engine actor,
/// which handles authorization, execution, and persistence.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file containing the block
/// * `cmd` - Command to execute (create, delete, link, write, etc.)
///
/// # Returns
/// * `Ok(events)` - Events generated by the command execution
/// * `Err(message)` - Error description if execution fails
#[tauri::command]
#[specta]
pub async fn execute_command(
    file_id: String,
    cmd: Command,
    app: AppHandle,
    state: State<'_, AppState>,
) -> Result<Vec<Event>, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Process command through engine actor
    let events = handle.process_command(cmd.clone()).await?;

    // 检查是否是 terminal.execute 命令，并且需要文件同步
    if cmd.cap_id == "terminal.execute" && !events.is_empty() {
        // 检查返回的事件中是否包含需要文件同步的标记
        for event in &events {
            if let Some(contents) = event.value.get("contents") {
                if let Some(obj) = contents.as_object() {
                    if obj.get("needs_file_sync").and_then(|v| v.as_bool()).unwrap_or(false) {
                        // 需要进行文件同步，获取 archive 并触发同步
                        if let Some(file_info) = state.files.get(&file_id) {
                            let archive = file_info.archive.clone();
                            let elf_path = file_info.path.clone();
                            let command = obj.get("file_operation_command")
                                .and_then(|v| v.as_str())
                                .unwrap_or("unknown")
                                .to_string();
                            
                            // 获取该 file_id 对应的互斥锁，确保同一文件的保存操作串行执行
                            // 防止多个文件操作快速连续执行时触发并发的 archive.save() 调用
                            let save_mutex = state.get_file_save_mutex(&file_id);
                            
                            // 克隆 AppHandle 和 file_id 用于异步任务中发送事件
                            let app_handle = app.clone();
                            let file_id_clone = file_id.clone();
                            
                            // 异步触发文件同步，不阻塞命令返回
                            // 使用互斥锁确保同一 file_id 的保存操作串行执行
                            tokio::spawn(async move {
                                // 获取锁，确保同一文件的保存操作不会并发执行
                                let _guard = save_mutex.lock().await;
                                
                                match archive.save(&elf_path) {
                                    Ok(_) => {
                                        println!("File sync completed successfully for command: {}", command);
                                        // 可选：发送成功通知（如果需要）
                                        // app_handle.emit("file-sync-success", &command).ok();
                                    }
                                    Err(e) => {
                                        let error_msg = format!("文件同步失败: {}", e);
                                        eprintln!("File sync failed: {}", e);
                                        
                                        // 发送错误事件到前端，前端可以显示通知
                                        if let Err(emit_err) = app_handle.emit("file-sync-error", serde_json::json!({
                                            "command": command,
                                            "error": error_msg,
                                            "file_id": file_id_clone
                                        })) {
                                            eprintln!("Failed to emit file-sync-error event: {}", emit_err);
                                        }
                                    }
                                }
                                // _guard 在这里自动释放，允许下一个保存操作继续
                            });
                        }
                        break;
                    }
                }
            }
        }
    }

    Ok(events)
}

/// Get a specific block by ID from a file.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file containing the block
/// * `block_id` - Unique identifier of the block to retrieve
///
/// # Returns
/// * `Ok(block)` - The requested block
/// * `Err(message)` - Error if file not open or block not found
#[tauri::command]
#[specta]
pub async fn get_block(
    file_id: String,
    block_id: String,
    state: State<'_, AppState>,
) -> Result<Block, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get block from engine
    handle
        .get_block(block_id)
        .await
        .ok_or_else(|| "Block not found".to_string())
}

/// Get all blocks from a file.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file
///
/// # Returns
/// * `Ok(blocks)` - Vector of all blocks in the file
/// * `Err(message)` - Error if file is not open
#[tauri::command]
#[specta]
pub async fn get_all_blocks(
    file_id: String,
    state: State<'_, AppState>,
) -> Result<Vec<Block>, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get all blocks from engine
    let blocks_map = handle.get_all_blocks().await;

    // Convert HashMap to Vec
    let blocks: Vec<Block> = blocks_map.into_values().collect();

    Ok(blocks)
}

/// List files in a block's asset directory.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file
/// * `block_id` - Unique identifier of the block whose directory to list
///
/// # Returns
/// * `Ok(Vec<String>)` - List of file and directory names in the block's directory
/// * `Err(message)` - Error if file is not open or directory doesn't exist
#[tauri::command]
#[specta]
pub fn list_block_files(
    file_id: String,
    block_id: String,
    state: State<'_, AppState>,
) -> Result<Vec<String>, String> {
    use std::fs;

    // Get file info to access the archive
    let file_info = state
        .files
        .get(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get block directory path
    // Block directories are stored in the archive's temp directory as "block-{block_id}"
    let block_dir = file_info.archive.temp_path().join(format!("block-{}", block_id));

    // Check if directory exists
    if !block_dir.exists() {
        // Directory doesn't exist yet, return empty list
        return Ok(Vec::new());
    }

    // Read directory contents
    let entries = fs::read_dir(&block_dir)
        .map_err(|e| format!("Failed to read directory '{}': {}", block_dir.display(), e))?;

    let mut files = Vec::new();
    for entry in entries {
        match entry {
            Ok(entry) => {
                let name = entry.file_name().to_string_lossy().to_string();
                files.push(name);
            }
            Err(e) => {
                // Log error but continue with other entries
                eprintln!("Error reading directory entry: {}", e);
            }
        }
    }

    // Sort files for consistent output
    files.sort();

    Ok(files)
}
