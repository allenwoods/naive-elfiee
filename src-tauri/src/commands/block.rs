use crate::models::{Block, Command, Event};
use crate::state::AppState;
use specta::specta;
use tauri::State;

/// Execute a command on a block in the specified file.
///
/// This is the primary way to modify blocks. Commands are processed by the engine actor,
/// which handles authorization, execution, and persistence.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file containing the block
/// * `cmd` - Command to execute (create, delete, link, write, etc.)
///
/// # Returns
/// * `Ok(events)` - Events generated by the command execution
/// * `Err(message)` - Error description if execution fails
#[tauri::command]
#[specta]
pub async fn execute_command(
    file_id: String,
    cmd: Command,
    state: State<'_, AppState>,
) -> Result<Vec<Event>, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Process command through engine actor
    handle.process_command(cmd).await
}

/// Get a specific block by ID from a file.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file containing the block
/// * `block_id` - Unique identifier of the block to retrieve
///
/// # Returns
/// * `Ok(block)` - The requested block
/// * `Err(message)` - Error if file not open or block not found
#[tauri::command]
#[specta]
pub async fn get_block(
    file_id: String,
    block_id: String,
    state: State<'_, AppState>,
) -> Result<Block, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get block from engine
    handle
        .get_block(block_id)
        .await
        .ok_or_else(|| "Block not found".to_string())
}

/// Get all blocks from a file.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file
///
/// # Returns
/// * `Ok(blocks)` - Vector of all blocks in the file
/// * `Err(message)` - Error if file is not open
#[tauri::command]
#[specta]
pub async fn get_all_blocks(
    file_id: String,
    state: State<'_, AppState>,
) -> Result<Vec<Block>, String> {
    // Get engine handle for this file
    let handle = state
        .engine_manager
        .get_engine(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get all blocks from engine
    let blocks_map = handle.get_all_blocks().await;

    // Convert HashMap to Vec
    let blocks: Vec<Block> = blocks_map.into_values().collect();

    Ok(blocks)
}

/// List files in a block's asset directory.
///
/// # Arguments
/// * `file_id` - Unique identifier of the file
/// * `block_id` - Unique identifier of the block whose directory to list
///
/// # Returns
/// * `Ok(Vec<String>)` - List of file and directory names in the block's directory
/// * `Err(message)` - Error if file is not open or directory doesn't exist
#[tauri::command]
#[specta]
pub fn list_block_files(
    file_id: String,
    block_id: String,
    state: State<'_, AppState>,
) -> Result<Vec<String>, String> {
    use std::fs;

    // Get file info to access the archive
    let file_info = state
        .files
        .get(&file_id)
        .ok_or_else(|| format!("File '{}' is not open", file_id))?;

    // Get block directory path
    // Block directories are stored in the archive's temp directory as "block-{block_id}"
    let block_dir = file_info.archive.temp_path().join(format!("block-{}", block_id));

    // Check if directory exists
    if !block_dir.exists() {
        // Directory doesn't exist yet, return empty list
        return Ok(Vec::new());
    }

    // Read directory contents
    let entries = fs::read_dir(&block_dir)
        .map_err(|e| format!("Failed to read directory '{}': {}", block_dir.display(), e))?;

    let mut files = Vec::new();
    for entry in entries {
        match entry {
            Ok(entry) => {
                let name = entry.file_name().to_string_lossy().to_string();
                files.push(name);
            }
            Err(e) => {
                // Log error but continue with other entries
                eprintln!("Error reading directory entry: {}", e);
            }
        }
    }

    // Sort files for consistent output
    files.sort();

    Ok(files)
}
