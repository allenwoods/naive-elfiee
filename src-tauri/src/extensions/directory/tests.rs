//! Tests for Directory extension
//!
//! Generated by elfiee-ext-gen - Implement the TODO markers.
//!
//! Test categories included:
//! - Payload deserialization tests
//! - Basic capability functionality tests
//! - Authorization/CBAC tests
//! - Integration workflow tests

use super::*;
use crate::capabilities::grants::GrantsTable;
use crate::capabilities::registry::CapabilityRegistry;

use crate::models::{Block, Command};

// ============================================
// DirectoryList - Payload Tests
// ============================================

#[test]
fn test_list_payload_deserialize() {
    let json = serde_json::json!({
        "path": "/test/path",
        "recursive": true,
        "include_hidden": false,
        "max_depth": 3
    });

    let result: Result<DirectoryListPayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Failed to deserialize DirectoryListPayload");

    let payload = result.unwrap();
    assert_eq!(payload.path, "/test/path");
    assert!(payload.recursive);
    assert!(!payload.include_hidden);
    assert_eq!(payload.max_depth, Some(3));
}

// ============================================
// DirectoryList - Functionality Tests
// ============================================

#[test]
fn test_list_basic() {
    use std::fs;
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create test files
    fs::write(temp_dir.path().join("file1.txt"), "").unwrap();
    fs::write(temp_dir.path().join("file2.txt"), "").unwrap();
    fs::create_dir(temp_dir.path().join("subdir")).unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.list")
        .expect("directory.list capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Initialize block contents with root path
    block.contents = serde_json::json!({
        "root": temp_path
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.list".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": ".",  // Relative to block root
            "recursive": false,
            "include_hidden": false,
            "max_depth": null
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.list");

    // Verify event contents
    let entries = events[0]
        .value
        .get("entries")
        .expect("Event should contain entries");
    let entries_array = entries.as_array().expect("Entries should be an array");

    // Should have 3 entries: file1.txt, file2.txt, subdir
    assert_eq!(entries_array.len(), 3, "Should list 3 entries");

    // Verify entries contain expected files
    let entry_names: Vec<String> = entries_array
        .iter()
        .map(|e| e.get("name").unwrap().as_str().unwrap().to_string())
        .collect();

    assert!(entry_names.contains(&"file1.txt".to_string()));
    assert!(entry_names.contains(&"file2.txt".to_string()));
    assert!(entry_names.contains(&"subdir".to_string()));
}

#[test]
fn test_list_path_traversal_blocked() {
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.list")
        .expect("directory.list capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Initialize block contents with root path
    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Attempt path traversal with relative path
    let cmd = Command::new(
        "alice".to_string(),
        "directory.list".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "../../../etc",  // Path traversal attempt
            "recursive": false,
            "include_hidden": false,
            "max_depth": null
        }),
    );

    let result = cap.handler(&cmd, Some(&block));

    // Should fail due to path traversal detection
    assert!(result.is_err(), "Should reject path traversal attempt");

    let err_msg = result.unwrap_err();
    assert!(
        err_msg.contains("does not exist") || err_msg.contains("outside"),
        "Error should indicate path issue, got: {}",
        err_msg
    );
}

#[test]
fn test_list_max_depth_limit() {
    use std::fs;
    use tempfile::TempDir;

    // Create temporary test directory with nested structure
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create test files and subdirectory
    fs::write(temp_dir.path().join("file1.txt"), "").unwrap();
    let subdir = temp_dir.path().join("subdir");
    fs::create_dir(&subdir).unwrap();
    fs::write(subdir.join("nested.txt"), "").unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.list")
        .expect("directory.list capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // List with max_depth = 1 (should only list current directory, no recursion into subdirs)
    let cmd = Command::new(
        "alice".to_string(),
        "directory.list".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": ".",
            "recursive": true,
            "include_hidden": false,
            "max_depth": 1
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    let entries = events[0]
        .value
        .get("entries")
        .expect("Event should contain entries");
    let entries_array = entries.as_array().expect("Entries should be an array");

    // With max_depth=1, should only see current directory contents (no recursion into subdirs)
    // Should see file1.txt and subdir, but NOT subdir/nested.txt
    assert_eq!(
        entries_array.len(),
        2,
        "Should list only current directory entries"
    );

    let entry_names: Vec<String> = entries_array
        .iter()
        .map(|e| e.get("name").unwrap().as_str().unwrap().to_string())
        .collect();

    assert!(entry_names.contains(&"file1.txt".to_string()));
    assert!(entry_names.contains(&"subdir".to_string()));

    // Verify no nested files are included (nested.txt is inside subdir)
    assert!(!entry_names.iter().any(|name| name.contains("nested")));
}

// ============================================
// DirectoryList - Authorization Tests
// ============================================

#[test]
fn test_list_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.list", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_list_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.list", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_list_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.list".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.list", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryCreate - Payload Tests
// ============================================

#[test]
fn test_create_payload_deserialize() {
    let json = serde_json::json!({
        "path": "test.txt",
        "item_type": "file",
        "content": ""
    });

    let result: Result<DirectoryCreatePayload, _> = serde_json::from_value(json);
    assert!(
        result.is_ok(),
        "Failed to deserialize DirectoryCreatePayload"
    );

    let payload = result.unwrap();
    assert_eq!(payload.path, "test.txt");
    assert_eq!(payload.item_type, "file");
    assert_eq!(payload.content, "");
}

// ============================================
// DirectoryCreate - Functionality Tests
// ============================================

#[test]
fn test_create_basic() {
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.create")
        .expect("directory.create capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Test 1: Create a file
    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "test.txt",
            "item_type": "file",
            "content": ""
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.create");

    // Verify file was created
    let created_file = temp_dir.path().join("test.txt");
    assert!(created_file.exists(), "File should be created");
    assert!(created_file.is_file(), "Should be a file");

    // Test 2: Create a directory
    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "testdir",
            "item_type": "dir",
            "content": ""
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Should create directory successfully");

    // Verify directory was created
    let created_dir = temp_dir.path().join("testdir");
    assert!(created_dir.exists(), "Directory should be created");
    assert!(created_dir.is_dir(), "Should be a directory");
}

#[test]
fn test_create_rejects_symlink_parent() {
    use std::fs;
    use std::os::unix::fs::symlink;
    use tempfile::TempDir;

    // Create temporary directories
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create a real directory and a symlink to it
    let real_dir = temp_dir.path().join("real_dir");
    fs::create_dir(&real_dir).unwrap();
    let symlink_dir = temp_dir.path().join("symlink_dir");
    symlink(&real_dir, &symlink_dir).unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.create")
        .expect("directory.create capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Try to create a file inside the symlinked directory
    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "symlink_dir/test.txt",
            "item_type": "file",
            "content": "test"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));

    // Should succeed - symlink in parent is allowed (only the target itself is checked)
    // This tests the current behavior. If we want stricter checks, modify the implementation.
    assert!(
        result.is_ok(),
        "Current implementation allows symlinks in path (not target): {:?}",
        result.err()
    );
}

#[test]
fn test_create_normalizes_dot_slash_path() {
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.create")
        .expect("directory.create capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Create file with ./ prefix
    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "./././test.txt",
            "item_type": "file",
            "content": "test content"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should handle ./ normalization: {:?}",
        result.err()
    );

    // Verify file was created correctly
    let created_file = temp_dir.path().join("test.txt");
    assert!(created_file.exists(), "File should be created");
    assert!(created_file.is_file(), "Should be a file");

    let content = fs::read_to_string(&created_file).unwrap();
    assert_eq!(
        content, "test content",
        "File should contain correct content"
    );
}

// ============================================
// DirectoryCreate - Authorization Tests
// ============================================

#[test]
fn test_create_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.create", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_create_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.create", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_create_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.create", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryDelete - Payload Tests
// ============================================

#[test]
fn test_delete_payload_deserialize() {
    let json = serde_json::json!({
        "path": "test.txt",
        "recursive": false
    });

    let result: Result<DirectoryDeletePayload, _> = serde_json::from_value(json);
    assert!(
        result.is_ok(),
        "Failed to deserialize DirectoryDeletePayload"
    );

    let payload = result.unwrap();
    assert_eq!(payload.path, "test.txt");
    assert!(!payload.recursive);
}

// ============================================
// DirectoryDelete - Functionality Tests
// ============================================

#[test]
fn test_delete_basic() {
    use std::fs;
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create test files and directories
    fs::write(temp_dir.path().join("file_to_delete.txt"), "test").unwrap();
    fs::create_dir(temp_dir.path().join("empty_dir")).unwrap();
    fs::create_dir(temp_dir.path().join("non_empty_dir")).unwrap();
    fs::write(temp_dir.path().join("non_empty_dir/file.txt"), "test").unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.delete")
        .expect("directory.delete capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Test 1: Delete a file
    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "file_to_delete.txt",
            "recursive": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should delete file successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.delete");

    // Verify file was deleted
    assert!(
        !temp_dir.path().join("file_to_delete.txt").exists(),
        "File should be deleted"
    );

    // Test 2: Delete empty directory
    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "empty_dir",
            "recursive": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Should delete empty directory successfully");
    assert!(
        !temp_dir.path().join("empty_dir").exists(),
        "Empty directory should be deleted"
    );

    // Test 3: Delete non-empty directory with recursive=true
    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "non_empty_dir",
            "recursive": true
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should delete non-empty directory with recursive=true"
    );
    assert!(
        !temp_dir.path().join("non_empty_dir").exists(),
        "Non-empty directory should be deleted"
    );
}

#[test]
fn test_delete_rejects_symlink() {
    use std::fs;
    use std::os::unix::fs::symlink;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create a real file and a symlink to it
    let real_file = temp_dir.path().join("real.txt");
    fs::write(&real_file, "content").unwrap();
    let symlink_file = temp_dir.path().join("link.txt");
    symlink(&real_file, &symlink_file).unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.delete")
        .expect("directory.delete capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Try to delete the symlink
    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "link.txt",
            "recursive": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));

    // Should fail - symlinks are rejected for security reasons
    assert!(result.is_err(), "Should reject deletion of symlink");

    let err_msg = result.unwrap_err();
    assert!(
        err_msg.contains("symlink") || err_msg.contains("symbolic link"),
        "Error should mention symlink, got: {}",
        err_msg
    );

    // Verify symlink still exists
    assert!(symlink_file.exists(), "Symlink should not be deleted");
    // Verify real file still exists
    assert!(real_file.exists(), "Real file should not be affected");
}

#[test]
fn test_delete_empty_dir_without_recursive() {
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create an empty directory
    let empty_dir = temp_dir.path().join("empty_dir");
    fs::create_dir(&empty_dir).unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.delete")
        .expect("directory.delete capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Delete empty directory with recursive=false
    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "empty_dir",
            "recursive": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));

    // Should succeed - empty directories can be deleted without recursive=true
    assert!(
        result.is_ok(),
        "Should delete empty directory without recursive flag: {:?}",
        result.err()
    );

    // Verify directory was deleted
    assert!(!empty_dir.exists(), "Empty directory should be deleted");
}

// ============================================
// DirectoryDelete - Authorization Tests
// ============================================

#[test]
fn test_delete_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.delete", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_delete_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.delete", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_delete_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.delete", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryRename - Payload Tests
// ============================================

#[test]
fn test_rename_payload_deserialize() {
    let json = serde_json::json!({
        "old_path": "old.txt",
        "new_path": "new.txt"
    });

    let result: Result<DirectoryRenamePayload, _> = serde_json::from_value(json);
    assert!(
        result.is_ok(),
        "Failed to deserialize DirectoryRenamePayload"
    );

    let payload = result.unwrap();
    assert_eq!(payload.old_path, "old.txt");
    assert_eq!(payload.new_path, "new.txt");
}

// ============================================
// DirectoryRename - Functionality Tests
// ============================================

#[test]
fn test_rename_basic() {
    use std::fs;
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create test file and directory
    fs::write(temp_dir.path().join("old_file.txt"), "content").unwrap();
    fs::create_dir(temp_dir.path().join("old_dir")).unwrap();
    fs::write(temp_dir.path().join("old_dir/nested.txt"), "nested").unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.rename")
        .expect("directory.rename capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Test 1: Rename a file
    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "old_file.txt",
            "new_path": "new_file.txt"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should rename file successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.rename");

    // Verify file was renamed
    assert!(
        !temp_dir.path().join("old_file.txt").exists(),
        "Old file should not exist"
    );
    assert!(
        temp_dir.path().join("new_file.txt").exists(),
        "New file should exist"
    );

    let content = fs::read_to_string(temp_dir.path().join("new_file.txt")).unwrap();
    assert_eq!(content, "content", "File content should be preserved");

    // Test 2: Rename a directory (with nested files)
    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "old_dir",
            "new_path": "new_dir"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Should rename directory successfully");

    // Verify directory was renamed
    assert!(
        !temp_dir.path().join("old_dir").exists(),
        "Old directory should not exist"
    );
    assert!(
        temp_dir.path().join("new_dir").exists(),
        "New directory should exist"
    );

    // Verify nested file path is automatically updated by filesystem
    assert!(
        temp_dir.path().join("new_dir/nested.txt").exists(),
        "Nested file should exist in new directory"
    );

    let nested_content = fs::read_to_string(temp_dir.path().join("new_dir/nested.txt")).unwrap();
    assert_eq!(
        nested_content, "nested",
        "Nested file content should be preserved"
    );
}

#[test]
fn test_rename_rejects_symlink() {
    use std::fs;
    use std::os::unix::fs::symlink;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create a real file and a symlink to it
    let real_file = temp_dir.path().join("real.txt");
    fs::write(&real_file, "content").unwrap();
    let symlink_file = temp_dir.path().join("link.txt");
    symlink(&real_file, &symlink_file).unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.rename")
        .expect("directory.rename capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Try to rename the symlink
    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "link.txt",
            "new_path": "renamed_link.txt"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));

    // Should fail - symlinks are rejected for security reasons
    assert!(result.is_err(), "Should reject renaming of symlink");

    let err_msg = result.unwrap_err();
    assert!(
        err_msg.contains("symlink") || err_msg.contains("symbolic link"),
        "Error should mention symlink, got: {}",
        err_msg
    );
}

#[test]
fn test_rename_normalizes_parent_ref() {
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create a subdirectory and a file
    let subdir = temp_dir.path().join("subdir");
    fs::create_dir(&subdir).unwrap();
    let original_file = temp_dir.path().join("original.txt");
    fs::write(&original_file, "content").unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.rename")
        .expect("directory.rename capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Rename with parent reference normalization: subdir/../renamed.txt = renamed.txt
    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "original.txt",
            "new_path": "subdir/../renamed.txt"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should handle parent reference normalization: {:?}",
        result.err()
    );

    // Verify file was renamed correctly (should be at root, not in subdir)
    let renamed_file = temp_dir.path().join("renamed.txt");
    assert!(
        renamed_file.exists(),
        "File should be renamed to root directory"
    );
    assert!(!original_file.exists(), "Original file should not exist");

    let content = fs::read_to_string(&renamed_file).unwrap();
    assert_eq!(content, "content", "File content should be preserved");
}

// ============================================
// DirectoryRename - Authorization Tests
// ============================================

#[test]
fn test_rename_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.rename", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_rename_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.rename", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_rename_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.rename", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryRefresh - Payload Tests
// ============================================

#[test]
fn test_refresh_payload_deserialize() {
    let json = serde_json::json!({
        "recursive": true
    });

    let result: Result<DirectoryRefreshPayload, _> = serde_json::from_value(json);
    assert!(
        result.is_ok(),
        "Failed to deserialize DirectoryRefreshPayload"
    );

    let payload = result.unwrap();
    assert!(payload.recursive);
}

// ============================================
// DirectoryRefresh - Functionality Tests
// ============================================

#[test]
fn test_refresh_basic() {
    use std::fs;
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create initial files
    fs::write(temp_dir.path().join("file1.txt"), "").unwrap();
    fs::write(temp_dir.path().join("file2.txt"), "").unwrap();

    let registry = CapabilityRegistry::new();
    let list_cap = registry.get("directory.list").unwrap();
    let refresh_cap = registry
        .get("directory.refresh")
        .expect("directory.refresh capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Step 1: Initial list to populate cache
    let list_cmd = Command::new(
        "alice".to_string(),
        "directory.list".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": ".",
            "recursive": false,
            "include_hidden": false,
            "max_depth": null
        }),
    );

    let list_result = list_cap.handler(&list_cmd, Some(&block)).unwrap();
    let initial_entries = list_result[0]
        .value
        .get("entries")
        .unwrap()
        .as_array()
        .unwrap();
    assert_eq!(initial_entries.len(), 2, "Should initially have 2 files");

    // Update block contents with list result
    block.contents = list_result[0].value.clone();

    // Step 2: Add a new file externally (simulating external change)
    fs::write(temp_dir.path().join("file3.txt"), "").unwrap();

    // Step 3: Refresh to detect the new file
    let refresh_cmd = Command::new(
        "alice".to_string(),
        "directory.refresh".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "recursive": false
        }),
    );

    let result = refresh_cap.handler(&refresh_cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should refresh successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.refresh");

    // Verify refreshed entries include the new file
    let refreshed_entries = events[0].value.get("entries").unwrap().as_array().unwrap();
    assert_eq!(
        refreshed_entries.len(),
        3,
        "Should now have 3 files after refresh"
    );

    let entry_names: Vec<String> = refreshed_entries
        .iter()
        .map(|e| e.get("name").unwrap().as_str().unwrap().to_string())
        .collect();

    assert!(entry_names.contains(&"file1.txt".to_string()));
    assert!(entry_names.contains(&"file2.txt".to_string()));
    assert!(entry_names.contains(&"file3.txt".to_string()));
}

#[test]
fn test_refresh_detects_external_changes() {
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create initial files
    fs::write(temp_dir.path().join("file1.txt"), "").unwrap();
    fs::write(temp_dir.path().join("file2.txt"), "").unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.refresh")
        .expect("directory.refresh capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path,
        "entries": [  // Simulated old cache
            {"name": "file1.txt", "is_file": true, "is_dir": false},
            {"name": "file2.txt", "is_file": true, "is_dir": false}
        ],
        "last_updated": "2024-01-01T00:00:00Z"
    });

    // Externally modify filesystem: add file3.txt, delete file2.txt
    fs::write(temp_dir.path().join("file3.txt"), "").unwrap();
    fs::remove_file(temp_dir.path().join("file2.txt")).unwrap();

    let cmd = Command::new(
        "alice".to_string(),
        "directory.refresh".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "recursive": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Refresh should detect external changes: {:?}",
        result.err()
    );

    let events = result.unwrap();
    let entries = events[0]
        .value
        .get("entries")
        .expect("Event should contain entries");
    let entries_array = entries.as_array().expect("Entries should be an array");

    let entry_names: Vec<String> = entries_array
        .iter()
        .map(|e| e.get("name").unwrap().as_str().unwrap().to_string())
        .collect();

    // Should detect changes
    assert!(
        entry_names.contains(&"file1.txt".to_string()),
        "file1.txt still exists"
    );
    assert!(
        entry_names.contains(&"file3.txt".to_string()),
        "file3.txt was added"
    );
    assert!(
        !entry_names.contains(&"file2.txt".to_string()),
        "file2.txt was deleted"
    );
}

#[test]
fn test_refresh_with_different_config() {
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create files including hidden file
    fs::write(temp_dir.path().join("visible.txt"), "").unwrap();
    fs::write(temp_dir.path().join(".hidden.txt"), "").unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.refresh")
        .expect("directory.refresh capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Block was previously listed with include_hidden=false
    block.contents = serde_json::json!({
        "root": temp_path,
        "include_hidden": false,
        "entries": [
            {"name": "visible.txt", "is_file": true, "is_dir": false}
        ]
    });

    // Refresh with different config (no include_hidden specified - uses old value)
    let cmd = Command::new(
        "alice".to_string(),
        "directory.refresh".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "recursive": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Refresh should work: {:?}", result.err());

    let events = result.unwrap();
    let entries = events[0]
        .value
        .get("entries")
        .expect("Event should contain entries");
    let entries_array = entries.as_array().expect("Entries should be an array");

    let entry_names: Vec<String> = entries_array
        .iter()
        .map(|e| e.get("name").unwrap().as_str().unwrap().to_string())
        .collect();

    // Should use previous config (include_hidden=false), so hidden file not included
    assert!(entry_names.contains(&"visible.txt".to_string()));
    assert!(!entry_names.contains(&".hidden.txt".to_string()));
}

// ============================================
// DirectoryRefresh - Authorization Tests
// ============================================

#[test]
fn test_refresh_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.refresh", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_refresh_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.refresh", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_refresh_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.refresh".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.refresh", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryWatch - Payload Tests
// ============================================

#[test]
fn test_watch_payload_deserialize() {
    let json = serde_json::json!({
        "enabled": true
    });

    let result: Result<DirectoryWatchPayload, _> = serde_json::from_value(json);
    assert!(
        result.is_ok(),
        "Failed to deserialize DirectoryWatchPayload"
    );

    let payload = result.unwrap();
    assert!(payload.enabled);
}

// ============================================
// DirectoryWatch - Functionality Tests
// ============================================

#[test]
fn test_watch_basic() {
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.watch")
        .expect("directory.watch capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path,
        "watch_enabled": false
    });

    // Test 1: Enable watching
    let cmd = Command::new(
        "alice".to_string(),
        "directory.watch".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "enabled": true
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should enable watching successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.watch");

    // Verify watch_enabled flag is set to true
    let watch_enabled = events[0].value.get("watch_enabled").unwrap();
    assert!(
        watch_enabled.as_bool().unwrap(),
        "watch_enabled should be true"
    );

    // Test 2: Disable watching
    let cmd = Command::new(
        "alice".to_string(),
        "directory.watch".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "enabled": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Should disable watching successfully");

    let events = result.unwrap();
    let watch_enabled = events[0].value.get("watch_enabled").unwrap();
    assert!(
        !watch_enabled.as_bool().unwrap(),
        "watch_enabled should be false"
    );
}

#[test]
fn test_watch_flag_persists() {
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.watch")
        .expect("directory.watch capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Enable watch
    let cmd_enable = Command::new(
        "alice".to_string(),
        "directory.watch".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "enabled": true
        }),
    );

    let result_enable = cap.handler(&cmd_enable, Some(&block));
    assert!(
        result_enable.is_ok(),
        "Should enable watch: {:?}",
        result_enable.err()
    );

    let events_enable = result_enable.unwrap();
    let watch_enabled = events_enable[0]
        .value
        .get("watch_enabled")
        .expect("Event should contain watch_enabled");
    assert!(watch_enabled.as_bool().unwrap());

    // Update block contents to simulate persistence
    block.contents = serde_json::json!({
        "root": temp_path,
        "watch_enabled": true
    });

    // Disable watch
    let cmd_disable = Command::new(
        "alice".to_string(),
        "directory.watch".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "enabled": false
        }),
    );

    let result_disable = cap.handler(&cmd_disable, Some(&block));
    assert!(
        result_disable.is_ok(),
        "Should disable watch: {:?}",
        result_disable.err()
    );

    let events_disable = result_disable.unwrap();
    let watch_enabled = events_disable[0]
        .value
        .get("watch_enabled")
        .expect("Event should contain watch_enabled");
    assert!(!watch_enabled.as_bool().unwrap());
}

#[test]
fn test_watch_no_actual_monitoring() {
    use std::fs;
    use std::thread;
    use std::time::Duration;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.watch")
        .expect("directory.watch capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Enable watch
    let cmd = Command::new(
        "alice".to_string(),
        "directory.watch".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "enabled": true
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Should enable watch: {:?}", result.err());

    // Modify filesystem (add a file)
    fs::write(temp_dir.path().join("new_file.txt"), "content").unwrap();

    // Wait a bit (simulating time passing)
    thread::sleep(Duration::from_millis(100));

    // The capability should NOT automatically emit events or trigger refresh
    // This is a documentation test - it verifies current stub behavior
    // In future, when real watching is implemented, this test should be updated

    // For now, we just verify the flag was set
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should only generate the initial event");

    let watch_enabled = events[0]
        .value
        .get("watch_enabled")
        .expect("Event should contain watch_enabled");
    assert!(
        watch_enabled.as_bool().unwrap(),
        "watch_enabled should be true"
    );

    // No additional events should have been generated (stub implementation)
}

// ============================================
// DirectoryWatch - Authorization Tests
// ============================================

#[test]
fn test_watch_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.watch", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_watch_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.watch", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_watch_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.watch".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.watch", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectorySearch - Payload Tests
// ============================================

#[test]
fn test_search_payload_deserialize() {
    let json = serde_json::json!({
        "pattern": "*.rs",
        "recursive": true,
        "include_hidden": false
    });

    let result: Result<DirectorySearchPayload, _> = serde_json::from_value(json);
    assert!(
        result.is_ok(),
        "Failed to deserialize DirectorySearchPayload"
    );

    let payload = result.unwrap();
    assert_eq!(payload.pattern, "*.rs");
    assert!(payload.recursive);
    assert!(!payload.include_hidden);
}

// ============================================
// DirectorySearch - Functionality Tests
// ============================================

#[test]
fn test_search_basic() {
    use std::fs;
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create test files with different extensions
    fs::write(temp_dir.path().join("test1.rs"), "").unwrap();
    fs::write(temp_dir.path().join("test2.rs"), "").unwrap();
    fs::write(temp_dir.path().join("test.txt"), "").unwrap();
    fs::write(temp_dir.path().join("readme.md"), "").unwrap();
    fs::create_dir(temp_dir.path().join("subdir")).unwrap();
    fs::write(temp_dir.path().join("subdir/nested.rs"), "").unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.search")
        .expect("directory.search capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Test 1: Search for *.rs files (non-recursive)
    let cmd = Command::new(
        "alice".to_string(),
        "directory.search".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "pattern": "*.rs",
            "recursive": false,
            "include_hidden": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should search successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.search");

    // Verify search results
    let matches = events[0].value.get("matches").unwrap().as_array().unwrap();
    assert_eq!(matches.len(), 2, "Should find 2 .rs files in root");

    let match_names: Vec<String> = matches
        .iter()
        .map(|m| m.get("name").unwrap().as_str().unwrap().to_string())
        .collect();

    assert!(match_names.contains(&"test1.rs".to_string()));
    assert!(match_names.contains(&"test2.rs".to_string()));

    // Test 2: Search recursively for *.rs files
    let cmd = Command::new(
        "alice".to_string(),
        "directory.search".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "pattern": "*.rs",
            "recursive": true,
            "include_hidden": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Should search recursively");

    let events = result.unwrap();
    let matches = events[0].value.get("matches").unwrap().as_array().unwrap();
    assert_eq!(matches.len(), 3, "Should find 3 .rs files including nested");

    // Test 3: Search with ? wildcard
    let cmd = Command::new(
        "alice".to_string(),
        "directory.search".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "pattern": "test?.rs",
            "recursive": false,
            "include_hidden": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Should search with ? wildcard");

    let events = result.unwrap();
    let matches = events[0].value.get("matches").unwrap().as_array().unwrap();
    assert_eq!(matches.len(), 2, "Should match test1.rs and test2.rs");
}

#[test]
fn test_search_multiple_consecutive_wildcards() {
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Create test files
    fs::write(temp_dir.path().join("test.txt"), "").unwrap();
    fs::write(temp_dir.path().join("testing.txt"), "").unwrap();
    fs::write(temp_dir.path().join("other.txt"), "").unwrap();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.search")
        .expect("directory.search capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Search with multiple consecutive wildcards (should not cause stack overflow)
    let cmd = Command::new(
        "alice".to_string(),
        "directory.search".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "pattern": "***test***",
            "recursive": false,
            "include_hidden": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Should handle multiple consecutive wildcards: {:?}",
        result.err()
    );

    let events = result.unwrap();
    let matches = events[0].value.get("matches").unwrap().as_array().unwrap();

    // Should match files containing "test"
    assert!(matches.len() >= 2, "Should match at least 2 files");

    let match_names: Vec<String> = matches
        .iter()
        .map(|m| m.get("name").unwrap().as_str().unwrap().to_string())
        .collect();

    assert!(match_names.contains(&"test.txt".to_string()));
    assert!(match_names.contains(&"testing.txt".to_string()));
}

#[test]
fn test_search_rejects_too_many_wildcards() {
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.search")
        .expect("directory.search capability should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Search with 11 wildcards (exceeds limit of 10)
    let cmd = Command::new(
        "alice".to_string(),
        "directory.search".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "pattern": "*a*b*c*d*e*f*g*h*i*j*k",  // 11 wildcards
            "recursive": false,
            "include_hidden": false
        }),
    );

    let result = cap.handler(&cmd, Some(&block));

    // Should fail due to too many wildcards
    assert!(
        result.is_err(),
        "Should reject patterns with more than 10 wildcards"
    );

    let err_msg = result.unwrap_err();
    assert!(
        err_msg.contains("wildcards") || err_msg.contains("11"),
        "Error should mention wildcard limit, got: {}",
        err_msg
    );
}

// ============================================
// DirectorySearch - Authorization Tests
// ============================================

#[test]
fn test_search_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.search", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_search_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.search", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_search_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.search".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.search", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// Integration Workflow Test
// ============================================

#[test]
fn test_full_workflow() {
    use tempfile::TempDir;

    // Create temporary test directory
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = CapabilityRegistry::new();

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "root": temp_path
    });

    // Step 1: List empty directory
    let list_cap = registry.get("directory.list").unwrap();
    let cmd = Command::new(
        "alice".to_string(),
        "directory.list".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": ".",
            "recursive": false,
            "include_hidden": false,
            "max_depth": null
        }),
    );
    let result = list_cap.handler(&cmd, Some(&block)).unwrap();
    let entries = result[0].value.get("entries").unwrap().as_array().unwrap();
    assert_eq!(entries.len(), 0, "Directory should be empty initially");

    // Update block contents
    block.contents = result[0].value.clone();

    // Step 2: Create a file
    let create_cap = registry.get("directory.create").unwrap();
    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "test.txt",
            "item_type": "file",
            "content": "hello"
        }),
    );
    create_cap.handler(&cmd, Some(&block)).unwrap();

    // Step 3: List to verify file was created
    let cmd = Command::new(
        "alice".to_string(),
        "directory.list".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": ".",
            "recursive": false,
            "include_hidden": false,
            "max_depth": null
        }),
    );
    let result = list_cap.handler(&cmd, Some(&block)).unwrap();
    let entries = result[0].value.get("entries").unwrap().as_array().unwrap();
    assert_eq!(entries.len(), 1, "Should have 1 file after create");
    assert_eq!(
        entries[0].get("name").unwrap().as_str().unwrap(),
        "test.txt"
    );

    block.contents = result[0].value.clone();

    // Step 4: Rename the file
    let rename_cap = registry.get("directory.rename").unwrap();
    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "test.txt",
            "new_path": "renamed.txt"
        }),
    );
    rename_cap.handler(&cmd, Some(&block)).unwrap();

    // Step 5: Refresh to see the renamed file
    let refresh_cap = registry.get("directory.refresh").unwrap();
    let cmd = Command::new(
        "alice".to_string(),
        "directory.refresh".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "recursive": false
        }),
    );
    let result = refresh_cap.handler(&cmd, Some(&block)).unwrap();
    let entries = result[0].value.get("entries").unwrap().as_array().unwrap();
    assert_eq!(entries.len(), 1, "Should still have 1 file after rename");
    assert_eq!(
        entries[0].get("name").unwrap().as_str().unwrap(),
        "renamed.txt"
    );

    block.contents = result[0].value.clone();

    // Step 6: Search for the renamed file
    let search_cap = registry.get("directory.search").unwrap();
    let cmd = Command::new(
        "alice".to_string(),
        "directory.search".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "pattern": "*.txt",
            "recursive": false,
            "include_hidden": false
        }),
    );
    let result = search_cap.handler(&cmd, Some(&block)).unwrap();
    let matches = result[0].value.get("matches").unwrap().as_array().unwrap();
    assert_eq!(matches.len(), 1, "Should find 1 .txt file");
    assert_eq!(
        matches[0].get("name").unwrap().as_str().unwrap(),
        "renamed.txt"
    );

    // Step 7: Enable watching
    let watch_cap = registry.get("directory.watch").unwrap();
    let cmd = Command::new(
        "alice".to_string(),
        "directory.watch".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "enabled": true
        }),
    );
    let result = watch_cap.handler(&cmd, Some(&block)).unwrap();
    assert!(result[0]
        .value
        .get("watch_enabled")
        .unwrap()
        .as_bool()
        .unwrap());

    // Step 8: Delete the file
    let delete_cap = registry.get("directory.delete").unwrap();
    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "renamed.txt",
            "recursive": false
        }),
    );
    delete_cap.handler(&cmd, Some(&block)).unwrap();

    // Step 9: List to verify file was deleted
    let cmd = Command::new(
        "alice".to_string(),
        "directory.list".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": ".",
            "recursive": false,
            "include_hidden": false,
            "max_depth": null
        }),
    );
    let result = list_cap.handler(&cmd, Some(&block)).unwrap();
    let entries = result[0].value.get("entries").unwrap().as_array().unwrap();
    assert_eq!(entries.len(), 0, "Directory should be empty after delete");
}

#[test]
fn test_concurrent_create_same_path() {
    use std::fs;
    use std::sync::{Arc, Mutex};
    use std::thread;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    let registry = Arc::new(CapabilityRegistry::new());
    let block = Arc::new(Mutex::new({
        let mut b = Block::new(
            "Test Block".to_string(),
            "directory".to_string(),
            "alice".to_string(),
        );
        b.contents = serde_json::json!({
            "root": temp_path.clone()
        });
        b
    }));

    // Spawn two threads trying to create the same file simultaneously
    let registry1 = registry.clone();
    let block1 = block.clone();
    let handle1 = thread::spawn(move || {
        let cap = registry1.get("directory.create").unwrap();
        let block_guard = block1.lock().unwrap();
        let cmd = Command::new(
            "alice".to_string(),
            "directory.create".to_string(),
            block_guard.block_id.clone(),
            serde_json::json!({
                "path": "conflict.txt",
                "item_type": "file",
                "content": "thread1"
            }),
        );
        cap.handler(&cmd, Some(&*block_guard))
    });

    let registry2 = registry.clone();
    let block2 = block.clone();
    let handle2 = thread::spawn(move || {
        let cap = registry2.get("directory.create").unwrap();
        let block_guard = block2.lock().unwrap();
        let cmd = Command::new(
            "alice".to_string(),
            "directory.create".to_string(),
            block_guard.block_id.clone(),
            serde_json::json!({
                "path": "conflict.txt",
                "item_type": "file",
                "content": "thread2"
            }),
        );
        cap.handler(&cmd, Some(&*block_guard))
    });

    let result1 = handle1.join().unwrap();
    let result2 = handle2.join().unwrap();

    // TOCTOU protection: only one should succeed
    // (Or both might succeed if they execute at different times)
    // The important thing is that the file system state is consistent
    let success_count = [result1.is_ok(), result2.is_ok()]
        .iter()
        .filter(|&&x| x)
        .count();

    // At least one should succeed, but if both succeed, the last write wins
    assert!(success_count >= 1, "At least one create should succeed");

    // Verify file exists and has content from one of the threads
    let file_path = temp_dir.path().join("conflict.txt");
    assert!(file_path.exists(), "File should exist");

    let content = fs::read_to_string(&file_path).unwrap();
    assert!(
        content == "thread1" || content == "thread2",
        "File should contain content from one thread"
    );
}

#[test]
fn test_concurrent_create_delete() {
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path().to_string_lossy().to_string();

    // Pre-create parent directory
    let parent_dir = temp_dir.path().join("parent");
    std::fs::create_dir(&parent_dir).unwrap();

    let registry = Arc::new(CapabilityRegistry::new());
    let block = Arc::new(Mutex::new({
        let mut b = Block::new(
            "Test Block".to_string(),
            "directory".to_string(),
            "alice".to_string(),
        );
        b.contents = serde_json::json!({
            "root": temp_path.clone()
        });
        b
    }));

    // Thread 1: Try to create a file in parent directory
    let registry1 = registry.clone();
    let block1 = block.clone();
    let handle1 = thread::spawn(move || {
        thread::sleep(Duration::from_millis(10)); // Slight delay
        let cap = registry1.get("directory.create").unwrap();
        let block_guard = block1.lock().unwrap();
        let cmd = Command::new(
            "alice".to_string(),
            "directory.create".to_string(),
            block_guard.block_id.clone(),
            serde_json::json!({
                "path": "parent/child.txt",
                "item_type": "file",
                "content": "test"
            }),
        );
        cap.handler(&cmd, Some(&*block_guard))
    });

    // Thread 2: Try to delete parent directory
    let registry2 = registry.clone();
    let block2 = block.clone();
    let handle2 = thread::spawn(move || {
        let cap = registry2.get("directory.delete").unwrap();
        let block_guard = block2.lock().unwrap();
        let cmd = Command::new(
            "alice".to_string(),
            "directory.delete".to_string(),
            block_guard.block_id.clone(),
            serde_json::json!({
                "path": "parent",
                "recursive": true
            }),
        );
        cap.handler(&cmd, Some(&*block_guard))
    });

    let _result1 = handle1.join().unwrap();
    let _result2 = handle2.join().unwrap();

    // Verify final state consistency
    // Either:
    // 1. Delete succeeded, parent directory doesn't exist
    // 2. Delete failed (not empty), parent directory exists with file
    // 3. Create failed (parent deleted), parent directory doesn't exist

    let parent_exists = parent_dir.exists();
    let child_exists = temp_dir.path().join("parent/child.txt").exists();

    // Consistency check: if child exists, parent must exist
    if child_exists {
        assert!(parent_exists, "If child exists, parent must exist");
    }
}
