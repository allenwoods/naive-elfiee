//! Tests for Directory extension
//!
//! Generated by elfiee-ext-gen - Implement the TODO markers.
//!
//! Test categories included:
//! - Payload deserialization tests
//! - Basic capability functionality tests
//! - Authorization/CBAC tests
//! - Integration workflow tests

use super::*;
use crate::capabilities::grants::GrantsTable;
use crate::capabilities::registry::CapabilityRegistry;

use crate::models::{Block, Command};

// ============================================
// DirectoryImport - Payload Tests
// ============================================

#[test]
fn test_import_payload_deserialize() {
    let json = serde_json::json!({
        "source_path": "/Users/me/projects/my-app",
        "target_path": "libs/external"
    });

    let result: Result<DirectoryImportPayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.source_path, "/Users/me/projects/my-app");
    assert_eq!(payload.target_path, Some("libs/external".to_string()));
}

// ============================================
// DirectoryImport - Functionality Tests
// ============================================

#[test]
fn test_import_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.import")
        .expect("directory.import should be registered");

    // Create temporary directory with test files
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path();

    // Create test files
    fs::write(temp_path.join("file1.md"), "# Test File 1").unwrap();
    fs::write(temp_path.join("file2.rs"), "fn main() {}").unwrap();

    // Create subdirectory
    fs::create_dir(temp_path.join("subdir")).unwrap();
    fs::write(temp_path.join("subdir/file3.txt"), "content").unwrap();

    // Create directory block with empty entries
    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    block.contents = serde_json::json!({
        "entries": {}
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.import".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "source_path": temp_path.to_str().unwrap(),
            "target_path": null
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result
    );

    let events = result.unwrap();
    // Should generate: N × core.create + 1 × directory.write + 1 × core.update_metadata
    assert!(
        events.len() >= 3,
        "Should generate multiple events (core.create + directory.write + metadata update), got {}",
        events.len()
    );

    // Verify core.create events
    let create_events: Vec<_> = events
        .iter()
        .filter(|e| e.attribute.ends_with("/core.create"))
        .collect();
    assert!(create_events.len() >= 2, "Should create blocks for files");
    assert_eq!(create_events[0].value["contents"]["source"], "linked");

    // Verify directory.write event
    let write_event = events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"));
    assert!(write_event.is_some(), "Should have directory.write event");

    let write_event = write_event.unwrap();
    assert_eq!(write_event.value["contents"]["source"], "linked");
    let entries = write_event.value["contents"]["entries"]
        .as_object()
        .unwrap();
    assert!(
        entries.contains_key("file1.md"),
        "Should have file1.md entry"
    );
    assert_eq!(entries["file1.md"]["source"], "linked");

    // Verify metadata update event
    let metadata_event = events
        .iter()
        .find(|e| e.attribute.ends_with("/core.update_metadata"));
    assert!(
        metadata_event.is_some(),
        "Should have metadata update event"
    );

    let metadata = &metadata_event.unwrap().value["metadata"];
    assert_eq!(metadata["external_root_path"], temp_path.to_str().unwrap());
}

// ============================================
// DirectoryImport - Authorization Tests
// ============================================

#[test]
fn test_import_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.import", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_import_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.import", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_import_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.import".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.import", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryExport - Payload Tests
// ============================================

#[test]
fn test_export_payload_deserialize() {
    let json = serde_json::json!({
        "target_path": "/Users/me/output/exported-project",
        "source_path": "src"
    });

    let result: Result<DirectoryExportPayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.target_path, "/Users/me/output/exported-project");
    assert_eq!(payload.source_path, Some("src".to_string()));
}

// ============================================
// DirectoryExport - Functionality Tests
// ============================================

#[test]
fn test_export_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.export")
        .expect("directory.export should be registered");

    // Create directory block with some entries
    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    block.contents = serde_json::json!({
        "entries": {
            "file1.md": {
                "id": "block-123",
                "type": "file"
            },
            "src/main.rs": {
                "id": "block-456",
                "type": "file"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.export".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "target_path": "/tmp/exported-project",
            "source_path": null
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one audit event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.export");

    // Verify audit event contains export parameters
    assert_eq!(events[0].value["target_path"], "/tmp/exported-project");
    assert_eq!(events[0].value["source_path"], serde_json::Value::Null);
}

// ============================================
// DirectoryExport - Authorization Tests
// ============================================

#[test]
fn test_export_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.export", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_export_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.export", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_export_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.export".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.export", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryCreate - Payload Tests
// ============================================

#[test]
fn test_create_payload_deserialize() {
    let json = serde_json::json!({
        "path": "docs/README.md",
        "type": "file",
        "source": "outline",
        "content": "# Hello World",
        "block_type": "markdown"
    });

    let result: Result<DirectoryCreatePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.path, "docs/README.md");
    assert_eq!(payload.entry_type, "file");
    assert_eq!(payload.source, "outline");
    assert_eq!(payload.content, Some("# Hello World".to_string()));
    assert_eq!(payload.block_type, Some("markdown".to_string()));
}

// ============================================
// DirectoryCreate - Functionality Tests
// ============================================

#[test]
fn test_create_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.create")
        .expect("directory.create should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "test.md",
            "type": "file",
            "source": "outline",
            "content": "Hello",
            "block_type": "markdown"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    // Should generate 2 events: core.create (for file block) + directory.write (update entries)
    assert_eq!(events.len(), 2, "Should generate two events");

    // Verify first event is core.create for the file
    assert!(events[0].attribute.ends_with("/core.create"));
    let file_block_val = &events[0].value;
    assert_eq!(file_block_val["name"], "test.md");
    assert_eq!(file_block_val["contents"]["source"], "outline");

    // Verify second event is directory.write
    assert_eq!(events[1].entity, block.block_id);
    assert!(events[1].attribute.ends_with("/directory.write"));
    let entries = events[1].value["contents"]["entries"].as_object().unwrap();
    assert!(entries.contains_key("test.md"));
    assert_eq!(entries["test.md"]["source"], "outline");
}

// ============================================
// DirectoryCreate - Authorization Tests
// ============================================

#[test]
fn test_create_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.create", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_create_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.create", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_create_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.create", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryDelete - Payload Tests
// ============================================

#[test]
fn test_delete_payload_deserialize() {
    let json = serde_json::json!({
        "path": "src/old_file.rs"
    });

    let result: Result<DirectoryDeletePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.path, "src/old_file.rs");
}

// ============================================
// DirectoryDelete - Functionality Tests
// ============================================

#[test]
fn test_delete_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.delete")
        .expect("directory.delete should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Setup: add a file entry to the directory
    block.contents = serde_json::json!({
        "entries": {
            "test.md": {
                "id": "file-block-123",
                "type": "file",
                "source": "outline",
                "updated_at": "2025-12-23T00:00:00Z"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "test.md"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    // Reference semantics: only generates directory.write event (removes entry reference)
    // The underlying Block (file-block-123) is NOT deleted - it continues to exist
    assert_eq!(
        events.len(),
        1,
        "Should generate one event (directory.write)"
    );

    // Verify event is directory.write
    assert_eq!(events[0].entity, block.block_id);
    assert!(events[0].attribute.ends_with("/directory.write"));
    let entries = events[0].value["contents"]["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("test.md"),
        "Entry reference should be removed from directory"
    );
}

// ============================================
// DirectoryDelete - Authorization Tests
// ============================================

#[test]
fn test_delete_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.delete", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_delete_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.delete", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_delete_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.delete", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryRename - Payload Tests
// ============================================

#[test]
fn test_rename_payload_deserialize() {
    let json = serde_json::json!({
        "old_path": "src/main.rs",
        "new_path": "src/index.rs"
    });

    let result: Result<DirectoryRenamePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.old_path, "src/main.rs");
    assert_eq!(payload.new_path, "src/index.rs");
}

// ============================================
// DirectoryRename - Functionality Tests
// ============================================

#[test]
fn test_rename_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.rename")
        .expect("directory.rename should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Setup: add a file entry to the directory
    block.contents = serde_json::json!({
        "entries": {
            "old.md": {
                "id": "file-block-456",
                "type": "file",
                "source": "outline",
                "updated_at": "2025-12-23T00:00:00Z"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "old.md",
            "new_path": "new.md"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    // Should generate 2 events: core.rename (for file block) + directory.write (update entries)
    assert_eq!(events.len(), 2, "Should generate two events");

    // Verify first event is core.rename for the file
    assert!(events[0].attribute.ends_with("/core.rename"));
    assert_eq!(events[0].entity, "file-block-456");
    assert_eq!(events[0].value["name"], "new.md");

    // Verify second event is directory.write
    assert_eq!(events[1].entity, block.block_id);
    assert!(events[1].attribute.ends_with("/directory.write"));
    let entries = events[1].value["contents"]["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("old.md"),
        "Old path should be removed"
    );
    assert!(entries.contains_key("new.md"), "New path should be added");
}

#[test]
fn test_rename_extension_change() {
    // This test verifies that renaming a file with a different extension
    // NO LONGER triggers a 'core.change_type' event automatically.
    // Frontend should detect extension changes and prompt the user.
    // Example: main.rs (code) -> main.md (still code type, user needs to manually change)
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.rename")
        .expect("directory.rename should be registered");

    let mut block = Block::new(
        "Test Directory".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "entries": {
            "main.rs": {
                "id": "block-code-1",
                "type": "file",
                "source": "outline",
                "updated_at": "2025-12-23T00:00:00Z"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "main.rs",
            "new_path": "main.md"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok());

    let events = result.unwrap();
    // Expected events (UPDATED):
    // 1. core.rename (name: main.md)
    // 2. directory.write (update entries)
    // NOTE: core.change_type is NO LONGER automatically generated
    assert_eq!(
        events.len(),
        2,
        "Should only generate core.rename and directory.write events"
    );

    // Verify core.rename event exists
    assert!(
        events
            .iter()
            .any(|e| e.attribute.ends_with("/core.rename") && e.value["name"] == "main.md"),
        "Should have core.rename event with updated name"
    );

    // Verify NO core.change_type event is generated
    assert!(
        !events
            .iter()
            .any(|e| e.attribute.ends_with("/core.change_type")),
        "Should NOT automatically generate core.change_type event"
    );

    // Verify directory.write event exists
    assert!(
        events
            .iter()
            .any(|e| e.attribute.ends_with("/directory.write")),
        "Should have directory.write event to update entries"
    );
}

// ============================================
// DirectoryRename - Authorization Tests
// ============================================

#[test]
fn test_rename_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.rename", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_rename_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.rename", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_rename_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.rename", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// Integration Workflow Test
// ============================================

#[test]
fn test_full_workflow() {
    // Complete workflow test: import → create → rename → delete
    use std::fs;
    use tempfile::TempDir;

    let registry = CapabilityRegistry::new();

    // Setup: Create temp directory with files
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path();
    fs::write(temp_path.join("initial.md"), "# Initial").unwrap();

    // Step 1: Import external directory
    let mut block = Block::new(
        "Workflow Test".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    block.contents = serde_json::json!({ "entries": {} });

    let import_cap = registry.get("directory.import").unwrap();
    let import_cmd = Command::new(
        "alice".to_string(),
        "directory.import".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "source_path": temp_path.to_str().unwrap(),
            "target_path": null
        }),
    );

    let import_events = import_cap.handler(&import_cmd, Some(&block)).unwrap();

    // Simulate StateProjector: apply directory.write event
    let dir_write = import_events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    block.contents = dir_write.value["contents"].clone();

    // Verify import worked
    let entries = block.contents["entries"].as_object().unwrap();
    assert!(
        entries.contains_key("initial.md"),
        "Should have imported initial.md"
    );

    // Step 2: Create new file in directory
    let create_cap = registry.get("directory.create").unwrap();
    let create_cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "new_file.md",
            "type": "file",
            "source": "outline",
            "content": "# New File",
            "block_type": "markdown"
        }),
    );

    let create_events = create_cap.handler(&create_cmd, Some(&block)).unwrap();

    // Apply events
    let dir_write = create_events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    block.contents = dir_write.value["contents"].clone();

    let entries = block.contents["entries"].as_object().unwrap();
    assert!(
        entries.contains_key("new_file.md"),
        "Should have created new_file.md"
    );

    // Step 3: Rename file
    let rename_cap = registry.get("directory.rename").unwrap();
    let rename_cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "new_file.md",
            "new_path": "renamed.md"
        }),
    );

    let rename_events = rename_cap.handler(&rename_cmd, Some(&block)).unwrap();

    // Apply events
    let dir_write = rename_events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    block.contents = dir_write.value["contents"].clone();

    let entries = block.contents["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("new_file.md"),
        "Old path should be gone"
    );
    assert!(entries.contains_key("renamed.md"), "New path should exist");

    // Step 4: Delete file
    let delete_cap = registry.get("directory.delete").unwrap();
    let delete_cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "renamed.md"
        }),
    );

    let delete_events = delete_cap.handler(&delete_cmd, Some(&block)).unwrap();

    // Apply events
    let dir_write = delete_events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    block.contents = dir_write.value["contents"].clone();

    let entries = block.contents["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("renamed.md"),
        "Deleted file should be gone"
    );
    assert!(
        entries.contains_key("initial.md"),
        "Other files should remain"
    );

    // Step 5: Export (audit only)
    let export_cap = registry.get("directory.export").unwrap();
    let export_cmd = Command::new(
        "alice".to_string(),
        "directory.export".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "target_path": "/tmp/export-test",
            "source_path": null
        }),
    );

    let export_events = export_cap.handler(&export_cmd, Some(&block)).unwrap();
    assert_eq!(export_events.len(), 1, "Export should generate audit event");
    assert_eq!(export_events[0].value["target_path"], "/tmp/export-test");
}

#[test]
fn test_security_path_traversal_create() {
    let registry = CapabilityRegistry::new();
    let cap = registry.get("directory.create").unwrap();
    let block = Block::new(
        "test".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Malicious path attempting traversal
    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "../evil.txt",
            "type": "file",
            "source": "outline"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_err(), "Should reject path traversal attempts");
    assert!(result.unwrap_err().contains("traversal forbidden"));
}

#[test]
fn test_security_path_matching_isolation() {
    let registry = CapabilityRegistry::new();
    let cap = registry.get("directory.delete").unwrap();

    // Create directory block with overlapping names
    let mut block = Block::new(
        "Isolation Test".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    block.contents = serde_json::json!({
        "entries": {
            "foo": {
                "id": "dir-foo",
                "type": "directory"
            },
            "foo/file.md": {
                "id": "block-foo-file",
                "type": "file"
            },
            "foobar": {
                "id": "block-foobar",
                "type": "file"
            }
        }
    });

    // Attempt to delete "foo"
    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "foo"
        }),
    );

    let events = cap.handler(&cmd, Some(&block)).unwrap();

    // Verify directory.write event
    let dir_write = events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    let new_entries = dir_write.value["contents"]["entries"].as_object().unwrap();

    // "foo" and its children should be gone
    assert!(!new_entries.contains_key("foo"));
    assert!(!new_entries.contains_key("foo/file.md"));

    // CRITICAL: "foobar" should remain untouched!
    assert!(
        new_entries.contains_key("foobar"),
        "Deleting 'foo' should NOT delete 'foobar'"
    );
}

#[test]
fn test_directory_delete_reference_semantics() {
    // This test explicitly verifies that directory.delete implements reference semantics:
    // 1. Removing an entry from a directory ONLY updates the directory's entry map
    // 2. It does NOT generate core.delete events for the referenced block
    // 3. The referenced block remains in existence (orphaned until GC)

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.delete")
        .expect("directory.delete should be registered");

    let mut block = Block::new(
        "Ref Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Setup: Directory references a block "block-shared-123"
    block.contents = serde_json::json!({
        "entries": {
            "shared.md": {
                "id": "block-shared-123",
                "type": "file",
                "source": "outline"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "shared.md"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok());

    let events = result.unwrap();

    // Assert 1: Should only generate directory.write
    assert_eq!(events.len(), 1, "Should generate exactly one event");
    assert!(
        events[0].attribute.ends_with("/directory.write"),
        "Event should be directory.write"
    );

    // Assert 2: CRITICAL - No core.delete events generated
    let has_delete_event = events.iter().any(|e| e.attribute.ends_with("/core.delete"));
    assert!(
        !has_delete_event,
        "Directory delete must NOT generate core.delete events (Reference Semantics violation!)"
    );

    // Assert 3: Entry removed from directory
    let entries = events[0].value["contents"]["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("shared.md"),
        "Entry should be removed from directory entries"
    );
}

// ============================================================================
// Tests for directory.rename_with_type_change (Atomic Rename + Type Change)
// ============================================================================

#[test]
fn test_rename_with_type_change_atomic() {
    // This test verifies that rename_with_type_change generates ALL events atomically:
    // 1. core.rename (update Block.name)
    // 2. core.change_type (update Block.block_type)
    // 3. directory.write (update directory entries)

    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.rename_with_type_change")
        .expect("directory.rename_with_type_change should be registered");

    // Setup: Directory with code.rs file
    let mut dir_block = Block::new(
        "Test Repo".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    let dir_id = dir_block.block_id.clone();
    dir_block.contents = serde_json::json!({
        "entries": {
            "code.rs": {
                "type": "file",
                "id": "file-1"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename_with_type_change".to_string(),
        dir_id.clone(),
        serde_json::json!({
            "old_path": "code.rs",
            "new_path": "notes.md",
            "file_extension": "md"
        }),
    );

    // Execute
    let result = cap.handler(&cmd, Some(&dir_block));

    // Verify
    assert!(
        result.is_ok(),
        "rename_with_type_change should succeed: {:?}",
        result
    );

    let events = result.unwrap();

    // Assert 1: Must generate exactly 3 events atomically
    assert_eq!(
        events.len(),
        3,
        "Should generate 3 events: core.rename + core.change_type + directory.write"
    );

    // Assert 2: Verify core.rename event
    let rename_event = events
        .iter()
        .find(|e| e.attribute.ends_with("/core.rename"));
    assert!(rename_event.is_some(), "Should have core.rename event");
    assert_eq!(
        rename_event.unwrap().entity,
        "file-1",
        "core.rename should target the file block"
    );
    assert_eq!(
        rename_event.unwrap().value["name"],
        "notes.md",
        "Should update name to notes.md"
    );

    // Assert 3: Verify core.change_type event
    let change_type_event = events
        .iter()
        .find(|e| e.attribute.ends_with("/core.change_type"));
    assert!(
        change_type_event.is_some(),
        "Should have core.change_type event"
    );
    assert_eq!(
        change_type_event.unwrap().entity,
        "file-1",
        "core.change_type should target the file block"
    );
    assert_eq!(
        change_type_event.unwrap().value["block_type"],
        "markdown",
        "Should infer block_type=markdown from extension=md"
    );

    // Assert 4: Verify directory.write event
    let write_event = events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"));
    assert!(write_event.is_some(), "Should have directory.write event");
    assert_eq!(
        write_event.unwrap().entity,
        dir_id,
        "directory.write should target the directory block"
    );

    let entries = write_event.unwrap().value["contents"]["entries"]
        .as_object()
        .unwrap();
    assert!(
        !entries.contains_key("code.rs"),
        "Old path should be removed"
    );
    assert!(
        entries.contains_key("notes.md"),
        "New path should be present"
    );
}

#[test]
fn test_rename_with_type_change_direct_type() {
    // Test direct block_type specification (not extension inference)

    let registry = CapabilityRegistry::new();
    let cap = registry.get("directory.rename_with_type_change").unwrap();

    // Setup
    let mut dir_block = Block::new(
        "Test Repo".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    let dir_id = dir_block.block_id.clone();
    dir_block.contents = serde_json::json!({
        "entries": {
            "file.txt": {
                "type": "file",
                "id": "file-1"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename_with_type_change".to_string(),
        dir_id,
        serde_json::json!({
            "old_path": "file.txt",
            "new_path": "script.py",
            "block_type": "code"  // Direct type specification
        }),
    );

    let result = cap.handler(&cmd, Some(&dir_block));

    // Verify
    assert!(result.is_ok());
    let events = result.unwrap();

    let change_type_event = events
        .iter()
        .find(|e| e.attribute.ends_with("/core.change_type"));
    assert!(change_type_event.is_some());
    assert_eq!(
        change_type_event.unwrap().value["block_type"],
        "code",
        "Should use directly specified block_type"
    );
}

#[test]
fn test_rename_with_type_change_no_type_change() {
    // Test rename without type change (neither block_type nor file_extension provided)

    let registry = CapabilityRegistry::new();
    let cap = registry.get("directory.rename_with_type_change").unwrap();

    // Setup
    let mut dir_block = Block::new(
        "Test Repo".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    let dir_id = dir_block.block_id.clone();
    dir_block.contents = serde_json::json!({
        "entries": {
            "file.md": {
                "type": "file",
                "id": "file-1"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename_with_type_change".to_string(),
        dir_id,
        serde_json::json!({
            "old_path": "file.md",
            "new_path": "notes.md"
            // No block_type or file_extension
        }),
    );

    let result = cap.handler(&cmd, Some(&dir_block));

    // Verify
    assert!(result.is_ok());
    let events = result.unwrap();

    // Should only generate 2 events: core.rename + directory.write (no core.change_type)
    assert_eq!(
        events.len(),
        2,
        "Should generate 2 events without type change"
    );

    let has_change_type = events
        .iter()
        .any(|e| e.attribute.ends_with("/core.change_type"));
    assert!(
        !has_change_type,
        "Should NOT generate core.change_type event"
    );
}

#[test]
fn test_rename_with_type_change_only_files() {
    // Verify that directories cannot use rename_with_type_change

    let registry = CapabilityRegistry::new();
    let cap = registry.get("directory.rename_with_type_change").unwrap();

    // Setup: Directory with subdirectory
    let mut dir_block = Block::new(
        "Test Repo".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    let dir_id = dir_block.block_id.clone();
    dir_block.contents = serde_json::json!({
        "entries": {
            "src": {
                "type": "directory"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename_with_type_change".to_string(),
        dir_id,
        serde_json::json!({
            "old_path": "src",
            "new_path": "lib",
            "block_type": "code"
        }),
    );

    let result = cap.handler(&cmd, Some(&dir_block));

    // Verify: Should fail for directories
    assert!(result.is_err());
    assert!(
        result
            .unwrap_err()
            .contains("Only files can use rename_with_type_change"),
        "Should reject directory renames"
    );
}
