//! Tests for Directory extension
//!
//! Generated by elfiee-ext-gen - Implement the TODO markers.
//!
//! Test categories included:
//! - Payload deserialization tests
//! - Basic capability functionality tests
//! - Authorization/CBAC tests
//! - Integration workflow tests

use super::*;
use crate::capabilities::grants::GrantsTable;
use crate::capabilities::registry::CapabilityRegistry;

use crate::models::{Block, Command};

// ============================================
// DirectoryImport - Payload Tests
// ============================================

#[test]
fn test_import_payload_deserialize() {
    let json = serde_json::json!({
        "source_path": "/Users/me/projects/my-app",
        "target_path": "libs/external"
    });

    let result: Result<DirectoryImportPayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.source_path, "/Users/me/projects/my-app");
    assert_eq!(payload.target_path, Some("libs/external".to_string()));
}

// ============================================
// DirectoryImport - Functionality Tests
// ============================================

#[test]
fn test_import_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.import")
        .expect("directory.import should be registered");

    // Create temporary directory with test files
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path();

    // Create test files
    fs::write(temp_path.join("file1.md"), "# Test File 1").unwrap();
    fs::write(temp_path.join("file2.rs"), "fn main() {}").unwrap();

    // Create subdirectory
    fs::create_dir(temp_path.join("subdir")).unwrap();
    fs::write(temp_path.join("subdir/file3.txt"), "content").unwrap();

    // Create directory block with empty entries
    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    block.contents = serde_json::json!({
        "entries": {}
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.import".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "source_path": temp_path.to_str().unwrap(),
            "target_path": null
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result
    );

    let events = result.unwrap();
    // Should generate: N × core.create + 1 × directory.write + 1 × core.update_metadata
    assert!(
        events.len() >= 3,
        "Should generate multiple events (core.create + directory.write + metadata update), got {}",
        events.len()
    );

    // Verify core.create events
    let create_events: Vec<_> = events
        .iter()
        .filter(|e| e.attribute.ends_with("/core.create"))
        .collect();
    assert!(create_events.len() >= 2, "Should create blocks for files");
    assert_eq!(create_events[0].value["contents"]["source"], "linked");

    // Verify directory.write event
    let write_event = events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"));
    assert!(write_event.is_some(), "Should have directory.write event");

    let write_event = write_event.unwrap();
    assert_eq!(write_event.value["contents"]["source"], "linked");
    let entries = write_event.value["contents"]["entries"]
        .as_object()
        .unwrap();
    assert!(
        entries.contains_key("file1.md"),
        "Should have file1.md entry"
    );
    assert_eq!(entries["file1.md"]["source"], "linked");

    // Verify metadata update event
    let metadata_event = events
        .iter()
        .find(|e| e.attribute.ends_with("/core.update_metadata"));
    assert!(
        metadata_event.is_some(),
        "Should have metadata update event"
    );

    let metadata = &metadata_event.unwrap().value["metadata"];
    assert_eq!(metadata["external_root_path"], temp_path.to_str().unwrap());
}

// ============================================
// DirectoryImport - Authorization Tests
// ============================================

#[test]
fn test_import_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.import", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_import_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.import", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_import_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.import".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.import", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryExport - Payload Tests
// ============================================

#[test]
fn test_export_payload_deserialize() {
    let json = serde_json::json!({
        "target_path": "/Users/me/output/exported-project",
        "source_path": "src"
    });

    let result: Result<DirectoryExportPayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.target_path, "/Users/me/output/exported-project");
    assert_eq!(payload.source_path, Some("src".to_string()));
}

// ============================================
// DirectoryExport - Functionality Tests
// ============================================

#[test]
fn test_export_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.export")
        .expect("directory.export should be registered");

    // Create directory block with some entries
    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    block.contents = serde_json::json!({
        "entries": {
            "file1.md": {
                "id": "block-123",
                "type": "file"
            },
            "src/main.rs": {
                "id": "block-456",
                "type": "file"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.export".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "target_path": "/tmp/exported-project",
            "source_path": null
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result
    );

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one audit event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/directory.export");

    // Verify audit event contains export parameters
    assert_eq!(events[0].value["target_path"], "/tmp/exported-project");
    assert_eq!(events[0].value["source_path"], serde_json::Value::Null);
}

// ============================================
// DirectoryExport - Authorization Tests
// ============================================

#[test]
fn test_export_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.export", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_export_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.export", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_export_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.export".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.export", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryCreate - Payload Tests
// ============================================

#[test]
fn test_create_payload_deserialize() {
    let json = serde_json::json!({
        "path": "docs/README.md",
        "type": "file",
        "source": "outline",
        "content": "# Hello World",
        "block_type": "markdown"
    });

    let result: Result<DirectoryCreatePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.path, "docs/README.md");
    assert_eq!(payload.entry_type, "file");
    assert_eq!(payload.source, "outline");
    assert_eq!(payload.content, Some("# Hello World".to_string()));
    assert_eq!(payload.block_type, Some("markdown".to_string()));
}

// ============================================
// DirectoryCreate - Functionality Tests
// ============================================

#[test]
fn test_create_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.create")
        .expect("directory.create should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "test.md",
            "type": "file",
            "source": "outline",
            "content": "Hello",
            "block_type": "markdown"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    // Should generate 2 events: core.create (for file block) + directory.write (update entries)
    assert_eq!(events.len(), 2, "Should generate two events");

    // Verify first event is core.create for the file
    assert!(events[0].attribute.ends_with("/core.create"));
    let file_block_val = &events[0].value;
    assert_eq!(file_block_val["name"], "test.md");
    assert_eq!(file_block_val["contents"]["source"], "outline");

    // Verify second event is directory.write
    assert_eq!(events[1].entity, block.block_id);
    assert!(events[1].attribute.ends_with("/directory.write"));
    let entries = events[1].value["contents"]["entries"].as_object().unwrap();
    assert!(entries.contains_key("test.md"));
    assert_eq!(entries["test.md"]["source"], "outline");
}

// ============================================
// DirectoryCreate - Authorization Tests
// ============================================

#[test]
fn test_create_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.create", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_create_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.create", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_create_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.create", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryDelete - Payload Tests
// ============================================

#[test]
fn test_delete_payload_deserialize() {
    let json = serde_json::json!({
        "path": "src/old_file.rs"
    });

    let result: Result<DirectoryDeletePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.path, "src/old_file.rs");
}

// ============================================
// DirectoryDelete - Functionality Tests
// ============================================

#[test]
fn test_delete_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.delete")
        .expect("directory.delete should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Setup: add a file entry to the directory
    block.contents = serde_json::json!({
        "entries": {
            "test.md": {
                "id": "file-block-123",
                "type": "file",
                "source": "outline",
                "updated_at": "2025-12-23T00:00:00Z"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "test.md"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    // Should generate 2 events: core.delete (for file block) + directory.write (update entries)
    assert_eq!(events.len(), 2, "Should generate two events");

    // Verify first event is core.delete for the file
    assert!(events[0].attribute.ends_with("/core.delete"));
    assert_eq!(events[0].entity, "file-block-123");

    // Verify second event is directory.write
    assert_eq!(events[1].entity, block.block_id);
    assert!(events[1].attribute.ends_with("/directory.write"));
    let entries = events[1].value["contents"]["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("test.md"),
        "File should be removed from entries"
    );
}

// ============================================
// DirectoryDelete - Authorization Tests
// ============================================

#[test]
fn test_delete_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.delete", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_delete_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.delete", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_delete_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.delete", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// DirectoryRename - Payload Tests
// ============================================

#[test]
fn test_rename_payload_deserialize() {
    let json = serde_json::json!({
        "old_path": "src/main.rs",
        "new_path": "src/index.rs"
    });

    let result: Result<DirectoryRenamePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.old_path, "src/main.rs");
    assert_eq!(payload.new_path, "src/index.rs");
}

// ============================================
// DirectoryRename - Functionality Tests
// ============================================

#[test]
fn test_rename_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.rename")
        .expect("directory.rename should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Setup: add a file entry to the directory
    block.contents = serde_json::json!({
        "entries": {
            "old.md": {
                "id": "file-block-456",
                "type": "file",
                "source": "outline",
                "updated_at": "2025-12-23T00:00:00Z"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "old.md",
            "new_path": "new.md"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(
        result.is_ok(),
        "Handler should execute successfully: {:?}",
        result.err()
    );

    let events = result.unwrap();
    // Should generate 2 events: core.rename (for file block) + directory.write (update entries)
    assert_eq!(events.len(), 2, "Should generate two events");

    // Verify first event is core.rename for the file
    assert!(events[0].attribute.ends_with("/core.rename"));
    assert_eq!(events[0].entity, "file-block-456");
    assert_eq!(events[0].value["name"], "new.md");

    // Verify second event is directory.write
    assert_eq!(events[1].entity, block.block_id);
    assert!(events[1].attribute.ends_with("/directory.write"));
    let entries = events[1].value["contents"]["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("old.md"),
        "Old path should be removed"
    );
    assert!(entries.contains_key("new.md"), "New path should be added");
}

#[test]
fn test_rename_extension_change() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("directory.rename")
        .expect("directory.rename should be registered");

    let mut block = Block::new(
        "Test Directory".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    block.contents = serde_json::json!({
        "entries": {
            "main.rs": {
                "id": "block-code-1",
                "type": "file",
                "source": "outline",
                "updated_at": "2025-12-23T00:00:00Z"
            }
        }
    });

    let cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "main.rs",
            "new_path": "main.md"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok());

    let events = result.unwrap();
    // Expected events:
    // 1. core.rename (name: main.md)
    // 2. core.change_type (block_type: markdown)
    // 3. directory.write (update entries)
    assert_eq!(events.len(), 3);

    assert!(events
        .iter()
        .any(|e| e.attribute.ends_with("/core.rename") && e.value["name"] == "main.md"));
    assert!(
        events
            .iter()
            .any(|e| e.attribute.ends_with("/core.change_type")
                && e.value["block_type"] == "markdown")
    );
}

// ============================================
// DirectoryRename - Authorization Tests
// ============================================

#[test]
fn test_rename_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "directory.rename", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_rename_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.rename", &block.block_id);

    assert!(
        !is_authorized,
        "Non-owner without grant should not be authorized"
    );
}

#[test]
fn test_rename_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
    );

    let is_authorized =
        block.owner == "bob" || grants_table.has_grant("bob", "directory.rename", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}

// ============================================
// Integration Workflow Test
// ============================================

#[test]
fn test_full_workflow() {
    // Complete workflow test: import → create → rename → delete
    use std::fs;
    use tempfile::TempDir;

    let registry = CapabilityRegistry::new();

    // Setup: Create temp directory with files
    let temp_dir = TempDir::new().unwrap();
    let temp_path = temp_dir.path();
    fs::write(temp_path.join("initial.md"), "# Initial").unwrap();

    // Step 1: Import external directory
    let mut block = Block::new(
        "Workflow Test".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    block.contents = serde_json::json!({ "entries": {} });

    let import_cap = registry.get("directory.import").unwrap();
    let import_cmd = Command::new(
        "alice".to_string(),
        "directory.import".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "source_path": temp_path.to_str().unwrap(),
            "target_path": null
        }),
    );

    let import_events = import_cap.handler(&import_cmd, Some(&block)).unwrap();

    // Simulate StateProjector: apply directory.write event
    let dir_write = import_events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    block.contents = dir_write.value["contents"].clone();

    // Verify import worked
    let entries = block.contents["entries"].as_object().unwrap();
    assert!(
        entries.contains_key("initial.md"),
        "Should have imported initial.md"
    );

    // Step 2: Create new file in directory
    let create_cap = registry.get("directory.create").unwrap();
    let create_cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "new_file.md",
            "type": "file",
            "source": "outline",
            "content": "# New File",
            "block_type": "markdown"
        }),
    );

    let create_events = create_cap.handler(&create_cmd, Some(&block)).unwrap();

    // Apply events
    let dir_write = create_events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    block.contents = dir_write.value["contents"].clone();

    let entries = block.contents["entries"].as_object().unwrap();
    assert!(
        entries.contains_key("new_file.md"),
        "Should have created new_file.md"
    );

    // Step 3: Rename file
    let rename_cap = registry.get("directory.rename").unwrap();
    let rename_cmd = Command::new(
        "alice".to_string(),
        "directory.rename".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "old_path": "new_file.md",
            "new_path": "renamed.md"
        }),
    );

    let rename_events = rename_cap.handler(&rename_cmd, Some(&block)).unwrap();

    // Apply events
    let dir_write = rename_events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    block.contents = dir_write.value["contents"].clone();

    let entries = block.contents["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("new_file.md"),
        "Old path should be gone"
    );
    assert!(entries.contains_key("renamed.md"), "New path should exist");

    // Step 4: Delete file
    let delete_cap = registry.get("directory.delete").unwrap();
    let delete_cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "renamed.md"
        }),
    );

    let delete_events = delete_cap.handler(&delete_cmd, Some(&block)).unwrap();

    // Apply events
    let dir_write = delete_events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    block.contents = dir_write.value["contents"].clone();

    let entries = block.contents["entries"].as_object().unwrap();
    assert!(
        !entries.contains_key("renamed.md"),
        "Deleted file should be gone"
    );
    assert!(
        entries.contains_key("initial.md"),
        "Other files should remain"
    );

    // Step 5: Export (audit only)
    let export_cap = registry.get("directory.export").unwrap();
    let export_cmd = Command::new(
        "alice".to_string(),
        "directory.export".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "target_path": "/tmp/export-test",
            "source_path": null
        }),
    );

    let export_events = export_cap.handler(&export_cmd, Some(&block)).unwrap();
    assert_eq!(export_events.len(), 1, "Export should generate audit event");
    assert_eq!(export_events[0].value["target_path"], "/tmp/export-test");
}

#[test]
fn test_security_path_traversal_create() {
    let registry = CapabilityRegistry::new();
    let cap = registry.get("directory.create").unwrap();
    let block = Block::new(
        "test".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );

    // Malicious path attempting traversal
    let cmd = Command::new(
        "alice".to_string(),
        "directory.create".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "../evil.txt",
            "type": "file",
            "source": "outline"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_err(), "Should reject path traversal attempts");
    assert!(result.unwrap_err().contains("traversal forbidden"));
}

#[test]
fn test_security_path_matching_isolation() {
    let registry = CapabilityRegistry::new();
    let cap = registry.get("directory.delete").unwrap();

    // Create directory block with overlapping names
    let mut block = Block::new(
        "Isolation Test".to_string(),
        "directory".to_string(),
        "alice".to_string(),
    );
    block.contents = serde_json::json!({
        "entries": {
            "foo": {
                "id": "dir-foo",
                "type": "directory"
            },
            "foo/file.md": {
                "id": "block-foo-file",
                "type": "file"
            },
            "foobar": {
                "id": "block-foobar",
                "type": "file"
            }
        }
    });

    // Attempt to delete "foo"
    let cmd = Command::new(
        "alice".to_string(),
        "directory.delete".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "path": "foo"
        }),
    );

    let events = cap.handler(&cmd, Some(&block)).unwrap();

    // Verify directory.write event
    let dir_write = events
        .iter()
        .find(|e| e.attribute.ends_with("/directory.write"))
        .unwrap();
    let new_entries = dir_write.value["contents"]["entries"].as_object().unwrap();

    // "foo" and its children should be gone
    assert!(!new_entries.contains_key("foo"));
    assert!(!new_entries.contains_key("foo/file.md"));

    // CRITICAL: "foobar" should remain untouched!
    assert!(
        new_entries.contains_key("foobar"),
        "Deleting 'foo' should NOT delete 'foobar'"
    );
}
