/// Capability: write
///
/// Generated by elfiee-ext-gen - Implement the logic below

use super::TerminalWritePayload;
use crate::capabilities::core::{create_event, CapResult};
use crate::models::{Block, Command, Event};
use capability_macros::capability;

/// Handler for terminal.write capability.
///
/// Writes content directly to the terminal. This is typically used for
/// displaying messages or output in the terminal without executing commands.
///
/// # Arguments
/// * `cmd` - The command containing the payload with content to write
/// * `block` - Optional block to operate on
///
/// # Returns
/// * `Ok(Vec<Event>)` - Events to be committed
/// * `Err(String)` - Error description
///
#[capability(id = "terminal.write", target = "terminal")]
pub(crate) fn handle_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    let block = block.ok_or("Block required for terminal.write")?;

    // Deserialize payload
    let payload: TerminalWritePayload = serde_json::from_value(cmd.payload.clone())
        .map_err(|e| format!("Invalid payload for terminal.write: {}", e))?;

    // Preserve existing contents
    let mut new_contents = if let Some(obj) = block.contents.as_object() {
        obj.clone()
    } else {
        serde_json::Map::new()
    };

    // Check if this is a save operation
    if let Some(saved_content) = payload.saved_content {
        // Save operation: store the terminal content and metadata
        new_contents.insert("saved_content".to_string(), serde_json::json!(saved_content));
        
        if let Some(saved_at) = payload.saved_at {
            new_contents.insert("saved_at".to_string(), serde_json::json!(saved_at));
        }
        
        if let Some(current_dir) = payload.current_directory {
            new_contents.insert("current_directory".to_string(), serde_json::json!(current_dir));
        }
    } else if let Some(data) = payload.data {
        // Regular write operation: append to history
        let text_content = if let Some(text) = data.as_str() {
            text.to_string()
        } else {
            data.to_string()
        };

        // Extract existing history or create new
        let mut history = new_contents
            .get("history")
            .and_then(|h| h.as_array())
            .map(|arr| arr.iter().cloned().collect::<Vec<_>>())
            .unwrap_or_default();

        // Create new history entry for the written content
        let history_entry = serde_json::json!({
            "command": "", // No command, this is direct output
            "output": text_content,
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "exit_code": 0,
            "type": "write" // Mark as written content vs command output
        });

        history.push(history_entry);
        new_contents.insert("history".to_string(), serde_json::json!(history));
    } else {
        return Err("Invalid payload: either 'data' or 'saved_content' must be provided".to_string());
    }

    // Create event
    let event = create_event(
        block.block_id.clone(),
        "terminal.write",
        serde_json::json!({ "contents": new_contents }),
        &cmd.editor_id,
        1, // Placeholder - engine actor updates with correct count
    );

    Ok(vec![event])
}
