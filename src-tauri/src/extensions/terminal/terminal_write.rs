/// Capability: write
///
/// Generated by elfiee-ext-gen - Implement the logic below

use super::TerminalWritePayload;
use crate::capabilities::core::{create_event, CapResult};
use crate::models::{Block, Command, Event};
use capability_macros::capability;

/// Handler for terminal.write capability.
///
/// Writes content directly to the terminal. This is typically used for
/// displaying messages or output in the terminal without executing commands.
///
/// # Arguments
/// * `cmd` - The command containing the payload with content to write
/// * `block` - Optional block to operate on
///
/// # Returns
/// * `Ok(Vec<Event>)` - Events to be committed
/// * `Err(String)` - Error description
///
#[capability(id = "terminal.write", target = "terminal")]
pub(crate) fn handle_write(cmd: &Command, block: Option<&Block>) -> CapResult<Vec<Event>> {
    let block = block.ok_or("Block required for terminal.write")?;

    // Deserialize payload
    let payload: TerminalWritePayload = serde_json::from_value(cmd.payload.clone())
        .map_err(|e| format!("Invalid payload for terminal.write: {}", e))?;

    // Preserve existing contents
    let mut new_contents = if let Some(obj) = block.contents.as_object() {
        obj.clone()
    } else {
        serde_json::Map::new()
    };

    // Check if this is a save operation
    let is_save_operation = payload.saved_content.is_some();
    
    if let Some(saved_content) = payload.saved_content {
        // Save operation: store the terminal content and metadata
        new_contents.insert("saved_content".to_string(), serde_json::json!(saved_content));
        
        if let Some(saved_at) = payload.saved_at {
            new_contents.insert("saved_at".to_string(), serde_json::json!(saved_at));
        }
        
        if let Some(current_dir) = payload.current_directory {
            new_contents.insert("current_directory".to_string(), serde_json::json!(current_dir));
        }
    }

    // Handle additional terminal state fields
    if let Some(root_path) = payload.root_path {
        new_contents.insert("root_path".to_string(), serde_json::json!(root_path));
    }
    
    if let Some(current_path) = payload.current_path {
        new_contents.insert("current_path".to_string(), serde_json::json!(current_path));
    }
    
    if let Some(latest_snapshot_block_id) = payload.latest_snapshot_block_id {
        new_contents.insert("latest_snapshot_block_id".to_string(), serde_json::json!(latest_snapshot_block_id));
    }
    
    // Handle regular write operation (only if data is provided and no save operation)
    if let Some(data) = payload.data {
        if !is_save_operation {
            // Regular write operation: append to history
            let text_content = if let Some(text) = data.as_str() {
                text.to_string()
            } else {
                data.to_string()
            };

            // Extract existing history or create new
            let mut history = new_contents
                .get("history")
                .and_then(|h| h.as_array())
                .map(|arr| arr.iter().cloned().collect::<Vec<_>>())
                .unwrap_or_default();

            // Create new history entry for the written content
            let history_entry = serde_json::json!({
                "command": "", // No command, this is direct output
                "output": text_content,
                "timestamp": chrono::Utc::now().to_rfc3339(),
                "exit_code": 0,
                "type": "write" // Mark as written content vs command output
            });

            history.push(history_entry);
            new_contents.insert("history".to_string(), serde_json::json!(history));
        }
    }

    // Create event
    let event = create_event(
        block.block_id.clone(),
        "terminal.write",
        serde_json::json!({ "contents": new_contents }),
        &cmd.editor_id,
        1, // Placeholder - engine actor updates with correct count
    );

    Ok(vec![event])
}
