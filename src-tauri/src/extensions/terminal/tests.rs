//! Tests for Terminal extension
//!
//! Generated by elfiee-ext-gen - Implement the TODO markers.
//!
//! Test categories included:
//! - Payload deserialization tests
//! - Basic capability functionality tests
//! - Authorization/CBAC tests
//! - Integration workflow tests


use super::*;
use crate::capabilities::registry::CapabilityRegistry;
use crate::capabilities::grants::GrantsTable;

use crate::models::{Block, Command};
use uuid::Uuid;

fn platform_command(unix_command: &str, windows_command: &str) -> String {
    if cfg!(target_os = "windows") {
        windows_command.to_string()
    } else {
        unix_command.to_string()
    }
}


// ============================================
// TerminalRead - Payload Tests
// ============================================

#[test]
fn test_read_payload_deserialize() {
    // TerminalReadPayload has no fields, so empty JSON should work
    let json = serde_json::json!({});

    let result: Result<TerminalReadPayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let _payload = result.unwrap();
    // No fields to verify since it's an empty struct
}

// ============================================
// TerminalRead - Functionality Tests
// ============================================

#[test]
fn test_read_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.read")
        .expect("terminal.read should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.read".to_string(),
        block.block_id.clone(),
        serde_json::json!({}), // Empty payload for read operation
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Handler should execute successfully");

    let events = result.unwrap();
    // Read operation doesn't generate events, just returns empty vec
    assert_eq!(events.len(), 0, "Read should not generate events");
}


// ============================================
// TerminalRead - Authorization Tests
// ============================================

#[test]
fn test_read_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "terminal.read", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_read_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "terminal.read", &block.block_id);

    assert!(!is_authorized, "Non-owner without grant should not be authorized");
}

#[test]
fn test_read_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "terminal.read".to_string(),
        block.block_id.clone(),
    );

    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "terminal.read", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}



// ============================================
// TerminalWrite - Payload Tests
// ============================================

#[test]
fn test_write_payload_deserialize() {
    let json = serde_json::json!({
        "data": "Hello terminal!"
    });

    let result: Result<TerminalWritePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.data, Some(serde_json::json!("Hello terminal!")));
}

// ============================================
// TerminalWrite - Functionality Tests
// ============================================

#[test]
fn test_write_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.write")
        .expect("terminal.write should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "data": "Hello terminal!"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Handler should execute successfully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/terminal.write");

    // Verify the event contains the updated history
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["output"], "Hello terminal!");
    assert_eq!(history[0]["type"], "write");
}


// ============================================
// TerminalWrite - Authorization Tests
// ============================================

#[test]
fn test_write_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "terminal.write", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_write_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "terminal.write", &block.block_id);

    assert!(!is_authorized, "Non-owner without grant should not be authorized");
}

#[test]
fn test_write_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
    );

    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "terminal.write", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}




// ============================================
// TerminalExecute - Tests
// ============================================

#[test]
fn test_execute_payload_deserialize() {
    let json = serde_json::json!({
        "command": "echo hello"
    });

    let result: Result<TerminalExecutePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.command, "echo hello");
}

#[test]
fn test_execute_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo hello world"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Handler should execute successfully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/terminal.execute");

    // Verify the event contains the command and output in history
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], "echo hello world");
    assert!(history[0]["output"].as_str().unwrap().contains("hello world"));
}

// ============================================
// Integration Workflow Test
// ============================================

#[test]
fn test_full_workflow() {
    let registry = CapabilityRegistry::new();
    let mut block = Block::new(
        "Workflow Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Step 1: Execute a command
    let execute_cap = registry.get("terminal.execute").unwrap();
    let execute_cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo 'test command'"
        }),
    );

    let execute_events = execute_cap.handler(&execute_cmd, Some(&block)).unwrap();
    assert_eq!(execute_events.len(), 1);

    // Step 2: Update block state (simulate StateProjector)
    block.contents = execute_events[0].value.get("contents").unwrap().clone();

    // Step 3: Write additional content to the terminal
    let write_cap = registry.get("terminal.write").unwrap();
    let write_cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "data": "Additional output from application"
        }),
    );

    let write_events = write_cap.handler(&write_cmd, Some(&block)).unwrap();
    assert_eq!(write_events.len(), 1);

    // Step 4: Verify final state has both entries
    let final_contents = write_events[0].value.get("contents").unwrap();
    let final_history = final_contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(final_history.len(), 2);
    // First entry from execute command
    assert_eq!(final_history[0]["command"], "echo 'test command'");
    assert!(final_history[0]["output"].as_str().unwrap().contains("test command"));
    
    // Second entry from write operation
    assert_eq!(final_history[1]["output"], "Additional output from application");
    assert_eq!(final_history[1]["type"], "write");
    assert_eq!(final_history[1]["command"], "");
}

// ============================================
// Additional Terminal Execute Tests
// ============================================

#[test]
fn test_execute_pwd_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "PWD Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "pwd"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "PWD command should execute successfully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1);
    
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], "pwd");
    assert_eq!(history[0]["exit_code"], 0);
    // PWD should return some path
    assert!(history[0]["output"].as_str().unwrap().len() > 0);
}

#[test]
fn test_execute_command_length_validation() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Length Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Create a command longer than 10000 characters
    let long_command = "echo ".to_string() + &"a".repeat(10000);

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": long_command
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_err(), "Long command should be rejected");
    
    let error = result.unwrap_err();
    assert!(error.contains("Command too long"), "Error should mention command length");
}

#[test]
fn test_execute_empty_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Empty Command Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": ""
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Empty command should be handled gracefully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1);
    
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], "");
    assert_eq!(history[0]["exit_code"], 0);
    assert_eq!(history[0]["output"], "");
}

#[test]
fn test_execute_without_block() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        "dummy-block-id".to_string(),
        serde_json::json!({
            "command": "echo test"
        }),
    );

    let result = cap.handler(&cmd, None);
    assert!(result.is_err(), "Command without block should fail");
    
    let error = result.unwrap_err();
    assert_eq!(error, "Block required for terminal.execute");
}

#[test]
fn test_execute_history_preservation() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    // Create a block with existing history
    let mut block = Block::new(
        "History Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );
    
    block.contents = serde_json::json!({
        "history": [
            {
                "command": "echo first",
                "output": "first",
                "timestamp": "2024-01-01T00:00:00Z",
                "exit_code": 0
            }
        ],
        "root_path": ".",
        "current_path": ".",
        "current_directory": "."
    });

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo second"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    // Should have both old and new commands
    assert_eq!(history.len(), 2);
    
    // First command should be preserved
    assert_eq!(history[0]["command"], "echo first");
    assert_eq!(history[0]["output"], "first");
    
    // Second command should be appended
    assert_eq!(history[1]["command"], "echo second");
    assert!(history[1]["output"].as_str().unwrap().contains("second"));
}

// ============================================
// Non-Interactive Commands Tests
// ============================================

#[test]
fn test_execute_ls_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let mut block = Block::new(
        "LS Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );
    
    // Set up a block directory with some test files
    block.contents = serde_json::json!({
        "root_path": ".",
        "current_path": ".",
        "current_directory": ".",
        "history": []
    });

    let command = platform_command("ls", "dir");
    let payload = serde_json::json!({ "command": command.clone() });
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        payload,
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "LS command should execute successfully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1);
    
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], command);
    assert_eq!(history[0]["exit_code"], 0);
    // ls should return some output (file listings)
    assert!(history[0]["output"].as_str().is_some());
}

#[test]
fn test_execute_echo_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Echo Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo \"Hello Terminal!\""
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Echo command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], "echo \"Hello Terminal!\"");
    assert_eq!(history[0]["exit_code"], 0);
    assert!(history[0]["output"].as_str().unwrap().contains("Hello Terminal!"));
}

#[test]
fn test_execute_mkdir_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Mkdir Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let command = platform_command(
        "mkdir -p terminal_test_dir",
        r#"powershell -Command "New-Item -ItemType Directory -Path 'terminal_test_dir' -Force; exit 0""#,
    );
    let payload = serde_json::json!({ "command": command.clone() });
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        payload,
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Mkdir command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], command);
    // mkdir typically returns exit code 0 on success
    assert_eq!(history[0]["exit_code"], 0);
}

#[test]
fn test_execute_touch_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Touch Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let command = platform_command(
        "touch terminal_test_file.txt",
        "type nul > terminal_test_file.txt",
    );
    let payload = serde_json::json!({ "command": command.clone() });
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        payload,
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Touch command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], command);
    assert_eq!(history[0]["exit_code"], 0);
}

#[test]
fn test_execute_cat_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Cat Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Test cat on a non-existent file (should fail)
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "cat nonexistent.txt"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Cat command should execute (but may fail)");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], "cat nonexistent.txt");
    // Should fail with exit code != 0 for non-existent file
    assert_ne!(history[0]["exit_code"], 0);
    assert!(history[0]["output"].as_str().unwrap().len() > 0); // Should have error message
}

#[test]
fn test_execute_grep_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Grep Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Test grep on current directory (should work even if no matches)
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "grep \"test\" *.txt || echo \"no matches found\""
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Grep command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert!(history[0]["command"].as_str().unwrap().contains("grep"));
    // Command should complete (exit code may vary based on matches)
    assert!(history[0].get("exit_code").is_some());
}

#[test]
fn test_execute_find_command() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Find Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let command = platform_command(
        r#"find . -name "*.txt" -type f"#,
        r#"dir /s /b *.txt"#,
    );
    let payload = serde_json::json!({ "command": command.clone() });
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        payload,
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Find command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], command);
    assert_eq!(history[0]["exit_code"], 0);
    // find should return paths or empty output
    assert!(history[0]["output"].as_str().is_some());
}

#[test]
fn test_execute_head_tail_commands() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let mut block = Block::new(
        "Head/Tail Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );
    
    block.contents = serde_json::json!({
        "root_path": ".",
        "current_path": ".",
        "current_directory": ".",
        "history": []
    });

    // Test head command (should work even on non-existent file, just return error)
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "head -n 5 nonexistent.txt || echo \"head completed\""
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Head command should execute");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert!(history[0]["command"].as_str().unwrap().contains("head"));
    assert!(history[0].get("exit_code").is_some());
    assert!(history[0]["output"].as_str().is_some());
}

#[test]
fn test_execute_multiple_commands_sequence() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let mut block = Block::new(
        "Multi Command Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );
    
    block.contents = serde_json::json!({
        "root_path": ".",
        "current_path": ".",
        "current_directory": ".",
        "history": []
    });

    // Test command sequence with && operator
    let command = platform_command(
        "echo \"first\" && echo \"second\" && pwd",
        "echo first && echo second && cd",
    );
    let payload = serde_json::json!({ "command": command.clone() });
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        payload,
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Multi-command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], command);
    assert_eq!(history[0]["exit_code"], 0);
    
    let output = history[0]["output"].as_str().unwrap();
    assert!(output.contains("first"));
    assert!(output.contains("second"));
    // Should also contain the pwd output (current directory path)
    assert!(output.len() > 10); // pwd should add substantial output
}

#[test]
fn test_execute_command_with_special_characters() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Special Chars Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Test echo with special characters and escaping
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo \"Hello $USER! Today is $(date +%Y-%m-%d) & it's great!\""
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Command with special characters should execute");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert!(history[0]["command"].as_str().unwrap().contains("Hello"));
    assert_eq!(history[0]["exit_code"], 0);
    assert!(history[0]["output"].as_str().unwrap().contains("Hello"));
}

#[test]
fn test_execute_pipe_operations() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Pipe Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Test command with pipes
    let command = platform_command(
        "echo \"line1\\nline2\\nline3\" | grep \"line2\"",
        r#"powershell -Command "Write-Output 'line1'; Write-Output 'line2'; Write-Output 'line3' | Select-String 'line2'; exit 0""#,
    );
    let payload = serde_json::json!({ "command": command.clone() });
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        payload,
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Pipe command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], command);
    assert_eq!(history[0]["exit_code"], 0);
    assert!(history[0]["output"].as_str().unwrap().contains("line2"));
}

// ============================================
// æ–‡ä»¶æ“ä½œæ£€æµ‹æµ‹è¯• - æ–°éœ€æ±‚
// ============================================

#[test]
fn test_file_operation_detection_mkdir() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "File Op Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let dir_name = format!("terminal_test_dir_{}", Uuid::new_v4().simple());
    let command = format!("mkdir {}", dir_name);

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": command.clone()
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Mkdir command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    
    // æ£€æŸ¥æ˜¯å¦æ ‡è®°äº†éœ€è¦æ–‡ä»¶åŒæ­¥
    assert!(contents.get("needs_file_sync").is_some());
    assert_eq!(contents.get("needs_file_sync").unwrap().as_bool(), Some(true));
    assert_eq!(
        contents.get("file_operation_command").unwrap().as_str().unwrap(),
        command
    );
}

#[test]
fn test_file_operation_detection_touch() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Touch Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let file_name = format!("terminal_test_file_{}.txt", Uuid::new_v4().simple());
    let command = platform_command(
        &format!("touch {}", file_name),
        &format!("type nul > {}", file_name),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": command.clone()
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Touch command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    
    // æ£€æŸ¥æ˜¯å¦æ ‡è®°äº†éœ€è¦æ–‡ä»¶åŒæ­¥
    assert!(contents.get("needs_file_sync").is_some());
    assert_eq!(contents.get("needs_file_sync").unwrap().as_bool(), Some(true));
    assert_eq!(
        contents.get("file_operation_command").unwrap().as_str().unwrap(),
        command
    );
}

#[test]
fn test_file_operation_detection_echo_redirect() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Echo Redirect Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo \"hello world\" > output.txt"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Echo redirect command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    
    // æ£€æŸ¥æ˜¯å¦æ ‡è®°äº†éœ€è¦æ–‡ä»¶åŒæ­¥
    assert!(contents.get("needs_file_sync").is_some());
    assert_eq!(contents.get("needs_file_sync").unwrap().as_bool(), Some(true));
    assert_eq!(
        contents.get("file_operation_command").unwrap().as_str().unwrap(),
        "echo \"hello world\" > output.txt"
    );
}

#[test]
fn test_non_file_operation_no_sync_flag() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Non-File Op Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo \"hello world\""
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Echo command should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let contents_obj = contents
        .as_object()
        .expect("contents should be an object");
    
    // éæ–‡ä»¶æ“ä½œå‘½ä»¤ä¸åº”è¯¥æ ‡è®°éœ€è¦æ–‡ä»¶åŒæ­¥
    assert!(!contents_obj.contains_key("needs_file_sync"));
    assert!(!contents_obj.contains_key("file_operation_command"));
}

// ============================================
// æ–‡ä»¶æ“ä½œæ£€æµ‹å‡½æ•°è¯¦ç»†æµ‹è¯•
// ============================================

#[test]
fn test_file_operation_detection_comprehensive() {
    use crate::extensions::terminal::terminal_execute::is_file_operation_command;
    
    // æµ‹è¯•å„ç§æ–‡ä»¶æ“ä½œå‘½ä»¤
    let file_ops = vec![
        "mkdir test_dir",
        "MKDIR test_dir", // å¤§å°å†™ä¸æ•æ„Ÿ
        "touch file.txt",
        "rm file.txt",
        "rmdir directory",
        "mv old.txt new.txt",
        "cp source.txt dest.txt",
        "vi filename.txt",
        "vim filename.txt", 
        "nano filename.txt",
        "chmod 755 file.txt",
        "chown user:group file.txt",
        "chgrp group file.txt",
        "echo \"content\" > file.txt",    // é‡å®šå‘è¾“å‡º
        "echo \"content\" >> file.txt",   // è¿½åŠ è¾“å‡º
        "cat input.txt > output.txt",    // ç®¡é“é‡å®šå‘
    ];
    
    for cmd in file_ops {
        assert!(is_file_operation_command(cmd), 
                "Command '{}' should be detected as file operation", cmd);
    }
}

#[test]
fn test_file_operation_detection_windows_commands() {
    use crate::extensions::terminal::terminal_execute::is_file_operation_command;
    
    // Windows ç‰¹å®šå‘½ä»¤ï¼ˆåªåœ¨ Windows å¹³å°æµ‹è¯•ï¼‰
    #[cfg(target_os = "windows")]
    {
        let windows_ops = vec![
            "del file.txt",
            "DEL file.txt", // å¤§å°å†™ä¸æ•æ„Ÿ
            "move old.txt new.txt",
            "copy source.txt dest.txt",
            "md test_dir",
            "rd test_dir",
            "type nul > file.txt",
        ];
        
        for cmd in windows_ops {
            assert!(is_file_operation_command(cmd), 
                    "Windows command '{}' should be detected as file operation", cmd);
        }
    }
}

#[test]
fn test_file_operation_detection_non_file_commands() {
    use crate::extensions::terminal::terminal_execute::is_file_operation_command;
    
    // éæ–‡ä»¶æ“ä½œå‘½ä»¤
    let non_file_ops = vec![
        "echo hello world",      // æ™®é€š echoï¼ˆæ— é‡å®šå‘ï¼‰
        "ls -la",               // åˆ—å‡ºæ–‡ä»¶ä½†ä¸ä¿®æ”¹
        "pwd",                  // æ˜¾ç¤ºè·¯å¾„
        "cd directory",         // åˆ‡æ¢ç›®å½•
        "ps aux",               // è¿›ç¨‹åˆ—è¡¨
        "grep pattern file.txt", // æœç´¢ä½†ä¸ä¿®æ”¹
        "cat file.txt",         // è¯»å–ä½†ä¸ä¿®æ”¹
        "head -n 10 file.txt",  // è¯»å–ä½†ä¸ä¿®æ”¹
        "tail -f file.txt",     // è¯»å–ä½†ä¸ä¿®æ”¹
        "find . -name '*.txt'", // æœç´¢ä½†ä¸ä¿®æ”¹
        "history",              // å‘½ä»¤å†å²
        "whoami",               // ç”¨æˆ·ä¿¡æ¯
        "date",                 // æ˜¾ç¤ºæ—¥æœŸ
        "uptime",               // ç³»ç»Ÿä¿¡æ¯
    ];
    
    for cmd in non_file_ops {
        assert!(!is_file_operation_command(cmd), 
                "Command '{}' should NOT be detected as file operation", cmd);
    }
}

#[test]
fn test_file_operation_detection_edge_cases() {
    use crate::extensions::terminal::terminal_execute::is_file_operation_command;
    
    // è¾¹ç•Œæƒ…å†µ
    assert!(!is_file_operation_command(""), "Empty command should not be file operation");
    assert!(!is_file_operation_command("   "), "Whitespace command should not be file operation");
    assert!(!is_file_operation_command("mkdirtest"), "mkdirtest is not a complete mkdir command");
    assert!(is_file_operation_command("mkdir test"), "mkdir with argument should be detected");
    assert!(is_file_operation_command("  mkdir  test  "), "mkdir with extra whitespace should be detected");
    
    // å¤æ‚ç®¡é“å‘½ä»¤
    assert!(is_file_operation_command("ls -la | grep test > output.txt"), 
            "Pipe with file redirection should be detected");
    assert!(!is_file_operation_command("ls -la | grep test"), 
            "Pipe without file redirection should NOT be detected");
    
    // å‘½ä»¤é“¾ï¼ˆå½“å‰å®ç°ä¸æ”¯æŒå¤æ‚å‘½ä»¤é“¾æ£€æµ‹ï¼Œåªæ£€æŸ¥ç›´æ¥çš„å‘½ä»¤ï¼‰
    assert!(!is_file_operation_command("echo test && mkdir dir"), 
            "Command chain detection not implemented in current version");
}

// ============================================
// CD å‘½ä»¤ä¸“é¡¹æµ‹è¯•
// ============================================

#[test]
fn test_cd_path_resolution() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let mut block = Block::new(
        "CD Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );
    
    // è®¾ç½®åˆå§‹çŠ¶æ€
    block.contents = serde_json::json!({
        "root_path": "/tmp/test",
        "current_path": "/tmp/test",
        "current_directory": ".",
        "history": []
    });

    // æµ‹è¯• cd åˆ°ç›¸å¯¹è·¯å¾„
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "cd .."
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "cd .. should execute successfully");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    
    // cd .. åº”è¯¥è¢«é™åˆ¶åœ¨ root_path å†…
    assert_eq!(
        contents.get("current_directory").unwrap().as_str().unwrap(),
        "."
    );
}

#[test]
fn test_cd_nonexistent_directory() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "CD Error Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "cd nonexistent_directory_12345"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "cd to nonexistent directory should execute (but fail)");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], "cd nonexistent_directory_12345");
    assert_eq!(history[0]["exit_code"], 1); // åº”è¯¥å¤±è´¥
    assert!(history[0]["output"].as_str().unwrap().contains("No such file or directory"));
}

// ============================================
// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
// ============================================

#[test]
fn test_execute_command_failed_exit_code() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Failed Command Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // æµ‹è¯•ä¸€ä¸ªä¼šå¤±è´¥çš„å‘½ä»¤
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "false"  // æ€»æ˜¯è¿”å›é”™è¯¯ç 1
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Command should execute (even if it fails)");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let contents_obj = contents
        .as_object()
        .expect("contents should be an object");
    
    // æ–‡ä»¶æ“ä½œå¤±è´¥æ—¶ä¸åº”è¯¥æ ‡è®°ä¸ºéœ€è¦åŒæ­¥
    assert!(
        !contents_obj.contains_key("needs_file_sync"),
            "Failed commands should not trigger file sync");
}

#[test]
fn test_file_operation_command_failed_no_sync() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Failed File Op Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // æµ‹è¯•ä¸€ä¸ªä¼šå¤±è´¥çš„æ–‡ä»¶æ“ä½œå‘½ä»¤
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "rm nonexistent_file_12345.txt"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "rm command should execute (even if it fails)");

    let events = result.unwrap();
    let contents = events[0].value.get("contents").unwrap();
    let contents_obj = contents
        .as_object()
        .expect("contents should be an object");
    let history = contents.get("history").unwrap().as_array().unwrap();
    
    // æ£€æŸ¥å‘½ä»¤å¤±è´¥
    assert_ne!(history[0]["exit_code"], 0);
    
    // å¤±è´¥çš„æ–‡ä»¶æ“ä½œä¸åº”è¯¥è§¦å‘æ–‡ä»¶åŒæ­¥
    assert!(
        !contents_obj.contains_key("needs_file_sync"),
            "Failed file operations should not trigger sync");
    assert!(!contents_obj.contains_key("file_operation_command"));
}

// ============================================
// Terminal Write è¯¦ç»†æµ‹è¯•
// ============================================

#[test]
fn test_write_empty_payload() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.write")
        .expect("terminal.write should be registered");

    let block = Block::new(
        "Empty Payload Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!({}), // ç©ºè½½è·
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Empty payload should be handled gracefully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1);
    
    // ç©ºè½½è·åº”è¯¥ä¸åšä»»ä½•ä¿®æ”¹ï¼Œåªæ˜¯ä¿ç•™åŸæœ‰å†…å®¹
    let contents = events[0].value.get("contents").unwrap();
    assert!(contents.is_object());
}

#[test]
fn test_write_invalid_payload() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.write")
        .expect("terminal.write should be registered");

    let block = Block::new(
        "Invalid Payload Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!("invalid_payload_string"), // æ— æ•ˆè½½è·
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_err(), "Invalid payload should return error");
    
    let error = result.unwrap_err();
    assert!(error.contains("Invalid payload"), "Error should mention invalid payload");
}

// ============================================
// Terminal Read è¯¦ç»†æµ‹è¯•
// ============================================

#[test]
fn test_read_without_block() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.read")
        .expect("terminal.read should be registered");

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.read".to_string(),
        "dummy-block-id".to_string(),
        serde_json::json!({}),
    );

    let result = cap.handler(&cmd, None);
    assert!(result.is_err(), "Read without block should fail");
    
    let error = result.unwrap_err();
    assert_eq!(error, "Block required for terminal.read");
}

#[test]
fn test_read_with_block() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.read")
        .expect("terminal.read should be registered");

    let block = Block::new(
        "Read Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.read".to_string(),
        block.block_id.clone(),
        serde_json::json!({}),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Read with block should succeed");

    let events = result.unwrap();
    assert_eq!(events.len(), 0, "Read should not generate events");
}

// ============================================
// Additional Edge Cases and Error Handling Tests
// ============================================

#[test]
fn test_execute_command_with_null_bytes() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // åŒ…å«ç©ºå­—èŠ‚çš„å‘½ä»¤ï¼ˆå¯èƒ½å¯¼è‡´å®‰å…¨é—®é¢˜ï¼‰
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "echo 'test\0malicious'"}),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Command with null bytes should execute (system will handle it)");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_execute_command_with_unicode() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Unicode å­—ç¬¦å‘½ä»¤
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "echo 'ä½ å¥½ä¸–ç•Œ ğŸŒ'"}),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Unicode command should execute successfully");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_execute_command_with_extreme_whitespace() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // æç«¯ç©ºç™½å­—ç¬¦
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "   \t\n  echo test  \t\n  "}),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Command with extreme whitespace should execute");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_cd_to_current_directory() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // cd åˆ°å½“å‰ç›®å½•
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "cd ."}),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "cd . should execute successfully");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], "cd .");
    assert_eq!(history[0]["exit_code"], 0);
}

#[test]
fn test_cd_with_quotes() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // cd å¸¦å¼•å·çš„è·¯å¾„
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "cd \"test dir\""}),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "cd with quotes should execute");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_multiple_consecutive_spaces() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // å¤šä¸ªè¿ç»­ç©ºæ ¼
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "echo    hello     world"}),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Command with multiple spaces should execute");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_write_with_very_large_content() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.write")
        .expect("terminal.write should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // ç”Ÿæˆéå¸¸å¤§çš„å†…å®¹ï¼ˆä½†ä»åœ¨åˆç†èŒƒå›´å†…ï¼‰
    let large_content = "A".repeat(50000);
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "data": large_content
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Large content should be handled");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_write_with_json_object_data() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.write")
        .expect("terminal.write should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // JSON å¯¹è±¡ä½œä¸ºæ•°æ®
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "data": {"key": "value", "number": 42}
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "JSON object data should be handled");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_write_with_array_data() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.write")
        .expect("terminal.write should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // æ•°ç»„ä½œä¸ºæ•°æ®
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "data": [1, 2, 3, "test"]
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Array data should be handled");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_execute_with_mixed_slash_paths() {
    use crate::extensions::terminal::terminal_execute::is_file_operation_command;
    
    // æµ‹è¯•æ··åˆæ–œæ è·¯å¾„
    assert!(is_file_operation_command("mkdir test\\dir/subdir"));
    assert!(is_file_operation_command("touch /home/user\\file.txt"));
    assert!(is_file_operation_command("rm path/to\\file.txt"));
}

#[test]
fn test_file_operation_detection_with_arguments() {
    use crate::extensions::terminal::terminal_execute::is_file_operation_command;
    
    // å¸¦å‚æ•°çš„æ–‡ä»¶æ“ä½œå‘½ä»¤
    assert!(is_file_operation_command("mkdir -p test/dir"));
    assert!(is_file_operation_command("rm -rf olddir"));
    assert!(is_file_operation_command("cp -r source dest"));
    assert!(is_file_operation_command("mv -v old new"));
    assert!(is_file_operation_command("chmod 755 script.sh"));
    assert!(is_file_operation_command("chown user:group file.txt"));
    assert!(is_file_operation_command("touch -t 202401010000 file.txt"));
}

#[test]
fn test_file_operation_false_positives() {
    use crate::extensions::terminal::terminal_execute::is_file_operation_command;
    
    // ç¡®ä¿éæ–‡ä»¶æ“ä½œå‘½ä»¤ä¸è¢«è¯¯åˆ¤
    assert!(!is_file_operation_command("echo 'mkdir test'"));
    assert!(!is_file_operation_command("grep 'rm file' document.txt"));
    assert!(!is_file_operation_command("ps aux | grep vim"));
    assert!(!is_file_operation_command("history | grep touch"));
}

#[test]
fn test_cd_special_characters() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // cd å¸¦ç‰¹æ®Šå­—ç¬¦çš„è·¯å¾„
    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "cd /path/with-special_chars.123"}),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "cd with special characters should execute");
    
    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
}

#[test]
fn test_pwd_after_nonexistent_cd() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let mut block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // é¦–å…ˆå°è¯• cd åˆ°ä¸å­˜åœ¨çš„ç›®å½•
    let cd_cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "cd /nonexistent/path"}),
    );

    let cd_result = cap.handler(&cd_cmd, Some(&block));
    assert!(cd_result.is_ok(), "cd command should execute (but may fail)");
    
    let cd_events = cd_result.unwrap();
    if !cd_events.is_empty() {
        // æ›´æ–° block å†…å®¹
        if let Some(contents) = cd_events[0].value.get("contents") {
            block.contents = contents.clone();
        }
    }

    // ç„¶åæ‰§è¡Œ pwd
    let pwd_cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({"command": "pwd"}),
    );

    let pwd_result = cap.handler(&pwd_cmd, Some(&block));
    assert!(pwd_result.is_ok(), "pwd should execute successfully");
    
    let pwd_events = pwd_result.unwrap();
    assert_eq!(pwd_events.len(), 1, "Should generate one event for pwd");
}

