//! Tests for Terminal extension
//!
//! Generated by elfiee-ext-gen - Implement the TODO markers.
//!
//! Test categories included:
//! - Payload deserialization tests
//! - Basic capability functionality tests
//! - Authorization/CBAC tests
//! - Integration workflow tests


use super::*;
use crate::capabilities::registry::CapabilityRegistry;
use crate::capabilities::grants::GrantsTable;

use crate::models::{Block, Command};


// ============================================
// TerminalRead - Payload Tests
// ============================================

#[test]
fn test_read_payload_deserialize() {
    // TerminalReadPayload has no fields, so empty JSON should work
    let json = serde_json::json!({});

    let result: Result<TerminalReadPayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let _payload = result.unwrap();
    // No fields to verify since it's an empty struct
}

// ============================================
// TerminalRead - Functionality Tests
// ============================================

#[test]
fn test_read_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.read")
        .expect("terminal.read should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.read".to_string(),
        block.block_id.clone(),
        serde_json::json!({}), // Empty payload for read operation
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Handler should execute successfully");

    let events = result.unwrap();
    // Read operation doesn't generate events, just returns empty vec
    assert_eq!(events.len(), 0, "Read should not generate events");
}


// ============================================
// TerminalRead - Authorization Tests
// ============================================

#[test]
fn test_read_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "terminal.read", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_read_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "terminal.read", &block.block_id);

    assert!(!is_authorized, "Non-owner without grant should not be authorized");
}

#[test]
fn test_read_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "terminal.read".to_string(),
        block.block_id.clone(),
    );

    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "terminal.read", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}



// ============================================
// TerminalWrite - Payload Tests
// ============================================

#[test]
fn test_write_payload_deserialize() {
    let json = serde_json::json!({
        "data": "Hello terminal!"
    });

    let result: Result<TerminalWritePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.data, serde_json::json!("Hello terminal!"));
}

// ============================================
// TerminalWrite - Functionality Tests
// ============================================

#[test]
fn test_write_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.write")
        .expect("terminal.write should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "data": "Hello terminal!"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Handler should execute successfully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/terminal.write");

    // Verify the event contains the updated history
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["output"], "Hello terminal!");
    assert_eq!(history[0]["type"], "write");
}


// ============================================
// TerminalWrite - Authorization Tests
// ============================================

#[test]
fn test_write_authorization_owner() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Owner should always be authorized
    let is_authorized = block.owner == "alice"
        || grants_table.has_grant("alice", "terminal.write", &block.block_id);

    assert!(is_authorized, "Block owner should be authorized");
}

#[test]
fn test_write_authorization_non_owner_without_grant() {
    let grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Bob (non-owner) without grant should not be authorized
    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "terminal.write", &block.block_id);

    assert!(!is_authorized, "Non-owner without grant should not be authorized");
}

#[test]
fn test_write_authorization_non_owner_with_grant() {
    let mut grants_table = GrantsTable::new();

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Grant Bob permission
    grants_table.add_grant(
        "bob".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
    );

    let is_authorized = block.owner == "bob"
        || grants_table.has_grant("bob", "terminal.write", &block.block_id);

    assert!(is_authorized, "Non-owner with grant should be authorized");
}




// ============================================
// TerminalExecute - Tests
// ============================================

#[test]
fn test_execute_payload_deserialize() {
    let json = serde_json::json!({
        "command": "echo hello"
    });

    let result: Result<TerminalExecutePayload, _> = serde_json::from_value(json);
    assert!(result.is_ok(), "Payload should deserialize successfully");

    let payload = result.unwrap();
    assert_eq!(payload.command, "echo hello");
}

#[test]
fn test_execute_basic() {
    let registry = CapabilityRegistry::new();
    let cap = registry
        .get("terminal.execute")
        .expect("terminal.execute should be registered");

    let block = Block::new(
        "Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    let cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo hello world"
        }),
    );

    let result = cap.handler(&cmd, Some(&block));
    assert!(result.is_ok(), "Handler should execute successfully");

    let events = result.unwrap();
    assert_eq!(events.len(), 1, "Should generate one event");
    assert_eq!(events[0].entity, block.block_id);
    assert_eq!(events[0].attribute, "alice/terminal.execute");

    // Verify the event contains the command and output in history
    let contents = events[0].value.get("contents").unwrap();
    let history = contents.get("history").unwrap().as_array().unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0]["command"], "echo hello world");
    assert!(history[0]["output"].as_str().unwrap().contains("hello world"));
}

// ============================================
// Integration Workflow Test
// ============================================

#[test]
fn test_full_workflow() {
    let registry = CapabilityRegistry::new();
    let mut block = Block::new(
        "Workflow Test Block".to_string(),
        "terminal".to_string(),
        "alice".to_string(),
    );

    // Step 1: Execute a command
    let execute_cap = registry.get("terminal.execute").unwrap();
    let execute_cmd = Command::new(
        "alice".to_string(),
        "terminal.execute".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "command": "echo 'test command'"
        }),
    );

    let execute_events = execute_cap.handler(&execute_cmd, Some(&block)).unwrap();
    assert_eq!(execute_events.len(), 1);

    // Step 2: Update block state (simulate StateProjector)
    block.contents = execute_events[0].value.get("contents").unwrap().clone();

    // Step 3: Write additional content to the terminal
    let write_cap = registry.get("terminal.write").unwrap();
    let write_cmd = Command::new(
        "alice".to_string(),
        "terminal.write".to_string(),
        block.block_id.clone(),
        serde_json::json!({
            "data": "Additional output from application"
        }),
    );

    let write_events = write_cap.handler(&write_cmd, Some(&block)).unwrap();
    assert_eq!(write_events.len(), 1);

    // Step 4: Verify final state has both entries
    let final_contents = write_events[0].value.get("contents").unwrap();
    let final_history = final_contents.get("history").unwrap().as_array().unwrap();
    
    assert_eq!(final_history.len(), 2);
    // First entry from execute command
    assert_eq!(final_history[0]["command"], "echo 'test command'");
    assert!(final_history[0]["output"].as_str().unwrap().contains("test command"));
    
    // Second entry from write operation
    assert_eq!(final_history[1]["output"], "Additional output from application");
    assert_eq!(final_history[1]["type"], "write");
    assert_eq!(final_history[1]["command"], "");
}

