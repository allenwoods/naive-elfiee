/**
 * Tauri Client - Wrapper around auto-generated Tauri bindings
 *
 * This module provides a high-level interface to interact with Tauri backend.
 * It uses auto-generated bindings from tauri-specta for type-safe communication.
 */

import { open, save } from '@tauri-apps/plugin-dialog';
import { commands, type Block, type Command, type Event, type JsonValue } from '@/bindings';

/**
 * Default editor ID for single-user MVP
 */
const DEFAULT_EDITOR_ID = 'default-editor';

/**
 * Payload types for various operations
 */
export interface CreateBlockPayload {
  name: string;
  block_type: string;
}

export interface WriteBlockPayload {
  content: { type: 'text' | 'link'; data: string };
}

export interface LinkBlockPayload {
  to_id: string;
}

export interface UpdateMetadataPayload {
  metadata: Record<string, string>;
}

/**
 * File Operations
 */
export class FileOperations {
  /**
   * Open file picker dialog and create a new .elf file
   * @returns File ID if created successfully
   */
  static async createFile(): Promise<string | null> {
    const filePath = await save({
      filters: [{
        name: 'Elfiee File',
        extensions: ['elf']
      }]
    });

    if (!filePath) {
      return null;
    }

    const result = await commands.createFile(filePath);
    if (result.status === 'ok') {
      return result.data;
    } else {
      throw new Error(result.error);
    }
  }

  /**
   * Open file picker dialog and open an existing .elf file
   * @returns File ID if opened successfully
   */
  static async openFile(): Promise<string | null> {
    const filePath = await open({
      multiple: false,
      filters: [{
        name: 'Elfiee File',
        extensions: ['elf']
      }]
    });

    if (!filePath || Array.isArray(filePath)) {
      return null;
    }

    const result = await commands.openFile(filePath);
    if (result.status === 'ok') {
      return result.data;
    } else {
      throw new Error(result.error);
    }
  }

  /**
   * Save the current state of a file to disk
   * @param fileId - Unique identifier of the file
   */
  static async saveFile(fileId: string): Promise<void> {
    const result = await commands.saveFile(fileId);
    if (result.status === 'error') {
      throw new Error(result.error);
    }
  }

  /**
   * Close a file and release resources
   * @param fileId - Unique identifier of the file
   */
  static async closeFile(fileId: string): Promise<void> {
    const result = await commands.closeFile(fileId);
    if (result.status === 'error') {
      throw new Error(result.error);
    }
  }

  /**
   * Get list of all currently open files
   * @returns Array of file IDs
   */
  static async listOpenFiles(): Promise<string[]> {
    const result = await commands.listOpenFiles();
    if (result.status === 'ok') {
      return result.data;
    } else {
      throw new Error(result.error);
    }
  }
}

/**
 * Helper function to create a Command
 */
function createCommand(
  editorId: string,
  capId: string,
  blockId: string,
  payload: JsonValue
): Command {
  return {
    cmd_id: crypto.randomUUID(),
    editor_id: editorId,
    cap_id: capId,
    block_id: blockId,
    payload,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Block Operations
 */
export class BlockOperations {
  /**
   * Execute a command on a block
   * @param fileId - Unique identifier of the file
   * @param cmd - Command to execute
   * @returns Events generated by the command
   */
  static async executeCommand(fileId: string, cmd: Command): Promise<Event[]> {
    const result = await commands.executeCommand(fileId, cmd);
    if (result.status === 'ok') {
      return result.data;
    } else {
      throw new Error(result.error);
    }
  }

  /**
   * Get a specific block by ID
   * @param fileId - Unique identifier of the file
   * @param blockId - Unique identifier of the block
   * @returns The requested block
   */
  static async getBlock(fileId: string, blockId: string): Promise<Block> {
    const result = await commands.getBlock(fileId, blockId);
    if (result.status === 'ok') {
      return result.data;
    } else {
      throw new Error(result.error);
    }
  }

  /**
   * Get all blocks from a file
   * @param fileId - Unique identifier of the file
   * @returns Array of all blocks
   */
  static async getAllBlocks(fileId: string): Promise<Block[]> {
    const result = await commands.getAllBlocks(fileId);
    if (result.status === 'ok') {
      return result.data;
    } else {
      throw new Error(result.error);
    }
  }

  /**
   * Helper: Create a new block
   */
  static async createBlock(
    fileId: string,
    blockId: string,
    name: string,
    blockType: string
  ): Promise<Event[]> {
    const payload: CreateBlockPayload = {
      name,
      block_type: blockType,
    };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.create', blockId, payload as unknown as JsonValue);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Write content to a block
   */
  static async writeBlock(
    fileId: string,
    blockId: string,
    content: { type: 'text' | 'link'; data: string }
  ): Promise<Event[]> {
    const payload: WriteBlockPayload = { content };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'markdown.write', blockId, payload as unknown as JsonValue);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Delete a block
   */
  static async deleteBlock(fileId: string, blockId: string): Promise<Event[]> {
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.delete', blockId, {} as unknown as JsonValue);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Link two blocks
   */
  static async linkBlocks(fileId: string, fromId: string, toId: string): Promise<Event[]> {
    const payload: LinkBlockPayload = { to_id: toId };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.link', fromId, payload as unknown as JsonValue);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Unlink two blocks
   */
  static async unlinkBlocks(fileId: string, fromId: string, toId: string): Promise<Event[]> {
    const payload: LinkBlockPayload = { to_id: toId };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.unlink', fromId, payload as unknown as JsonValue);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Update block metadata
   */
  static async updateMetadata(
    fileId: string,
    blockId: string,
    metadata: Record<string, string>
  ): Promise<Event[]> {
    const payload: UpdateMetadataPayload = { metadata };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.update_metadata', blockId, payload as unknown as JsonValue);
    return await this.executeCommand(fileId, cmd);
  }
}

/**
 * Combined API client
 */
export const TauriClient = {
  file: FileOperations,
  block: BlockOperations,
};

// Re-export types from bindings for convenience
export type { Block, Command, Event };

export default TauriClient;
