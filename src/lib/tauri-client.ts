/**
 * Tauri Client - Wrapper around Tauri invoke commands
 *
 * This module provides a typed interface to interact with Tauri backend commands.
 * All functions return Promises and handle errors appropriately.
 */

import { invoke } from '@tauri-apps/api/core';
import { open, save } from '@tauri-apps/plugin-dialog';
import type { Block, Command, Event, CreateBlockPayload, WriteBlockPayload, LinkBlockPayload, UpdateMetadataPayload } from './types';

/**
 * Default editor ID for single-user MVP
 */
const DEFAULT_EDITOR_ID = 'default-editor';

/**
 * File Operations
 */
export class FileOperations {
  /**
   * Open file picker dialog and create a new .elf file
   * @returns File ID if created successfully
   */
  static async createFile(): Promise<string | null> {
    const filePath = await save({
      filters: [{
        name: 'Elfiee File',
        extensions: ['elf']
      }]
    });

    if (!filePath) {
      return null;
    }

    return await invoke<string>('create_file', { path: filePath });
  }

  /**
   * Open file picker dialog and open an existing .elf file
   * @returns File ID if opened successfully
   */
  static async openFile(): Promise<string | null> {
    const filePath = await open({
      multiple: false,
      filters: [{
        name: 'Elfiee File',
        extensions: ['elf']
      }]
    });

    if (!filePath || Array.isArray(filePath)) {
      return null;
    }

    return await invoke<string>('open_file', { path: filePath });
  }

  /**
   * Save the current state of a file to disk
   * @param fileId - Unique identifier of the file
   */
  static async saveFile(fileId: string): Promise<void> {
    await invoke('save_file', { fileId });
  }

  /**
   * Close a file and release resources
   * @param fileId - Unique identifier of the file
   */
  static async closeFile(fileId: string): Promise<void> {
    await invoke('close_file', { fileId });
  }

  /**
   * Get list of all currently open files
   * @returns Array of file IDs
   */
  static async listOpenFiles(): Promise<string[]> {
    return await invoke<string[]>('list_open_files');
  }
}

/**
 * Helper function to create a Command
 */
function createCommand(
  editorId: string,
  capId: string,
  blockId: string,
  payload: unknown
): Command {
  return {
    cmd_id: crypto.randomUUID(),
    editor_id: editorId,
    cap_id: capId,
    block_id: blockId,
    payload,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Block Operations
 */
export class BlockOperations {
  /**
   * Execute a command on a block
   * @param fileId - Unique identifier of the file
   * @param cmd - Command to execute
   * @returns Events generated by the command
   */
  static async executeCommand(fileId: string, cmd: Command): Promise<Event[]> {
    return await invoke<Event[]>('execute_command', { fileId, cmd });
  }

  /**
   * Get a specific block by ID
   * @param fileId - Unique identifier of the file
   * @param blockId - Unique identifier of the block
   * @returns The requested block
   */
  static async getBlock(fileId: string, blockId: string): Promise<Block> {
    return await invoke<Block>('get_block', { fileId, blockId });
  }

  /**
   * Get all blocks from a file
   * @param fileId - Unique identifier of the file
   * @returns Array of all blocks
   */
  static async getAllBlocks(fileId: string): Promise<Block[]> {
    return await invoke<Block[]>('get_all_blocks', { fileId });
  }

  /**
   * Helper: Create a new block
   */
  static async createBlock(
    fileId: string,
    blockId: string,
    parentId: string | null,
    content: { type: 'text' | 'link'; data: string }
  ): Promise<Event[]> {
    const payload: CreateBlockPayload = {
      parent_id: parentId,
      content,
    };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.create', blockId, payload);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Write content to a block
   */
  static async writeBlock(
    fileId: string,
    blockId: string,
    content: { type: 'text' | 'link'; data: string }
  ): Promise<Event[]> {
    const payload: WriteBlockPayload = { content };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'markdown.write', blockId, payload);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Delete a block
   */
  static async deleteBlock(fileId: string, blockId: string): Promise<Event[]> {
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.delete', blockId, {});
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Link two blocks
   */
  static async linkBlocks(fileId: string, fromId: string, toId: string): Promise<Event[]> {
    const payload: LinkBlockPayload = { to_id: toId };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.link', fromId, payload);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Unlink two blocks
   */
  static async unlinkBlocks(fileId: string, fromId: string, toId: string): Promise<Event[]> {
    const payload: LinkBlockPayload = { to_id: toId };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.unlink', fromId, payload);
    return await this.executeCommand(fileId, cmd);
  }

  /**
   * Helper: Update block metadata
   */
  static async updateMetadata(
    fileId: string,
    blockId: string,
    metadata: Record<string, string>
  ): Promise<Event[]> {
    const payload: UpdateMetadataPayload = { metadata };
    const cmd = createCommand(DEFAULT_EDITOR_ID, 'core.update_metadata', blockId, payload);
    return await this.executeCommand(fileId, cmd);
  }
}

/**
 * Combined API client
 */
export const TauriClient = {
  file: FileOperations,
  block: BlockOperations,
};

export default TauriClient;
