/**
 * Tauri Client - Wrapper around auto-generated Tauri bindings
 *
 * This module provides a high-level interface to interact with Tauri backend.
 * It uses auto-generated bindings from tauri-specta for type-safe communication.
 */

import { open, save } from '@tauri-apps/plugin-dialog'

import {
  commands,
  type Block,
  type Command,
  type Event,
  type Editor,
  type Grant,
  type JsonValue,
  type CreateBlockPayload,
  type LinkBlockPayload,
  type UnlinkBlockPayload,
  type GrantPayload,
  type RevokePayload,
  type TerminalSavePayload,
} from '@/bindings'
/**
 * Default editor ID for single-user MVP
 */
const DEFAULT_EDITOR_ID = 'default-editor'

/**
 * Payload types for various operations
 *
 * NOTE: All payload types are now auto-generated from Rust via tauri-specta.
 * See src/bindings.ts for:
 * - CreateBlockPayload (from models/payloads)
 * - LinkBlockPayload (from models/payloads)
 * - UnlinkBlockPayload (from models/payloads)
 * - GrantPayload (from models/payloads)
 * - RevokePayload (from models/payloads)
 * - MarkdownWritePayload (from extensions/markdown)
 */
export interface UpdateMetadataPayload {
  metadata: Record<string, string>
}

/**
 * Terminal command history entry
 */
export interface TerminalCommandEntry {
  command: string
  output: string
  timestamp: string
  exit_code: number
}

/**
 * File Operations
 */
export class FileOperations {
  /**
   * Open file picker dialog and create a new .elf file
   * @returns File ID if created successfully
   */
  static async createFile(): Promise<string | null> {
    const filePath = await save({
      filters: [
        {
          name: 'Elfiee File',
          extensions: ['elf'],
        },
      ],
    })
    console.log('[TauriClient] save returned:', filePath)

    if (!filePath) {
      return null
    }

    const result = await commands.createFile(filePath)
    console.log('[TauriClient] commands.createFile returned:', result)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Open file picker dialog and open an existing .elf file
   * @returns File ID if opened successfully
   */
  static async openFile(): Promise<string | null> {
    const filePath = await open({
      multiple: false,
      filters: [
        {
          name: 'Elfiee File',
          extensions: ['elf'],
        },
      ],
    })

    if (!filePath || Array.isArray(filePath)) {
      return null
    }

    const result = await commands.openFile(filePath)
    const listOpenFiles = await commands.listOpenFiles()
    console.log('[TauriClient] listOpenFiles:', listOpenFiles)
    console.log('[TauriClient] openFile result:', result)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Save the current state of a file to disk
   * @param fileId - Unique identifier of the file
   */
  static async saveFile(fileId: string): Promise<void> {
    const result = await commands.saveFile(fileId)
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Close a file and release resources
   * @param fileId - Unique identifier of the file
   */
  static async closeFile(fileId: string): Promise<void> {
    const result = await commands.closeFile(fileId)
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Get list of all currently open files
   * @returns Array of file IDs
   */
  static async listOpenFiles(): Promise<string[]> {
    const result = await commands.listOpenFiles()
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get all events for a specific file
   * @param fileId - Unique identifier of the file
   * @returns Array of all events for the file
   */
  static async getAllEvents(fileId: string): Promise<Event[]> {
    const result = await commands.getAllEvents(fileId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }
}

/**
 * Helper function to create a Command
 */
function createCommand(
  editorId: string,
  capId: string,
  blockId: string,
  payload: JsonValue
): Command {
  return {
    cmd_id: crypto.randomUUID(),
    editor_id: editorId,
    cap_id: capId,
    block_id: blockId,
    payload,
    timestamp: new Date().toISOString(),
  }
}

/**
 * Block Operations
 */
export class BlockOperations {
  /**
   * Execute a command on a block
   * @param fileId - Unique identifier of the file
   * @param cmd - Command to execute
   * @returns Events generated by the command
   */
  static async executeCommand(fileId: string, cmd: Command): Promise<Event[]> {
    const result = await commands.executeCommand(fileId, cmd)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get a specific block by ID
   * @param fileId - Unique identifier of the file
   * @param blockId - Unique identifier of the block
   * @returns The requested block
   */
  static async getBlock(fileId: string, blockId: string): Promise<Block> {
    const result = await commands.getBlock(fileId, blockId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get all blocks from a file
   * @param fileId - Unique identifier of the file
   * @returns Array of all blocks
   */
  static async getAllBlocks(fileId: string): Promise<Block[]> {
    const result = await commands.getAllBlocks(fileId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * List files in a block's asset directory
   * @param fileId - Unique identifier of the file
   * @param blockId - Unique identifier of the block
   * @returns List of file and directory names
   */
  static async listBlockFiles(
    fileId: string,
    blockId: string
  ): Promise<string[]> {
    const result = await commands.listBlockFiles(fileId, blockId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Helper: Create a new block
   */
  static async createBlock(
    fileId: string,
    blockId: string,
    name: string,
    blockType: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: CreateBlockPayload = {
      name,
      block_type: blockType,
    }
    const cmd = createCommand(
      editorId,
      'core.create',
      blockId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Write markdown content to a block
   *
   * Uses the strongly-typed MarkdownWritePayload which expects a direct string.
   * This payload structure is auto-generated from Rust.
   *
   * @param fileId - File ID
   * @param blockId - Block ID
   * @param content - Markdown content as a plain string
   * @param editorId - Editor performing the write
   */
  static async writeBlock(
    fileId: string,
    blockId: string,
    content: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    // Payload structure matches MarkdownWritePayload from Rust
    const payload = { content }
    const cmd = createCommand(
      editorId,
      'markdown.write',
      blockId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Delete a block
   */
  static async deleteBlock(
    fileId: string,
    blockId: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const cmd = createCommand(
      editorId,
      'core.delete',
      blockId,
      {} as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Link two blocks
   *
   * @param fileId - File ID
   * @param fromId - Source block ID
   * @param toId - Target block ID
   * @param relation - Relation type (e.g., "references", "depends_on", "contains")
   * @param editorId - Editor performing the link
   */
  static async linkBlocks(
    fileId: string,
    fromId: string,
    toId: string,
    relation: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: LinkBlockPayload = { relation, target_id: toId }
    const cmd = createCommand(
      editorId,
      'core.link',
      fromId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Unlink two blocks
   *
   * @param fileId - File ID
   * @param fromId - Source block ID
   * @param toId - Target block ID
   * @param relation - Relation type (e.g., "references", "depends_on", "contains")
   * @param editorId - Editor performing the unlink
   */
  static async unlinkBlocks(
    fileId: string,
    fromId: string,
    toId: string,
    relation: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: UnlinkBlockPayload = { relation, target_id: toId }
    const cmd = createCommand(
      editorId,
      'core.unlink',
      fromId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Update block metadata
   */
  static async updateMetadata(
    fileId: string,
    blockId: string,
    metadata: Record<string, string>,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: UpdateMetadataPayload = { metadata }
    const cmd = createCommand(
      editorId,
      'core.update_metadata',
      blockId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }
}

/**
 * Editor Operations
 */
export class EditorOperations {
  /**
   * Create a new editor for a file
   * @param fileId - Unique identifier of the file
   * @param name - Display name for the new editor
   * @returns The newly created editor
   */
  static async createEditor(fileId: string, name: string): Promise<Editor> {
    const result = await commands.createEditor(fileId, name)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * List all editors for a file
   * @param fileId - Unique identifier of the file
   * @returns Array of all editors
   */
  static async listEditors(fileId: string): Promise<Editor[]> {
    const result = await commands.listEditors(fileId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get a specific editor by ID
   * @param fileId - Unique identifier of the file
   * @param editorId - Unique identifier of the editor
   * @returns The requested editor
   */
  static async getEditor(fileId: string, editorId: string): Promise<Editor> {
    const result = await commands.getEditor(fileId, editorId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Set the active editor for a file
   * @param fileId - Unique identifier of the file
   * @param editorId - Unique identifier of the editor to set as active
   */
  static async setActiveEditor(
    fileId: string,
    editorId: string
  ): Promise<void> {
    const result = await commands.setActiveEditor(fileId, editorId)
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Get the currently active editor for a file
   * @param fileId - Unique identifier of the file
   * @returns Editor ID if one is active, null otherwise
   */
  static async getActiveEditor(fileId: string): Promise<string | null> {
    const result = await commands.getActiveEditor(fileId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * List all grants for a file
   * @param fileId - Unique identifier of the file
   * @returns Array of all grants
   */
  static async listGrants(fileId: string): Promise<Grant[]> {
    const result = await commands.listGrants(fileId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get grants for a specific editor
   * @param fileId - Unique identifier of the file
   * @param editorId - Unique identifier of the editor
   * @returns Array of grants for the editor
   */
  static async getEditorGrants(
    fileId: string,
    editorId: string
  ): Promise<Grant[]> {
    const result = await commands.getEditorGrants(fileId, editorId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get grants for a specific block
   * @param fileId - Unique identifier of the file
   * @param blockId - Unique identifier of the block
   * @returns Array of grants for the block
   */
  static async getBlockGrants(
    fileId: string,
    blockId: string
  ): Promise<Grant[]> {
    const result = await commands.getBlockGrants(fileId, blockId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Grant a capability to an editor
   * @param fileId - Unique identifier of the file
   * @param targetEditor - Editor ID to grant capability to
   * @param capability - Capability ID to grant
   * @param targetBlock - Block ID or "*" for wildcard (defaults to "*")
   * @param editorId - Editor ID performing the grant (defaults to DEFAULT_EDITOR_ID)
   * @returns Events generated by the grant
   */
  static async grantCapability(
    fileId: string,
    targetEditor: string,
    capability: string,
    targetBlock: string = '*',
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: GrantPayload = {
      target_editor: targetEditor,
      capability,
      target_block: targetBlock,
    }
    const cmd = createCommand(
      editorId,
      'core.grant',
      targetBlock,
      payload as unknown as JsonValue
    )
    return await BlockOperations.executeCommand(fileId, cmd)
  }

  /**
   * Revoke a capability from an editor
   * @param fileId - Unique identifier of the file
   * @param targetEditor - Editor ID to revoke capability from
   * @param capability - Capability ID to revoke
   * @param targetBlock - Block ID or "*" for wildcard (defaults to "*")
   * @param editorId - Editor ID performing the revoke (defaults to DEFAULT_EDITOR_ID)
   * @returns Events generated by the revoke
   */
  static async revokeCapability(
    fileId: string,
    targetEditor: string,
    capability: string,
    targetBlock: string = '*',
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: RevokePayload = {
      target_editor: targetEditor,
      capability,
      target_block: targetBlock,
    }
    const cmd = createCommand(
      editorId,
      'core.revoke',
      targetBlock,
      payload as unknown as JsonValue
    )
    return await BlockOperations.executeCommand(fileId, cmd)
  }
}

/**
 * Terminal Operations (PTY-based)
 */
export class TerminalOperations {
  /**
   * Initialize a PTY session for a terminal block
   * @param blockId - Terminal block ID
   * @param editorId - Editor ID
   * @param rows - Terminal rows
   * @param cols - Terminal columns
   * @param cwd - Optional working directory
   */
  static async initTerminal(
    blockId: string,
    editorId: string,
    rows: number,
    cols: number,
    cwd?: string
  ): Promise<void> {
    const result = await commands.asyncInitTerminal({
      block_id: blockId,
      editor_id: editorId,
      rows,
      cols,
      cwd: cwd || null,
    })
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Write data to PTY
   * @param blockId - Terminal block ID
   * @param data - Data to write (user input)
   */
  static async writeToPty(blockId: string, data: string): Promise<void> {
    const result = await commands.writeToPty({
      block_id: blockId,
      data,
    })
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Resize PTY
   * @param blockId - Terminal block ID
   * @param rows - New terminal rows
   * @param cols - New terminal columns
   */
  static async resizePty(
    blockId: string,
    rows: number,
    cols: number
  ): Promise<void> {
    const result = await commands.resizePty({
      block_id: blockId,
      rows,
      cols,
    })
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Save terminal session content to block
   * @param fileId - File ID
   * @param blockId - Terminal block ID
   * @param content - Terminal buffer content
   * @param editorId - Editor ID
   */
  static async saveSession(
    fileId: string,
    blockId: string,
    content: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: TerminalSavePayload = {
      saved_content: content,
      saved_at: new Date().toISOString(),
    }
    const cmd = createCommand(
      editorId,
      'terminal.save',
      blockId,
      payload as unknown as JsonValue
    )
    return await BlockOperations.executeCommand(fileId, cmd)
  }
}

/**
 * Combined API client
 */
export const TauriClient = {
  file: FileOperations,
  block: BlockOperations,
  editor: EditorOperations,
  terminal: TerminalOperations,
}

// Re-export types from bindings for convenience
export type { Block, Command, Event, Editor, Grant }

export default TauriClient
