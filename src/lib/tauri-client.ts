/**
 * Tauri Client - Wrapper around auto-generated Tauri bindings
 *
 * This module provides a high-level interface to interact with Tauri backend.
 * It uses auto-generated bindings from tauri-specta for type-safe communication.
 */

import { open, save } from '@tauri-apps/plugin-dialog'
import {
  commands,
  type Block,
  type Command,
  type Event,
  type Editor,
  type JsonValue,
} from '@/bindings'

/**
 * Default editor ID for single-user MVP
 */
const DEFAULT_EDITOR_ID = 'default-editor'

/**
 * Payload types for various operations
 */
export interface CreateBlockPayload {
  name: string
  block_type: string
}

export interface WriteBlockPayload {
  content: { type: 'text' | 'link'; data: string }
}

export interface LinkBlockPayload {
  to_id: string
}

export interface UpdateMetadataPayload {
  metadata: Record<string, string>
}

/**
 * File Operations
 */
export class FileOperations {
  /**
   * Open file picker dialog and create a new .elf file
   * @returns File ID if created successfully
   */
  static async createFile(): Promise<string | null> {
    const filePath = await save({
      filters: [
        {
          name: 'Elfiee File',
          extensions: ['elf'],
        },
      ],
    })

    if (!filePath) {
      return null
    }

    const result = await commands.createFile(filePath)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Open file picker dialog and open an existing .elf file
   * @returns File ID if opened successfully
   */
  static async openFile(): Promise<string | null> {
    const filePath = await open({
      multiple: false,
      filters: [
        {
          name: 'Elfiee File',
          extensions: ['elf'],
        },
      ],
    })

    if (!filePath || Array.isArray(filePath)) {
      return null
    }

    const result = await commands.openFile(filePath)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Save the current state of a file to disk
   * @param fileId - Unique identifier of the file
   */
  static async saveFile(fileId: string): Promise<void> {
    const result = await commands.saveFile(fileId)
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Close a file and release resources
   * @param fileId - Unique identifier of the file
   */
  static async closeFile(fileId: string): Promise<void> {
    const result = await commands.closeFile(fileId)
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Get list of all currently open files
   * @returns Array of file IDs
   */
  static async listOpenFiles(): Promise<string[]> {
    const result = await commands.listOpenFiles()
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }
}

/**
 * Helper function to create a Command
 */
function createCommand(
  editorId: string,
  capId: string,
  blockId: string,
  payload: JsonValue
): Command {
  return {
    cmd_id: crypto.randomUUID(),
    editor_id: editorId,
    cap_id: capId,
    block_id: blockId,
    payload,
    timestamp: new Date().toISOString(),
  }
}

/**
 * Block Operations
 */
export class BlockOperations {
  /**
   * Execute a command on a block
   * @param fileId - Unique identifier of the file
   * @param cmd - Command to execute
   * @returns Events generated by the command
   */
  static async executeCommand(fileId: string, cmd: Command): Promise<Event[]> {
    const result = await commands.executeCommand(fileId, cmd)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get a specific block by ID
   * @param fileId - Unique identifier of the file
   * @param blockId - Unique identifier of the block
   * @returns The requested block
   */
  static async getBlock(fileId: string, blockId: string): Promise<Block> {
    const result = await commands.getBlock(fileId, blockId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get all blocks from a file
   * @param fileId - Unique identifier of the file
   * @returns Array of all blocks
   */
  static async getAllBlocks(fileId: string): Promise<Block[]> {
    const result = await commands.getAllBlocks(fileId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Helper: Create a new block
   */
  static async createBlock(
    fileId: string,
    blockId: string,
    name: string,
    blockType: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: CreateBlockPayload = {
      name,
      block_type: blockType,
    }
    const cmd = createCommand(
      editorId,
      'core.create',
      blockId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Write content to a block
   */
  static async writeBlock(
    fileId: string,
    blockId: string,
    content: { type: 'text' | 'link'; data: string },
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: WriteBlockPayload = { content }
    const cmd = createCommand(
      editorId,
      'markdown.write',
      blockId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Delete a block
   */
  static async deleteBlock(
    fileId: string,
    blockId: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const cmd = createCommand(
      editorId,
      'core.delete',
      blockId,
      {} as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Link two blocks
   */
  static async linkBlocks(
    fileId: string,
    fromId: string,
    toId: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: LinkBlockPayload = { to_id: toId }
    const cmd = createCommand(
      editorId,
      'core.link',
      fromId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Unlink two blocks
   */
  static async unlinkBlocks(
    fileId: string,
    fromId: string,
    toId: string,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: LinkBlockPayload = { to_id: toId }
    const cmd = createCommand(
      editorId,
      'core.unlink',
      fromId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }

  /**
   * Helper: Update block metadata
   */
  static async updateMetadata(
    fileId: string,
    blockId: string,
    metadata: Record<string, string>,
    editorId: string = DEFAULT_EDITOR_ID
  ): Promise<Event[]> {
    const payload: UpdateMetadataPayload = { metadata }
    const cmd = createCommand(
      editorId,
      'core.update_metadata',
      blockId,
      payload as unknown as JsonValue
    )
    return await this.executeCommand(fileId, cmd)
  }
}

/**
 * Editor Operations
 */
export class EditorOperations {
  /**
   * Create a new editor for a file
   * @param fileId - Unique identifier of the file
   * @param name - Display name for the new editor
   * @returns The newly created editor
   */
  static async createEditor(fileId: string, name: string): Promise<Editor> {
    const result = await commands.createEditor(fileId, name)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * List all editors for a file
   * @param fileId - Unique identifier of the file
   * @returns Array of all editors
   */
  static async listEditors(fileId: string): Promise<Editor[]> {
    const result = await commands.listEditors(fileId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Get a specific editor by ID
   * @param fileId - Unique identifier of the file
   * @param editorId - Unique identifier of the editor
   * @returns The requested editor
   */
  static async getEditor(fileId: string, editorId: string): Promise<Editor> {
    const result = await commands.getEditor(fileId, editorId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }

  /**
   * Set the active editor for a file
   * @param fileId - Unique identifier of the file
   * @param editorId - Unique identifier of the editor to set as active
   */
  static async setActiveEditor(
    fileId: string,
    editorId: string
  ): Promise<void> {
    const result = await commands.setActiveEditor(fileId, editorId)
    if (result.status === 'error') {
      throw new Error(result.error)
    }
  }

  /**
   * Get the currently active editor for a file
   * @param fileId - Unique identifier of the file
   * @returns Editor ID if one is active, null otherwise
   */
  static async getActiveEditor(fileId: string): Promise<string | null> {
    const result = await commands.getActiveEditor(fileId)
    if (result.status === 'ok') {
      return result.data
    } else {
      throw new Error(result.error)
    }
  }
}

/**
 * Combined API client
 */
export const TauriClient = {
  file: FileOperations,
  block: BlockOperations,
  editor: EditorOperations,
}

// Re-export types from bindings for convenience
export type { Block, Command, Event, Editor }

export default TauriClient
