
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Create a new .elf file and open it for editing.
 * 
 * # Arguments
 * * `path` - Absolute path where the new .elf file should be created
 * 
 * # Returns
 * * `Ok(file_id)` - Unique identifier for the opened file
 * * `Err(message)` - Error description if creation fails
 */
async createFile(path: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Open an existing .elf file for editing.
 * 
 * # Arguments
 * * `path` - Absolute path to the .elf file to open
 * 
 * # Returns
 * * `Ok(file_id)` - Unique identifier for the opened file
 * * `Err(message)` - Error description if opening fails
 */
async openFile(path: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save the current state of a file to disk.
 * 
 * This persists all changes made since the file was opened or last saved.
 * 
 * # Arguments
 * * `file_id` - Unique identifier of the file to save
 * 
 * # Returns
 * * `Ok(())` - File saved successfully
 * * `Err(message)` - Error description if save fails
 */
async saveFile(fileId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_file", { fileId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Close a file and release associated resources.
 * 
 * This shuts down the engine actor and removes the file from memory.
 * Unsaved changes will be lost.
 * 
 * # Arguments
 * * `file_id` - Unique identifier of the file to close
 * 
 * # Returns
 * * `Ok(())` - File closed successfully
 * * `Err(message)` - Error description if close fails
 */
async closeFile(fileId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_file", { fileId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get list of all currently open files.
 * 
 * # Returns
 * * `Ok(Vec<file_id>)` - List of file IDs currently open
 * * `Err(message)` - Error description if retrieval fails
 */
async listOpenFiles() : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_open_files") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Execute a command on a block in the specified file.
 * 
 * This is the primary way to modify blocks. Commands are processed by the engine actor,
 * which handles authorization, execution, and persistence.
 * 
 * # Arguments
 * * `file_id` - Unique identifier of the file containing the block
 * * `cmd` - Command to execute (create, delete, link, write, etc.)
 * 
 * # Returns
 * * `Ok(events)` - Events generated by the command execution
 * * `Err(message)` - Error description if execution fails
 */
async executeCommand(fileId: string, cmd: Command) : Promise<Result<Event[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("execute_command", { fileId, cmd }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a specific block by ID from a file.
 * 
 * # Arguments
 * * `file_id` - Unique identifier of the file containing the block
 * * `block_id` - Unique identifier of the block to retrieve
 * 
 * # Returns
 * * `Ok(block)` - The requested block
 * * `Err(message)` - Error if file not open or block not found
 */
async getBlock(fileId: string, blockId: string) : Promise<Result<Block, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_block", { fileId, blockId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get all blocks from a file.
 * 
 * # Arguments
 * * `file_id` - Unique identifier of the file
 * 
 * # Returns
 * * `Ok(blocks)` - Vector of all blocks in the file
 * * `Err(message)` - Error if file is not open
 */
async getAllBlocks(fileId: string) : Promise<Result<Block[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_blocks", { fileId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type Block = { block_id: string; name: string; block_type: string; contents: JsonValue; children: Partial<{ [key in string]: string[] }>; owner: string }
export type Command = { cmd_id: string; editor_id: string; cap_id: string; block_id: string; payload: JsonValue; timestamp: string }
export type Event = { event_id: string; entity: string; attribute: string; value: JsonValue; timestamp: Partial<{ [key in string]: number }> }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
