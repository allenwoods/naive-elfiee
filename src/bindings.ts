// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  /**
   * Create a new .elf file and open it for editing.
   *
   * # Arguments
   * * `path` - Absolute path where the new .elf file should be created
   *
   * # Returns
   * * `Ok(file_id)` - Unique identifier for the opened file
   * * `Err(message)` - Error description if creation fails
   */
  async createFile(path: string): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('create_file', { path }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Open an existing .elf file for editing.
   *
   * # Arguments
   * * `path` - Absolute path to the .elf file to open
   *
   * # Returns
   * * `Ok(file_id)` - Unique identifier for the opened file
   * * `Err(message)` - Error description if opening fails
   */
  async openFile(path: string): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_file', { path }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Save the current state of a file to disk.
   *
   * This persists all changes made since the file was opened or last saved.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file to save
   *
   * # Returns
   * * `Ok(())` - File saved successfully
   * * `Err(message)` - Error description if save fails
   */
  async saveFile(fileId: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('save_file', { fileId }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Close a file and release associated resources.
   *
   * This shuts down the engine actor and removes the file from memory.
   * Unsaved changes will be lost.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file to close
   *
   * # Returns
   * * `Ok(())` - File closed successfully
   * * `Err(message)` - Error description if close fails
   */
  async closeFile(fileId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('close_file', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get list of all currently open files.
   *
   * # Returns
   * * `Ok(Vec<file_id>)` - List of file IDs currently open
   * * `Err(message)` - Error description if retrieval fails
   */
  async listOpenFiles(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('list_open_files') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get all events for a specific file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(Vec<Event>)` - List of all events for the file
   * * `Err(message)` - Error description if retrieval fails
   */
  async getAllEvents(fileId: string): Promise<Result<Event[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_all_events', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get detailed information about a file.
   *
   * Returns metadata including file name, path, collaborators (editors),
   * and timestamps. The file must be open to retrieve this information.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(FileMetadata)` - File metadata
   * * `Err(message)` - Error description if retrieval fails
   */
  async getFileInfo(fileId: string): Promise<Result<FileMetadata, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_file_info', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Rename a file on the filesystem.
   *
   * This updates the file path both in the filesystem and in the application state.
   * The file must be open to be renamed.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `new_name` - New name for the file (without extension)
   *
   * # Returns
   * * `Ok(())` - File renamed successfully
   * * `Err(message)` - Error description if rename fails
   */
  async renameFile(
    fileId: string,
    newName: string
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('rename_file', { fileId, newName }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Remove a file from the open files list.
   *
   * This closes the file and removes it from memory, but does NOT delete the physical file.
   * The file remains on disk and can be reopened later.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file to remove from the list
   *
   * # Returns
   * * `Ok(())` - File removed from list successfully
   * * `Err(message)` - Error description if removal fails
   */
  async deleteFile(fileId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('delete_file', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Duplicate (copy) an existing .elf file.
   *
   * This creates a copy of the file with a new name and opens it for editing.
   * The new file will have " Copy" appended to the name, or " Copy N" if that name exists.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file to duplicate
   *
   * # Returns
   * * `Ok(new_file_id)` - Unique identifier for the newly created duplicate file
   * * `Err(message)` - Error description if duplication fails
   */
  async duplicateFile(fileId: string): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('duplicate_file', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Execute a command on a block in the specified file.
   *
   * This is the primary way to modify blocks. Commands are processed by the engine actor,
   * which handles authorization, execution, and persistence.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file containing the block
   * * `cmd` - Command to execute (create, delete, link, write, etc.)
   *
   * # Returns
   * * `Ok(events)` - Events generated by the command execution
   * * `Err(message)` - Error description if execution fails
   */
  async executeCommand(
    fileId: string,
    cmd: Command
  ): Promise<Result<Event[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('execute_command', { fileId, cmd }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get a specific block by ID from a file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file containing the block
   * * `block_id` - Unique identifier of the block to retrieve
   *
   * # Returns
   * * `Ok(block)` - The requested block
   * * `Err(message)` - Error if file not open or block not found
   */
  async getBlock(
    fileId: string,
    blockId: string
  ): Promise<Result<Block, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_block', { fileId, blockId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get all blocks from a file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(blocks)` - Vector of all blocks in the file
   * * `Err(message)` - Error if file is not open
   */
  async getAllBlocks(fileId: string): Promise<Result<Block[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_all_blocks', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Create a new editor for the specified file.
   *
   * This generates a Command with editor.create capability and processes it through
   * the engine actor. The new editor is added to the file's state via event replay.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `name` - Display name for the new editor
   *
   * # Returns
   * * `Ok(Editor)` - The newly created editor
   * * `Err(message)` - Error description if creation fails
   */
  async createEditor(
    fileId: string,
    name: string
  ): Promise<Result<Editor, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_editor', { fileId, name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * List all editors for the specified file.
   *
   * Reads the editors from the StateProjector which is built from event replay.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(Vec<Editor>)` - List of all editors
   * * `Err(message)` - Error if file is not open
   */
  async listEditors(fileId: string): Promise<Result<Editor[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('list_editors', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get a specific editor by ID.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `editor_id` - Unique identifier of the editor
   *
   * # Returns
   * * `Ok(Editor)` - The requested editor
   * * `Err(message)` - Error if file not open or editor not found
   */
  async getEditor(
    fileId: string,
    editorId: string
  ): Promise<Result<Editor, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_editor', { fileId, editorId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Set the active editor for the specified file.
   *
   * This is a UI state operation and is not persisted to the .elf file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `editor_id` - Unique identifier of the editor to set as active
   *
   * # Returns
   * * `Ok(())` - Success
   * * `Err(message)` - Error if file or editor not found
   */
  async setActiveEditor(
    fileId: string,
    editorId: string
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_active_editor', { fileId, editorId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get the currently active editor for the specified file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(Option<String>)` - Editor ID if one is active, None otherwise
   * * `Err(message)` - Error if file is not open
   */
  async getActiveEditor(
    fileId: string
  ): Promise<Result<string | null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_active_editor', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * List all grants for the specified file.
   *
   * Returns all capability grants in the system as Grant objects.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(Vec<Grant>)` - List of all grants
   * * `Err(message)` - Error if file is not open
   */
  async listGrants(fileId: string): Promise<Result<Grant[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('list_grants', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get grants for a specific editor.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `editor_id` - Unique identifier of the editor
   *
   * # Returns
   * * `Ok(Vec<Grant>)` - List of grants for the editor
   * * `Err(message)` - Error if file is not open
   */
  async getEditorGrants(
    fileId: string,
    editorId: string
  ): Promise<Result<Grant[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_editor_grants', { fileId, editorId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get grants for a specific block.
   *
   * Returns all grants that apply to this block (including wildcard grants).
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `block_id` - Unique identifier of the block
   *
   * # Returns
   * * `Ok(Vec<Grant>)` - List of grants for the block
   * * `Err(message)` - Error if file is not open
   */
  async getBlockGrants(
    fileId: string,
    blockId: string
  ): Promise<Result<Grant[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_block_grants', { fileId, blockId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Initialize a new PTY session for a block.
   */
  async asyncInitTerminal(
    payload: TerminalInitPayload
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('async_init_terminal', { payload }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Write data to the PTY.
   */
  async writeToPty(
    payload: TerminalWritePayload
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('write_to_pty', { payload }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Resize the PTY.
   */
  async resizePty(
    payload: TerminalResizePayload
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('resize_pty', { payload }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Close a PTY session.
   */
  async closeTerminalSession(
    fileId: string,
    blockId: string,
    editorId: string
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('close_terminal_session', {
          fileId,
          blockId,
          editorId,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
}

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type Block = {
  block_id: string
  name: string
  block_type: string
  contents: JsonValue
  children: Partial<{ [key in string]: string[] }>
  owner: string
  /**
   * 元数据（灵活的 JSON 对象）
   *
   * 推荐使用 BlockMetadata 结构，但不强制。
   * 默认为空对象 {}
   */
  metadata: JsonValue
}
/**
 * Block 元数据结构（推荐格式）
 *
 * 存储在 Block.metadata 字段中（JSON 格式）。
 * 该结构定义了推荐的 metadata 格式，但不强制所有代码使用。
 *
 * # 字段说明
 * * `description` - Block 的详细描述
 * * `created_at` - 创建时间（ISO 8601 UTC 格式，例如："2025-12-17T02:30:00Z"）
 * * `updated_at` - 最后更新时间（ISO 8601 UTC 格式）
 * * `custom` - 自定义扩展字段（使用 #[serde(flatten)] 合并到根对象）
 */
export type BlockMetadata =
  /**
   * 自定义扩展字段
   */
  Partial<{
    [key in string]:
      | null
      | boolean
      | number
      | string
      | JsonValue[]
      | Partial<{ [key in string]: JsonValue }>
  }> & {
    /**
     * Block 描述
     */
    description?: string | null
    /**
     * 创建时间（ISO 8601 UTC）
     */
    created_at?: string | null
    /**
     * 最后更新时间（ISO 8601 UTC）
     */
    updated_at?: string | null
  }
export type Command = {
  cmd_id: string
  editor_id: string
  cap_id: string
  block_id: string
  payload: JsonValue
  /**
   * UTC timestamp when the command was created (timezone-aware)
   */
  timestamp: string
}
/**
 * Payload for core.create capability
 *
 * This payload is used to create a new block with a name and type.
 */
export type CreateBlockPayload = {
  /**
   * The display name for the new block
   */
  name: string
  /**
   * The block type (e.g., "markdown", "code", "diagram")
   */
  block_type: string
  /**
   * Optional metadata (description, custom fields, etc.)
   *
   * If provided, will be merged with auto-generated timestamps.
   * Example: { "description": "项目需求文档" }
   */
  metadata?: JsonValue | null
}
export type Editor = { editor_id: string; name: string }
/**
 * Payload for editor.create capability
 *
 * This payload is used to create a new editor identity in the file.
 */
export type EditorCreatePayload = {
  /**
   * The display name for the new editor
   */
  name: string
}
export type Event = {
  event_id: string
  entity: string
  attribute: string
  value: JsonValue
  timestamp: Partial<{ [key in string]: number }>
}
/**
 * File metadata for frontend display.
 *
 * This structure contains all information about a file that the UI needs to display,
 * including the file name, path, collaborators (editors), and timestamps.
 */
export type FileMetadata = {
  file_id: string
  name: string
  path: string
  collaborators: string[]
  created_at: string
  last_modified: string
}
/**
 * Represents a capability grant in the CBAC system.
 *
 * Grants define which editors have which capabilities on which blocks.
 * They are projected from grant/revoke events in the EventStore.
 */
export type Grant = {
  /**
   * The editor who has been granted the capability
   */
  editor_id: string
  /**
   * The capability that has been granted (e.g., "markdown.write", "core.delete")
   */
  cap_id: string
  /**
   * The target block ID, or "*" for wildcard (all blocks)
   */
  block_id: string
}
/**
 * Payload for core.grant capability
 *
 * This payload is used to grant a capability to an editor for a specific block.
 */
export type GrantPayload = {
  /**
   * The editor ID to grant the capability to
   */
  target_editor: string
  /**
   * The capability ID to grant (e.g., "markdown.write", "core.delete")
   */
  capability: string
  /**
   * The block ID to grant access to, or "*" for all blocks (wildcard)
   */
  target_block?: string
}
export type JsonValue =
  | null
  | boolean
  | number
  | string
  | JsonValue[]
  | Partial<{ [key in string]: JsonValue }>
/**
 * Payload for core.link capability
 *
 * This payload is used to create a link (relation) from one block to another.
 */
export type LinkBlockPayload = {
  /**
   * The relation type (e.g., "references", "depends_on", "contains")
   */
  relation: string
  /**
   * The target block ID to link to
   */
  target_id: string
}
/**
 * Payload for markdown.write capability
 *
 * This payload is used to write markdown content to a markdown block.
 * The content is stored directly as a string in the block's contents.markdown field.
 */
export type MarkdownWritePayload = {
  /**
   * The markdown content to write to the block
   */
  content: string
}
/**
 * Payload for core.revoke capability
 *
 * This payload is used to revoke a capability from an editor for a specific block.
 */
export type RevokePayload = {
  /**
   * The editor ID to revoke the capability from
   */
  target_editor: string
  /**
   * The capability ID to revoke
   */
  capability: string
  /**
   * The block ID to revoke access from, or "*" for all blocks (wildcard)
   */
  target_block?: string
}
export type TerminalInitPayload = {
  cols: number
  rows: number
  block_id: string
  editor_id: string
  file_id: string
  cwd: string | null
}
export type TerminalResizePayload = {
  cols: number
  rows: number
  block_id: string
  file_id: string
  editor_id: string
}
/**
 * Payload for terminal.save capability
 *
 * This payload is used to save terminal content (buffer snapshot) to a terminal block.
 */
export type TerminalSavePayload = {
  /**
   * The terminal content to save (typically from xterm.js buffer)
   */
  saved_content: string
  /**
   * Timestamp when the content was saved
   */
  saved_at: string
}
export type TerminalWritePayload = {
  data: string
  block_id: string
  file_id: string
  editor_id: string
}
/**
 * Payload for core.unlink capability
 *
 * This payload is used to remove a link (relation) from one block to another.
 */
export type UnlinkBlockPayload = {
  /**
   * The relation type (e.g., "references", "depends_on", "contains")
   */
  relation: string
  /**
   * The target block ID to unlink
   */
  target_id: string
}

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from '@tauri-apps/api/core'
import * as TAURI_API_EVENT from '@tauri-apps/api/event'
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow'

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>
}

export type Result<T, E> =
  | { status: 'ok'; data: T }
  | { status: 'error'; error: E }

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>
      }
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T]

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg)
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg)
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg)
            }
          },
        })
      },
    }
  )
}
