// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  /**
   * Create a new .elf file and open it for editing.
   *
   * # Arguments
   * * `path` - Absolute path where the new .elf file should be created
   *
   * # Returns
   * * `Ok(file_id)` - Unique identifier for the opened file
   * * `Err(message)` - Error description if creation fails
   */
  async createFile(path: string): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('create_file', { path }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Open an existing .elf file for editing.
   *
   * # Arguments
   * * `path` - Absolute path to the .elf file to open
   *
   * # Returns
   * * `Ok(file_id)` - Unique identifier for the opened file
   * * `Err(message)` - Error description if opening fails
   */
  async openFile(path: string): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_file', { path }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Save the current state of a file to disk.
   *
   * This persists all changes made since the file was opened or last saved.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file to save
   *
   * # Returns
   * * `Ok(())` - File saved successfully
   * * `Err(message)` - Error description if save fails
   */
  async saveFile(fileId: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('save_file', { fileId }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Close a file and release associated resources.
   *
   * This shuts down the engine actor and removes the file from memory.
   * Unsaved changes will be lost.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file to close
   *
   * # Returns
   * * `Ok(())` - File closed successfully
   * * `Err(message)` - Error description if close fails
   */
  async closeFile(fileId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('close_file', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get list of all currently open files.
   *
   * # Returns
   * * `Ok(Vec<file_id>)` - List of file IDs currently open
   * * `Err(message)` - Error description if retrieval fails
   */
  async listOpenFiles(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('list_open_files') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get all events for a specific file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(Vec<Event>)` - List of all events for the file
   * * `Err(message)` - Error description if retrieval fails
   */
  async getAllEvents(fileId: string): Promise<Result<Event[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_all_events', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get detailed information about a file.
   *
   * Returns metadata including file name, path, collaborators (editors),
   * and timestamps. The file must be open to retrieve this information.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(FileMetadata)` - File metadata
   * * `Err(message)` - Error description if retrieval fails
   */
  async getFileInfo(fileId: string): Promise<Result<FileMetadata, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_file_info', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Rename a file on the filesystem.
   *
   * This updates the file path both in the filesystem and in the application state.
   * The file must be open to be renamed.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `new_name` - New name for the file (without extension)
   *
   * # Returns
   * * `Ok(())` - File renamed successfully
   * * `Err(message)` - Error description if rename fails
   */
  async renameFile(
    fileId: string,
    newName: string
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('rename_file', { fileId, newName }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Remove a file from the open files list.
   *
   * This closes the file and removes it from memory, but does NOT delete the physical file.
   * The file remains on disk and can be reopened later.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file to remove from the list
   *
   * # Returns
   * * `Ok(())` - File removed from list successfully
   * * `Err(message)` - Error description if removal fails
   */
  async deleteFile(fileId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('delete_file', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Duplicate (copy) an existing .elf file.
   *
   * This creates a copy of the file with a new name and opens it for editing.
   * The new file will have " Copy" appended to the name, or " Copy N" if that name exists.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file to duplicate
   *
   * # Returns
   * * `Ok(new_file_id)` - Unique identifier for the newly created duplicate file
   * * `Err(message)` - Error description if duplication fails
   */
  async duplicateFile(fileId: string): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('duplicate_file', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get the global system editor ID from config.
   *
   * This returns the persistent system editor ID that is stored in
   * the user's home directory config file (`$USER_HOME/.elf/config.json`).
   *
   * # Returns
   * * `Ok(String)` - The system editor ID (UUID)
   * * `Err(message)` - Error if config cannot be read
   */
  async getSystemEditorIdFromConfig(): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_system_editor_id_from_config'),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Execute a command on a block in the specified file.
   *
   * This is the primary way to modify blocks. Commands are processed by the engine actor,
   * which handles authorization, execution, and persistence.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file containing the block
   * * `cmd` - Command to execute (create, delete, link, write, etc.)
   *
   * # Returns
   * * `Ok(events)` - Events generated by the command execution
   * * `Err(message)` - Error description if execution fails
   */
  async executeCommand(
    fileId: string,
    cmd: Command
  ): Promise<Result<Event[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('execute_command', { fileId, cmd }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get a specific block by ID from a file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file containing the block
   * * `block_id` - Unique identifier of the block to retrieve
   *
   * # Returns
   * * `Ok(block)` - The requested block
   * * `Err(message)` - Error if file not open or block not found
   */
  async getBlock(
    fileId: string,
    blockId: string
  ): Promise<Result<Block, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_block', { fileId, blockId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get all blocks from a file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(blocks)` - Vector of all blocks in the file
   * * `Err(message)` - Error if file is not open
   */
  async getAllBlocks(fileId: string): Promise<Result<Block[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_all_blocks', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Update block metadata.
   *
   * This generates a Command with core.update_metadata capability and processes it through
   * the engine actor. The metadata is merged with existing metadata and updated via event replay.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file containing the block
   * * `block_id` - Unique identifier of the block to update
   * * `metadata` - Metadata fields to update (will be merged with existing metadata)
   *
   * # Returns
   * * `Ok(())` - Metadata updated successfully
   * * `Err(message)` - Error description if update fails
   */
  async updateBlockMetadata(
    fileId: string,
    blockId: string,
    metadata: JsonValue
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('update_block_metadata', {
          fileId,
          blockId,
          metadata,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Rename a block.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `block_id` - Unique identifier of the block
   * * `name` - New name for the block
   */
  async renameBlock(
    fileId: string,
    blockId: string,
    name: string
  ): Promise<Result<Event[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('rename_block', { fileId, blockId, name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Update block type.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `block_id` - Unique identifier of the block
   * * `block_type` - New type for the block
   */
  async updateBlockType(
    fileId: string,
    blockId: string,
    blockType: string
  ): Promise<Result<Event[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('update_block_type', {
          fileId,
          blockId,
          blockType,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Check if current editor has permission for a capability on a block.
   */
  async checkPermission(
    fileId: string,
    blockId: string,
    capability: string
  ): Promise<Result<boolean, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('check_permission', {
          fileId,
          blockId,
          capability,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Create a new editor for the specified file.
   *
   * This generates a Command with editor.create capability and processes it through
   * the engine actor. The new editor is added to the file's state via event replay.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `name` - Display name for the new editor
   *
   * # Returns
   * * `Ok(Editor)` - The newly created editor
   * * `Err(message)` - Error description if creation fails
   */
  async createEditor(
    fileId: string,
    name: string,
    editorType: string | null
  ): Promise<Result<Editor, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_editor', { fileId, name, editorType }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Delete an editor identity from the specified file.
   *
   * This generates a Command with editor.delete capability and processes it through
   * the engine actor. The editor and associated grants are removed from the state.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `editor_id` - Unique identifier of the editor to delete
   *
   * # Returns
   * * `Ok(())` - Success
   * * `Err(message)` - Error description if deletion fails
   */
  async deleteEditor(
    fileId: string,
    editorId: string
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('delete_editor', { fileId, editorId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * List all editors for the specified file.
   *
   * Reads the editors from the StateProjector which is built from event replay.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(Vec<Editor>)` - List of all editors
   * * `Err(message)` - Error if file is not open
   */
  async listEditors(fileId: string): Promise<Result<Editor[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('list_editors', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get a specific editor by ID.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `editor_id` - Unique identifier of the editor
   *
   * # Returns
   * * `Ok(Editor)` - The requested editor
   * * `Err(message)` - Error if file not open or editor not found
   */
  async getEditor(
    fileId: string,
    editorId: string
  ): Promise<Result<Editor, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_editor', { fileId, editorId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Set the active editor for the specified file.
   *
   * This is a UI state operation and is not persisted to the .elf file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `editor_id` - Unique identifier of the editor to set as active
   *
   * # Returns
   * * `Ok(())` - Success
   * * `Err(message)` - Error if file or editor not found
   */
  async setActiveEditor(
    fileId: string,
    editorId: string
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_active_editor', { fileId, editorId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get the currently active editor for the specified file.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(Option<String>)` - Editor ID if one is active, None otherwise
   * * `Err(message)` - Error if file is not open
   */
  async getActiveEditor(
    fileId: string
  ): Promise<Result<string | null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_active_editor', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * List all grants for the specified file.
   *
   * Returns all capability grants in the system as Grant objects.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   *
   * # Returns
   * * `Ok(Vec<Grant>)` - List of all grants
   * * `Err(message)` - Error if file is not open
   */
  async listGrants(fileId: string): Promise<Result<Grant[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('list_grants', { fileId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get grants for a specific editor.
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `editor_id` - Unique identifier of the editor
   *
   * # Returns
   * * `Ok(Vec<Grant>)` - List of grants for the editor
   * * `Err(message)` - Error if file is not open
   */
  async getEditorGrants(
    fileId: string,
    editorId: string
  ): Promise<Result<Grant[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_editor_grants', { fileId, editorId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Get grants for a specific block.
   *
   * Returns all grants that apply to this block (including wildcard grants).
   *
   * # Arguments
   * * `file_id` - Unique identifier of the file
   * * `block_id` - Unique identifier of the block
   *
   * # Returns
   * * `Ok(Vec<Grant>)` - List of grants for the block
   * * `Err(message)` - Error if file is not open
   */
  async getBlockGrants(
    fileId: string,
    blockId: string
  ): Promise<Result<Grant[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_block_grants', { fileId, blockId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Materialize blocks to the external file system (Checkout).
   *
   * This command implements the bottom-layer I/O ability:
   * 1. Calls the `directory.export` capability for authorization and auditing.
   * 2. If authorized, performs the 'checkout' by writing block contents to the target path.
   */
  async checkoutWorkspace(
    fileId: string,
    blockId: string,
    payload: DirectoryExportPayload
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('checkout_workspace', {
          fileId,
          blockId,
          payload,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Initialize a new PTY session for a block.
   */
  async asyncInitTerminal(
    payload: TerminalInitPayload
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('async_init_terminal', { payload }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Write data to the PTY.
   */
  async writeToPty(
    payload: TerminalWritePayload
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('write_to_pty', { payload }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Resize the PTY.
   */
  async resizePty(
    payload: TerminalResizePayload
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('resize_pty', { payload }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * Close a PTY session.
   */
  async closeTerminalSession(
    fileId: string,
    blockId: string,
    editorId: string
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('close_terminal_session', {
          fileId,
          blockId,
          editorId,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
}

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type Block = {
  block_id: string
  name: string
  block_type: string
  contents: JsonValue
  children: Partial<{ [key in string]: string[] }>
  owner: string
  /**
   * Block metadata with timestamps and custom fields
   */
  metadata: BlockMetadata
}
/**
 * Block metadata structure (recommended format)
 *
 * Stored in Block.metadata field (JSON format).
 * This structure defines the recommended metadata format, but is not enforced.
 *
 * # Fields
 * * `description` - Detailed description of the block
 * * `created_at` - Creation timestamp (ISO 8601 UTC format, e.g., "2025-12-17T02:30:00Z")
 * * `updated_at` - Last update timestamp (ISO 8601 UTC format)
 * * `custom` - Custom extension fields (merged into root object via #[serde(flatten)])
 */
export type BlockMetadata =
  /**
   * Custom extension fields
   */
  Partial<{
    [key in string]:
      | null
      | boolean
      | number
      | string
      | JsonValue[]
      | Partial<{ [key in string]: JsonValue }>
  }> & {
    /**
     * Block description
     */
    description?: string | null
    /**
     * Creation timestamp (ISO 8601 UTC)
     */
    created_at?: string | null
    /**
     * Last update timestamp (ISO 8601 UTC)
     */
    updated_at?: string | null
  }
/**
 * Payload for CodeRead
 */
export type CodeReadPayload = Record<string, never>
/**
 * Payload for CodeWrite
 */
export type CodeWritePayload = {
  /**
   * The source code text content to write
   */
  content: string
}
export type Command = {
  cmd_id: string
  editor_id: string
  cap_id: string
  block_id: string
  payload: JsonValue
  /**
   * UTC timestamp when the command was created (timezone-aware)
   */
  timestamp: string
}
/**
 * Payload for core.create capability
 *
 * This payload is used to create a new block with a name and type.
 */
export type CreateBlockPayload = {
  /**
   * The display name for the new block
   */
  name: string
  /**
   * The block type (e.g., "markdown", "code", "diagram")
   */
  block_type: string
  /**
   * Optional metadata (description, custom fields, etc.)
   *
   * If provided, will be merged with auto-generated timestamps.
   * Example: { "description": "项目需求文档" }
   */
  metadata?: JsonValue | null
}
/**
 * Payload for DirectoryCreate
 *
 * Creates a new file or directory inside the Directory Block.
 */
export type DirectoryCreatePayload = {
  /**
   * Internal virtual path (e.g., "docs/README.md")
   */
  path: string
  /**
   * Entry type: "file" or "directory"
   */
  type: string
  /**
   * Initial content (for files only, optional)
   */
  content?: string | null
  /**
   * Block type (for files only)
   * Example: "markdown", "code"
   */
  block_type?: string | null
}
/**
 * Payload for DirectoryDelete
 *
 * Deletes a file or directory from the Directory Block (cascade delete).
 */
export type DirectoryDeletePayload = {
  /**
   * Virtual path to delete
   */
  path: string
}
/**
 * Payload for DirectoryExport
 *
 * Exports files from Directory Block to external file system.
 */
export type DirectoryExportPayload = {
  /**
   * Target external path (where to write)
   * Example: "/Users/me/output/exported-project"
   */
  target_path: string
  /**
   * Internal virtual path (optional, to export only a subdirectory)
   * None means export entire project
   * Example: "src"
   */
  source_path?: string | null
}
/**
 * Payload for DirectoryImport
 *
 * Imports files from an external directory into the Directory Block.
 */
export type DirectoryImportPayload = {
  /**
   * External file system path (source)
   * Example: "/Users/me/projects/my-app"
   */
  source_path: string
  /**
   * Internal virtual path prefix (target)
   * None or "/" means import to root directory
   * Example: "libs/external"
   */
  target_path?: string | null
}
/**
 * Payload for DirectoryRename
 *
 * Renames or moves a file/directory, syncs Block.name for files.
 */
export type DirectoryRenamePayload = {
  /**
   * Old path
   */
  old_path: string
  /**
   * New path
   */
  new_path: string
}
/**
 * Payload for directory.write capability.
 *
 * Used to directly update the entries map of a directory block.
 */
export type DirectoryWritePayload = {
  /**
   * The full entries map to be saved
   */
  entries: JsonValue
}
export type Editor = {
  editor_id: string
  name: string
  editor_type?: EditorType
}
/**
 * Payload for editor.create capability
 *
 * This payload is used to create a new editor identity in the file.
 */
export type EditorCreatePayload = {
  /**
   * The display name for the new editor
   */
  name: string
  /**
   * The type of editor (Human or Bot), defaults to Human if not specified
   */
  editor_type?: string | null
  /**
   * Optional explicitly provided editor ID (e.g. system editor ID)
   */
  editor_id?: string | null
}
/**
 * Payload for editor.delete capability
 *
 * This payload is used to delete an editor identity from the file.
 */
export type EditorDeletePayload = {
  /**
   * The editor ID to delete
   */
  editor_id: string
}
export type EditorType = 'Human' | 'Bot'
export type Event = {
  event_id: string
  entity: string
  attribute: string
  value: JsonValue
  timestamp: Partial<{ [key in string]: number }>
}
/**
 * File metadata for frontend display.
 *
 * This structure contains all information about a file that the UI needs to display,
 * including the file name, path, collaborators (editors), and timestamps.
 */
export type FileMetadata = {
  file_id: string
  name: string
  path: string
  collaborators: string[]
  created_at: string
  updated_at: string
}
/**
 * Represents a capability grant in the CBAC system.
 *
 * Grants define which editors have which capabilities on which blocks.
 * They are projected from grant/revoke events in the EventStore.
 */
export type Grant = {
  /**
   * The editor who has been granted the capability
   */
  editor_id: string
  /**
   * The capability that has been granted (e.g., "markdown.write", "core.delete")
   */
  cap_id: string
  /**
   * The target block ID, or "*" for wildcard (all blocks)
   */
  block_id: string
}
/**
 * Payload for core.grant capability
 *
 * This payload is used to grant a capability to an editor for a specific block.
 */
export type GrantPayload = {
  /**
   * The editor ID to grant the capability to
   */
  target_editor: string
  /**
   * The capability ID to grant (e.g., "markdown.write", "core.delete")
   */
  capability: string
  /**
   * The block ID to grant access to, or "*" for all blocks (wildcard)
   */
  target_block?: string
}
export type JsonValue =
  | null
  | boolean
  | number
  | string
  | JsonValue[]
  | Partial<{ [key in string]: JsonValue }>
/**
 * Payload for core.link capability
 *
 * This payload is used to create a link (relation) from one block to another.
 */
export type LinkBlockPayload = {
  /**
   * The relation type (e.g., "references", "depends_on", "contains")
   */
  relation: string
  /**
   * The target block ID to link to
   */
  target_id: string
}
/**
 * Payload for markdown.write capability
 *
 * This payload is used to write markdown content to a markdown block.
 * The content is stored directly as a string in the block's contents.markdown field.
 */
export type MarkdownWritePayload = {
  /**
   * The markdown content to write to the block
   */
  content: string
}
/**
 * Payload for core.revoke capability
 *
 * This payload is used to revoke a capability from an editor for a specific block.
 */
export type RevokePayload = {
  /**
   * The editor ID to revoke the capability from
   */
  target_editor: string
  /**
   * The capability ID to revoke
   */
  capability: string
  /**
   * The block ID to revoke access from, or "*" for all blocks (wildcard)
   */
  target_block?: string
}
export type TerminalInitPayload = {
  cols: number
  rows: number
  block_id: string
  editor_id: string
  file_id: string
  cwd: string | null
}
export type TerminalResizePayload = {
  cols: number
  rows: number
  block_id: string
  file_id: string
  editor_id: string
}
/**
 * Payload for terminal.save capability
 *
 * This payload is used to save terminal content (buffer snapshot) to a terminal block.
 */
export type TerminalSavePayload = {
  /**
   * The terminal content to save (typically from xterm.js buffer)
   */
  saved_content: string
  /**
   * Timestamp when the content was saved
   */
  saved_at: string
}
export type TerminalWritePayload = {
  data: string
  block_id: string
  file_id: string
  editor_id: string
}
/**
 * Payload for core.unlink capability
 *
 * This payload is used to remove a link (relation) from one block to another.
 */
export type UnlinkBlockPayload = {
  /**
   * The relation type (e.g., "references", "depends_on", "contains")
   */
  relation: string
  /**
   * The target block ID to unlink
   */
  target_id: string
}
/**
 * Payload for core.update_metadata capability
 *
 * This payload is used to update metadata fields of an existing block.
 * The metadata will be merged with existing metadata (not replaced).
 */
export type UpdateMetadataPayload = {
  /**
   * Metadata fields to update or add
   * Example: { "description": "Updated description", "tags": ["tag1", "tag2"] }
   */
  metadata: JsonValue
}

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from '@tauri-apps/api/core'
import * as TAURI_API_EVENT from '@tauri-apps/api/event'
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow'

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>
}

export type Result<T, E> =
  | { status: 'ok'; data: T }
  | { status: 'error'; error: E }

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>
      }
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T]

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg)
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg)
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg)
            }
          },
        })
      },
    }
  )
}
